<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train B√©tail - Jeu Snake am√©lior√©</title>
<style>
  body {
    background-color: #000;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
    user-select: none;
  }
  h1 {
    margin-top: 20px;
  }
  #gameCanvas {
    background-color: #111;
    border: 3px solid #0ff;
    margin-top: 20px;
    display: block;
  }
  #info {
    margin-top: 15px;
    font-size: 18px;
    text-align: center;
    max-width: 400px;
  }
</style>
</head>
<body>

  <div id="gameOverMessage" style="
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #0ff;
  font-family: 'Orbitron', monospace;
  font-size: 48px;
  text-shadow:
    0 0 5px #0ff,
    0 0 10px #0ff,
    0 0 20px #0ff,
    0 0 40px #0ff;
  background: rgba(0,0,0,0.8);
  padding: 20px 40px;
  border: 3px solid #0ff;
  border-radius: 10px;
  display: none;
  z-index: 1000;
  pointer-events: none;
  user-select: none;
"></div>

<h1>Train B√©tail - √âvite les suppressions !</h1>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="info">
  Utilise les <b>fl√®ches</b> pour tourner.<br>
  Prends le <span style="color: yellow;">b√©tail jaune</span> pour augmenter la capacit√© du train.<br>
  √âvite les <span style="color: red;">cases rouges (suppression)</span>.<br>
  Les <span style="color: orange;">cases perturbations oranges</span> ralentissent ou acc√©l√®rent le train pendant 2s.<br>
  Attention aux <span style="color: white;">vaches blanches</span> qui traversent la voie !<br> <!-- ajout√© -->
  La vitesse augmente progressivement avec le temps.<br>
  Score : <span id="score">0</span>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const gridSize = 20;
  const cols = canvas.width / gridSize;
  const rows = canvas.height / gridSize;

  const colorTrainHead = "#0ff";
  const colorTrainBody = "#088";
  const colorSuppression = "#f33";
  const colorAcceleration = "#f90";
  const colorBetail = "#ff0";
  const colorVache = "#0a0"; // vert sombre pour vaches

  let train = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  let direction = { x: 0, y: -1 }; // initial vers le haut
  let nextDirection = direction;

  let speed = 300;
  let baseSpeed = 300;
  let speedModifier = 0; // en ms, ajout√© ou retir√© temporairement
  let speedEffectTimeout = null;

  let betail = null; // case jaune (b√©tail)
  let suppressions = [];
  let oranges = [];

  let vaches = []; // tableau des vaches traversantes
  let vachesActive = false; // elles commencent √† 60s

  let score = 0;
  let gameStopped = false;
  const scoreEl = document.getElementById("score");

  // Messages rigolos suppression
  const messagesSuppression = [
  "Train supprim√© pour cause de vaches r√©fractaires sur les voies üêÑ",
  "Probl√®me de personnel : le chef de bord est coinc√© √† la caf√©t√©ria ‚òï",
  "Suppression suite √† une panne d'humour du conducteur üòÇ",
  "Train annul√© pour cause de gr√®ve surprise (√©videmment)",
  "Incident technique myst√©rieux. L'ing√©nieur cherche encore... üîß",
  "Train supprim√© pour cause de 'conditions exceptionnelles' (comme d‚Äôhab)",
  "Locomotive fatigu√©e. Repos obligatoire üöÇüí§",
  "Feu rouge bloqu√© sur rouge permanent üî¥",
  "Erreur informatique : suppression automatique valid√©e ‚úÖ",
  "Train absorb√© par un vortex administratif üåÄ",
  "Exc√®s de confiance du planning pr√©visionnel üìÖ",
  "La SNCF vous pr√©sente ses excuses (une fois de plus)",
  "Train supprim√© pour cause de feuille sur la voie üçÇ",
  "Incident sur la cat√©naire (les pigeons ont encore frapp√©) üïäÔ∏è‚ö°",
  "Mauvaise humeur collective du jour üåßÔ∏è",
  "Train annul√© pour respecter la tradition luxembourgeoise",
  "Suppression √† titre purement pr√©ventif (on ne sait jamais...)",
  "Chauffeur t√©l√©port√© directement √† la pause d√©jeuner ü•ê"
  ];

  // Fonction utilitaire pour g√©n√©rer une position libre (pas sur train, ni sur perturbations ni sur vaches)
  function randomFreePosition() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
    } while (
      isOnTrain(pos) ||
      isOnSuppression(pos) ||
      isOnOrange(pos) ||
      isOnVache(pos) ||
      (betail && betail.x === pos.x && betail.y === pos.y)
    );
    return pos;
  }

  function isOnTrain(pos) {
    return train.some(t => t.x === pos.x && t.y === pos.y);
  }
  function isOnSuppression(pos) {
    return suppressions.some(p => p.x === pos.x && p.y === pos.y);
  }
  function isOnOrange(pos) {
    return oranges.some(p => p.x === pos.x && p.y === pos.y);
  }
  function isOnVache(pos) {
    return vaches.some(v => v.x === pos.x && v.y === pos.y);
  }

  function placePerturbations() {
    suppressions = [];
    for(let i = 0; i < 8; i++) {
      suppressions.push(randomFreePosition());
    }
    oranges = [];
    for(let i = 0; i < 5; i++) {
      oranges.push(randomFreePosition());
    }
    betail = randomFreePosition();
  }

  // --- VACHES ---

  // G√©n√©rer une ligne de 2 √† 4 vaches traversant horizontalement
  function generateVaches() {
    const count = 2 + Math.floor(Math.random() * 3); // 2,3 ou 4 vaches
    const y = Math.floor(Math.random() * rows);
    let startX, dx;
    if (Math.random() < 0.5) {
      // traversent de gauche √† droite
      startX = 0 - count; // commencent hors champ √† gauche
      dx = 1;
    } else {
      // traversent de droite √† gauche
      startX = cols + count; // commencent hors champ √† droite
      dx = -1;
    }
    vaches = [];
    for(let i = 0; i < count; i++) {
      vaches.push({ x: startX + i, y: y, dx: dx });
    }
  }

  // D√©placer les vaches chaque frame (une case selon dx)
  function moveVaches() {
    for(let i = 0; i < vaches.length; i++) {
      vaches[i].x += vaches[i].dx;
    }
    // Supprimer les vaches compl√®tement hors √©cran
    vaches = vaches.filter(v => v.x >= -5 && v.x <= cols + 5);
  }

  // Dessiner les vaches
  function drawVaches() {
  vaches.forEach(v => {
    ctx.fillStyle = "#fff"; // blanc pour les vaches
    ctx.fillRect(v.x * gridSize + 1, v.y * gridSize + 1, gridSize - 2, gridSize - 2);
  });
}

  // Gestion de la fr√©quence d'apparition des vaches
  let vacheInterval = null;
  let vacheFrequency = 20000; // initialement 20 sec entre apparition (apr√®s 60s d√©but)
  let gameStartTime = Date.now();

  function scheduleNextVaches() {
    if(!vachesActive) return;
    generateVaches();
    // programme la prochaine apparition avec un d√©lai al√©atoire autour de vacheFrequency
    const delay = vacheFrequency / 2 + Math.random() * vacheFrequency;
    vacheInterval = setTimeout(() => {
      scheduleNextVaches();
    }, delay);
  }

  // Augmentation progressive fr√©quence vaches (plus fr√©quentes toutes les minutes)
  function increaseVacheFrequency() {
    if(vacheFrequency > 5000) {
      vacheFrequency -= 2000; // diminue d√©lai entre vagues, donc plus fr√©quent
    }
    setTimeout(increaseVacheFrequency, 60000); // toutes les 60s on augmente la fr√©quence
  }

  // --- FIN VACHES ---

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grille
    ctx.strokeStyle = "#222";
    for(let x = 0; x <= cols; x++) {
      ctx.beginPath();
      ctx.moveTo(x * gridSize, 0);
      ctx.lineTo(x * gridSize, canvas.height);
      ctx.stroke();
    }
    for(let y = 0; y <= rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * gridSize);
      ctx.lineTo(canvas.width, y * gridSize);
      ctx.stroke();
    }

    // Suppressions rouges
    suppressions.forEach(p => {
      ctx.fillStyle = colorSuppression;
      ctx.fillRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4);
    });

    // Oranges (bonus/malus)
    oranges.forEach(p => {
      ctx.fillStyle = colorAcceleration;
      ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8);
    });

    // B√©tail jaune
    if (betail) {
      ctx.fillStyle = colorBetail;
      ctx.beginPath();
      const cx = betail.x * gridSize + gridSize/2;
      const cy = betail.y * gridSize + gridSize/2;
      const radius = gridSize/3;
      ctx.arc(cx, cy, radius, 0, 2*Math.PI);
      ctx.fill();
    }

    // Vaches
    drawVaches();

    // Train
    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? colorTrainHead : colorTrainBody;
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  // Augmentation progressive de la vitesse par paliers (plus c'est long, plus c'est rapide)
  function increaseSpeedOverTime() {
    if (baseSpeed > 80) {
      baseSpeed -= 10; // augmente la vitesse (diminue le d√©lai)
    }
    scheduleNextSpeedIncrease();
  }
  function scheduleNextSpeedIncrease() {
    setTimeout(() => {
      increaseSpeedOverTime();
    }, 60000);
  }

  function gameOver(message) {
  const div = document.getElementById("gameOverMessage");
  div.textContent = message + "\nScore final: " + score;
  div.style.display = "block";

  // animation fade in
  div.style.opacity = 0;
  let opacity = 0;
  const fadeIn = setInterval(() => {
    opacity += 0.05;
    if (opacity >= 1) {
      clearInterval(fadeIn);
      // apr√®s 4s, fade out et reload
      setTimeout(() => {
        const fadeOut = setInterval(() => {
          opacity -= 0.05;
          if (opacity <= 0) {
            clearInterval(fadeOut);
            div.style.display = "none";
            document.location.reload();
          }
          div.style.opacity = opacity;
        }, 50);
      }, 4000);
    }
    div.style.opacity = opacity;
  }, 50);
}

  // Quand le train touche une case suppression, on affiche un message rigolo al√©atoire
  function handleSuppression() {
  const msg = messagesSuppression[Math.floor(Math.random() * messagesSuppression.length)];
  showGameOver(msg);
}

  let shakeCount = 0;
  const maxShakes = 10;

  const shakeInterval = setInterval(() => {
    const dx = (Math.random() - 0.5) * 10;  // d√©placement horizontal al√©atoire
    const dy = (Math.random() - 0.5) * 10;  // d√©placement vertical al√©atoire

    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.translate(dx, dy);
    draw(); // on redessine avec le l√©ger d√©calage
    ctx.restore();

    shakeCount++;
    if (shakeCount >= maxShakes) {
      clearInterval(shakeInterval);
      showGameOver(msg);
      setTimeout(() => {
        document.location.reload();
      }, 4500);
    }
  }, 50);
}

  // Gestion de la vitesse temporaire li√©e aux cases oranges
  function applySpeedModifier(modifier) {
    speedModifier = modifier;
    if(speedEffectTimeout) clearTimeout(speedEffectTimeout);
    speedEffectTimeout = setTimeout(() => {
      speedModifier = 0;
    }, 2000);
  }

  // G√©n√©rer un nouveau b√©tail jaune
  function generateBetail() {
    betail = randomFreePosition();
  }

  // G√©rer clavier
  window.addEventListener("keydown", e => {
    switch(e.key) {
      case "ArrowUp":
        if(direction.y !== 1) nextDirection = { x: 0, y: -1 };
        break;
      case "ArrowDown":
        if(direction.y !== -1) nextDirection = { x: 0, y: 1 };
        break;
      case "ArrowLeft":
        if(direction.x !== 1) nextDirection = { x: -1, y: 0 };
        break;
      case "ArrowRight":
        if(direction.x !== -1) nextDirection = { x: 1, y: 0 };
        break;
    }
  });

  function update() {
    if (gameStopped) return;
    direction = nextDirection;

    // nouvelle t√™te
    let newHead = { x: train[0].x + direction.x, y: train[0].y + direction.y };

    // Effet wrap autour des bords
    if (newHead.x < 0) newHead.x = cols - 1;
    if (newHead.x >= cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = rows - 1;
    if (newHead.y >= rows) newHead.y = 0;

    // Collision train avec lui-m√™me ?
    if (isOnTrain(newHead)) {
      showGameOver("Collision avec soi-m√™me !");
      return;
    }

    // Collision avec vaches = game over imm√©diat
    if (isOnVache(newHead)) {
      showGameOver("Le train a percut√© des vaches !");
      return;
    }

    train.unshift(newHead);

    // Collision avec b√©tail : grandit
    if (betail && newHead.x === betail.x && newHead.y === betail.y) {
      score++;
      scoreEl.textContent = score;
      generateBetail();
    } else {
      train.pop();
    }

    // Collision avec suppression (case rouge)
    if (isOnSuppression(newHead)) {
      handleSuppression();
      return;
    }

    // Collision avec case orange : acc√©l√®re ou ralentit
    if (isOnOrange(newHead)) {
      // 50% chance acc√©l√©rer ou ralentir
      if (Math.random() < 0.5) {
        applySpeedModifier(-150); // acc√©l√®re (diminue d√©lai)
      } else {
        applySpeedModifier(150); // ralentit (augmente d√©lai)
      }
    }

    // D√©placer vaches si actives
    if(vachesActive) {
      moveVaches();
    }
  }

  function gameLoop() {
    update();
    draw();
    // Calculer d√©lai avec vitesse modifi√©e
    const delay = Math.max(50, baseSpeed + speedModifier);
    setTimeout(gameLoop, delay);
  }

function showGameOver(message) {
  if (gameStopped) return; // emp√™che les appels multiples
  gameStopped = true;

  const div = document.getElementById("gameOverMessage");
  div.textContent = message + "\nScore final: " + score;
  div.style.display = "block";

  div.style.opacity = 0;
  let opacity = 0;
  const fadeIn = setInterval(() => {
    opacity += 0.05;
    div.style.opacity = opacity;
    if (opacity >= 1) {
      clearInterval(fadeIn);
    }
  }, 50);
}
  
  // D√©marrage

  placePerturbations();
  generateBetail();

  // D√©marre la boucle principale
  gameLoop();

  // D√©marre la fr√©quence des vaches √† partir de 60 secondes
  setTimeout(() => {
    vachesActive = true;
    scheduleNextVaches();
    increaseVacheFrequency();
  }, 60000);

})();
</script>

</body>
</html>
