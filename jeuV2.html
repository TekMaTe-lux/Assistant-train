<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Train Bétail V5</title>
  <style>
    body {
      background: black;
      color: #0ff;
      font-family: 'Orbitron', monospace;
      text-align: center;
    }
    canvas {
      border: 3px solid #0ff;
      margin-top: 20px;
    }
    #info {
      margin-top: 15px;
      font-size: 18px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    #gameOverMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0ff;
      font-family: 'Orbitron', monospace;
      font-size: 48px;
      text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
      background: rgba(0,0,0,0.8);
      padding: 20px 40px;
      border: 3px solid #0ff;
      border-radius: 10px;
      display: none;
      z-index: 1000;
    }
    #restartBtn {
      margin-top: 20px;
      font-size: 20px;
      padding: 10px 30px;
      border-radius: 10px;
      border: 2px solid #0ff;
      background: black;
      color: #0ff;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>

<h1>Train Bétail - Évite les suppressions !</h1>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="info">
  Utilise les <b>flèches</b> pour tourner.<br>
  Prends le <span style="color: yellow;">bétail jaune</span> pour grandir.<br>
  Évite les <span style="color: red;">suppressions</span>.<br>
  Les <span style="color: orange;">oranges</span> accélèrent ou ralentissent.<br>
  Attention aux <span style="color: white;">bandes de vaches</span> !<br>
  Score : <span id="score">0</span> | Record : <span id="highscore">0</span>
</div>

<div id="gameOverMessage"></div>
<button id="restartBtn">Rejouer</button>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const gridSize = 20, cols = canvas.width / gridSize, rows = canvas.height / gridSize;

  let train, direction, nextDirection, score, highscore = 0;
  let baseSpeed = 200, speedModifier = 0, betail, suppressions, oranges, vaches, vacheFrequency, gameStopped;

  const messagesSuppression = [
    "Supprimé : conducteur perdu !",
    "Supprimé : grève surprise.",
    "Supprimé : hérissons envahissants.",
    "Supprimé : panne de réveil.",
    "Supprimé : surcharge de blagues.",
    "Supprimé : café épuisé.",
    "Supprimé : panne de signalisation lunaire.",
    "Supprimé : alignement cosmique défavorable."
  ];

  function initGame() {
    train = [{x: 10, y: 10}];
    direction = {x: 1, y: 0};
    nextDirection = direction;
    score = 0;
    document.getElementById("score").textContent = score;
    suppressions = []; oranges = []; vaches = [];
    vacheFrequency = 15000;
    gameStopped = false;
    speedModifier = 0;
    placePerturbations();
    generateBetail();
    gameLoop();
    setTimeout(() => { scheduleVaches(); increaseVacheFrequency(); }, 60000);
  }

  function placePerturbations() {
    for (let i = 0; i < 10; i++) suppressions.push(randomFreePosition());
    for (let i = 0; i < 5; i++) oranges.push(randomFreePosition());
  }

  function randomFreePosition() {
    let pos;
    do {
      pos = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
    } while (isOccupied(pos));
    return pos;
  }

  function isOccupied(pos) {
    return train.some(p => p.x === pos.x && p.y === pos.y)
      || suppressions.some(p => p.x === pos.x && p.y === pos.y)
      || oranges.some(p => p.x === pos.x && p.y === pos.y)
      || (betail && betail.x === pos.x && betail.y === pos.y);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    suppressions.forEach(p => { ctx.fillStyle = "red"; ctx.fillRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4); });
    oranges.forEach(p => { ctx.fillStyle = "orange"; ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8); });
    if (betail) {
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(betail.x * gridSize + gridSize/2, betail.y * gridSize + gridSize/2, gridSize/3, 0, 2*Math.PI);
      ctx.fill();
    }
    vaches.forEach(band => {
      band.forEach(p => {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(p.x * gridSize + gridSize/2, p.y * gridSize + gridSize/2, gridSize/3, 0, 2*Math.PI);
        ctx.fill();
      });
    });
    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? "#0ff" : "#088";
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  function update() {
    if (gameStopped) return;
    direction = nextDirection;
    let newHead = { x: train[0].x + direction.x, y: train[0].y + direction.y };
    if (newHead.x < 0) newHead.x = cols - 1;
    if (newHead.x >= cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = rows - 1;
    if (newHead.y >= rows) newHead.y = 0;

    if (train.some(p => p.x === newHead.x && p.y === newHead.y)) return gameOver("Collision avec soi-même !");
    if (vaches.some(band => band.some(p => p.x === newHead.x && p.y === newHead.y))) return gameOver("Percuté des vaches !");
    if (suppressions.some(p => p.x === newHead.x && p.y === newHead.y)) {
      const msg = messagesSuppression[Math.floor(Math.random() * messagesSuppression.length)];
      return gameOver(msg, true);
    }

    train.unshift(newHead);

    if (betail && newHead.x === betail.x && newHead.y === betail.y) {
      score++;
      document.getElementById("score").textContent = score;
      if (score > highscore) {
        highscore = score;
        document.getElementById("highscore").textContent = highscore;
        localStorage.setItem("highscore", highscore);
      }
      generateBetail();
    } else {
      train.pop();
    }

    if (oranges.some(p => p.x === newHead.x && p.y === newHead.y)) {
      speedModifier = (Math.random() < 0.5) ? -150 : 150;
      setTimeout(() => { speedModifier = 0; }, 2000);
    }

    moveVaches();
  }

  function moveVaches() {
    vaches.forEach(band => band.forEach(v => v.x--));
    vaches = vaches.filter(band => band.some(v => v.x >= 0));
  }

  function scheduleVaches() {
    if (gameStopped) return;
    const size = Math.floor(Math.random()*4)+1;
    const yStart = Math.floor(Math.random() * (rows - size));
    const band = Array.from({length: size}, (_, i) => ({x: cols-1, y: yStart+i}));
    vaches.push(band);
    setTimeout(scheduleVaches, vacheFrequency);
  }

  function increaseVacheFrequency() {
    if (vacheFrequency > 3000) vacheFrequency -= 1000;
    setTimeout(increaseVacheFrequency, 60000);
  }

  function gameOver(message, secousse=false) {
    gameStopped = true;
    document.getElementById("gameOverMessage").textContent = message + "\nScore: " + score;
    document.getElementById("gameOverMessage").style.display = "block";
    document.getElementById("restartBtn").style.display = "inline-block";
    if (secousse) shake();
  }

  function shake() {
    let intensity = 10, count = 0;
    const shakeInterval = setInterval(() => {
      count++;
      canvas.style.transform = `translate(${(Math.random()-0.5)*intensity}px, ${(Math.random()-0.5)*intensity}px)`;
      if (count > 10) {
        clearInterval(shakeInterval);
        canvas.style.transform = "";
      }
    }, 50);
  }

  function gameLoop() {
    update();
    draw();
    if (!gameStopped) setTimeout(gameLoop, Math.max(50, baseSpeed + speedModifier));
  }

  function generateBetail() {
    betail = randomFreePosition();
  }

  window.addEventListener("keydown", e => {
    switch(e.key) {
      case "ArrowUp": if(direction.y !== 1) nextDirection = {x: 0, y: -1}; break;
      case "ArrowDown": if(direction.y !== -1) nextDirection = {x: 0, y: 1}; break;
      case "ArrowLeft": if(direction.x !== 1) nextDirection = {x: -1, y: 0}; break;
      case "ArrowRight": if(direction.x !== -1) nextDirection = {x: 1, y: 0}; break;
    }
  });

  document.getElementById("restartBtn").addEventListener("click", () => {
    document.getElementById("gameOverMessage").style.display = "none";
    document.getElementById("restartBtn").style.display = "none";
    initGame();
  });

  // Charger le record localStorage
  if (localStorage.getItem("highscore")) {
    highscore = parseInt(localStorage.getItem("highscore"));
    document.getElementById("highscore").textContent = highscore;
  }

  initGame();
})();
</script>

</body>
</html>
