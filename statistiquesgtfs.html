<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stats GTFS-RT ‚Äì Local (gtfsrt_history.jsonl.gz)</title>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; line-height: 1.35; }
    .box { border: 1px dashed #aaa; padding: 18px; border-radius: 12px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin-top: 12px; }
    input[type="date"], input[type="text"] { padding: 8px 10px; border-radius: 10px; border: 1px solid #ccc; }
    button { padding: 10px 14px; border: 1px solid #ccc; border-radius: 12px; background: #fff; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .kpi { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-top: 16px; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 14px; }
    .label { font-size: 13px; opacity: .75; }
    .value { font-size: 28px; font-weight: 700; margin-top: 6px; }

    .log { white-space: pre-wrap; background: #f7f7f7; border: 1px solid #eee; border-radius: 12px; padding: 12px; margin-top: 16px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }

    .hint { opacity:.86; font-size: 13px; margin-top: 8px; }
    .muted { opacity:.7; }

    .details { margin-top: 18px; }
    .details h2 { margin: 8px 0 10px; }
    .details-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    .dcard { border: 1px solid #ddd; border-radius: 14px; padding: 14px; }
    .dhead { display:flex; align-items: baseline; justify-content: space-between; gap: 10px; }
    .dtitle { font-weight: 700; }
    .dcount { opacity: .75; font-size: 13px; }

    .trainlist {
      margin-top: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      background: #fafafa;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 10px;
      max-height: 180px;
      overflow:auto;
    }

    .chips { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .chip {
      border:1px solid #ddd; border-radius:999px; padding:6px 10px;
      font-size:12px; background:#fff; cursor:pointer;
      display:inline-flex; gap:8px; align-items:center;
    }
    .chip:hover { border-color:#999; }
    .chip b { font-weight: 700; }
    .chip .x { opacity:.6; }
    .chip:hover .x { opacity:1; }

    table { width:100%; border-collapse: collapse; }
    th { text-align:left; padding:8px; border-bottom:1px solid #eee; font-size: 12px; opacity:.85; }
    td { padding:8px; border-bottom:1px solid #f2f2f2; font-size: 12px; }
    td.num, th.num { text-align:right; }

    canvas { width: 100% !important; max-width: 100%; }
    .sep { opacity:.5; margin: 0 6px; }
  </style>

  <!-- D√©compression .gz -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <!-- Graphiques -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>

<body>
  <h1>Stats GTFS-RT (local) ‚Äì recherche par date</h1>
  <p>
    Charge une fois le fichier <b>gtfsrt_history.jsonl.gz</b> (ou .jsonl/.json),
    puis s√©lectionne une date (et/ou une plage) disponible.
  </p>

  <div id="drop" class="box">
    <b>D√©pose ton fichier ici</b> ou s√©lectionne-le :
    <div class="row">
      <input id="file" type="file" accept=".gz,.jsonl,.json" />

      <label>
        Jour :
        <input id="date" type="date" />
      </label>
      <button id="run" disabled>Calculer (jour)</button>

      <span class="muted">|</span>

      <label>
        D√©but :
        <input id="start" type="date" />
      </label>
      <label>
        Fin :
        <input id="end" type="date" />
      </label>
      <button id="runRange" disabled>Calculer (plage)</button>
      <button id="last7" disabled>7 derniers jours</button>
    </div>

    <div class="hint">
      <div>R√®gles (format GTFSRT ‚Äúhistory‚Äù) :</div>
      <ul>
        <li><b>Supprim√©</b> = <code>status === "CANCELED"</code></li>
        <li><b>Partiel</b> = <code>status === "PARTIAL_CANCELLATION"</code></li>
        <li><b>Retard√©</b> = <code>max(stops) &gt; 0</code> ou <code>status === "DELAYED"</code></li>
        <li><b>Pas √† l‚Äôheure</b> = union (retard√© ‚à™ partiel ‚à™ supprim√©) sans double-compte</li>
      </ul>
      <div class="muted">
        Les buckets retards (5‚Äì9 / 10‚Äì19 / 20‚Äì39 / ‚â•40) sont bas√©s sur <code>max(stops)</code> (retard max du train sur ses arr√™ts).
      </div>

      <div id="availableWrap" style="margin-top:10px; display:none;">
        <div class="muted">Derni√®res dates trouv√©es :</div>
        <div class="chips" id="available"></div>
      </div>
    </div>
  </div>

  <div class="kpi" id="kpis" style="display:none;">
    <div class="card"><div class="label">Date</div><div class="value" id="k_date">‚Äî</div></div>
    <div class="card"><div class="label">Total trains</div><div class="value" id="total">‚Äî</div></div>
    <div class="card"><div class="label">Retard√©s</div><div class="value" id="delayed">‚Äî</div></div>
    <div class="card"><div class="label">Supprim√©s</div><div class="value" id="cancelled">‚Äî</div></div>
    <div class="card"><div class="label">Partiellement supprim√©s</div><div class="value" id="partial">‚Äî</div></div>
    <div class="card"><div class="label">Pas √† l‚Äôheure</div><div class="value" id="notOnTime">‚Äî</div></div>
    <div class="card"><div class="label">% pas √† l‚Äôheure</div><div class="value" id="pct">‚Äî</div></div>
  </div>

  <!-- Graphiques "global" -->
  <div class="details" id="charts" style="display:none;">
    <h2>Graphiques</h2>
    <div class="details-grid">
      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">% Pas √† l‚Äôheure (par jour)</div>
          <div class="dcount muted" id="chart_note">‚Äî</div>
        </div>
        <canvas id="chart_pct" height="140"></canvas>
      </div>

      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">Volumes (par jour)</div>
          <div class="dcount muted">Retard√©s / Partiels / Supprim√©s</div>
        </div>
        <canvas id="chart_stack" height="140"></canvas>
      </div>

      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">R√©partition (jour s√©lectionn√©)</div>
          <div class="dcount muted" id="chart_day">‚Äî</div>
        </div>
        <canvas id="chart_donut" height="140"></canvas>
      </div>

      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">Histogramme des retards (jour)</div>
          <div class="dcount muted">5‚Äì9 / 10‚Äì19 / 20‚Äì39 / ‚â•40</div>
        </div>
        <canvas id="chart_buckets" height="140"></canvas>
      </div>
    </div>
  </div>

  <!-- D√©tails par cat√©gories (jour s√©lectionn√© uniquement) -->
  <div class="details" id="details" style="display:none;">
    <h2>D√©tails du jour s√©lectionn√©</h2>
    <div class="details-grid">
      <div class="dcard">
        <div class="dhead"><div class="dtitle">Retards (5 √† 9 min)</div><div class="dcount" id="c_5_9">0</div></div>
        <div class="trainlist" id="l_5_9">‚Äî</div>
      </div>

      <div class="dcard">
        <div class="dhead"><div class="dtitle">Retards (10 √† 19 min)</div><div class="dcount" id="c_10_19">0</div></div>
        <div class="trainlist" id="l_10_19">‚Äî</div>
      </div>

      <div class="dcard">
        <div class="dhead"><div class="dtitle">Retards (20 √† 39 min)</div><div class="dcount" id="c_20_39">0</div></div>
        <div class="trainlist" id="l_20_39">‚Äî</div>
      </div>

      <div class="dcard">
        <div class="dhead"><div class="dtitle">Retards (‚â• 40 min)</div><div class="dcount" id="c_40p">0</div></div>
        <div class="trainlist" id="l_40p">‚Äî</div>
      </div>

      <div class="dcard">
        <div class="dhead"><div class="dtitle">Suppressions</div><div class="dcount" id="c_cancel">0</div></div>
        <div class="trainlist" id="l_cancel">‚Äî</div>
      </div>

      <div class="dcard">
        <div class="dhead"><div class="dtitle">Suppressions partielles</div><div class="dcount" id="c_partial">0</div></div>
        <div class="trainlist" id="l_partial">‚Äî</div>
      </div>
    </div>
  </div>

  <!-- Stats par arr√™t (jour s√©lectionn√©) -->
  <div class="details" id="stopsPanel" style="display:none;">
    <h2>Stats par arr√™t (jour s√©lectionn√©)</h2>
    <div class="dcard">
      <div class="row" style="margin-top:0;">
        <label class="muted">Filtre gare :
          <input id="stopFilter" type="text" placeholder="ex: Metz, Thionville..." />
        </label>
        <span class="muted" id="stopsMeta">‚Äî</span>
      </div>

      <div class="trainlist" style="max-height:320px;">
        <table id="stopsTable">
          <thead>
            <tr>
              <th>Arr√™t</th>
              <th class="num">Trains</th>
              <th class="num">En retard</th>
              <th class="num">% retard</th>
              <th class="num">Moy (min)*</th>
              <th class="num">Max (min)</th>
              <th class="num">Trains annul√©s</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="muted" style="margin-top:8px;font-size:12px;">
        * Moyenne calcul√©e uniquement sur les trains r√©ellement en retard (&gt;0) √† cet arr√™t.
      </div>
    </div>
  </div>

  <!-- Comparateur trains / arr√™ts -->
  <div class="details" id="comparePanel" style="display:none;">
    <h2>Comparateur (trains & arr√™ts) ‚Äì belles courbes</h2>

    <div class="details-grid">
      <!-- Comparer trains (sur une gare) dans le temps -->
      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">Courbe : retard d‚Äôun / plusieurs trains (par jour)</div>
          <div class="dcount muted">sur un arr√™t (optionnel)</div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label class="muted">Train :
            <input id="trainPick" list="trainList" type="text" placeholder="ex: 88573" />
            <datalist id="trainList"></datalist>
          </label>
          <button id="trainAdd">Ajouter</button>

          <span class="sep">|</span>

          <label class="muted">Arr√™t (optionnel) :
            <input id="trainStopPick" list="stopList" type="text" placeholder="ex: Metz" />
          </label>
        </div>

        <div class="chips" id="trainSel"></div>
        <div class="muted" style="margin-top:8px;font-size:12px;">
          Si tu choisis un arr√™t : on trace le retard de chaque train √† cet arr√™t. Sinon : on trace le <b>retard max</b> (max(stops)) du train.
        </div>

        <canvas id="chart_train_over_days" height="150" style="margin-top:10px;"></canvas>
      </div>

      <!-- Comparer arr√™ts (moyenne retard) dans le temps -->
      <div class="dcard">
        <div class="dhead">
          <div class="dtitle">Courbe : retards par arr√™t (par jour)</div>
          <div class="dcount muted">moyenne & / ou max</div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label class="muted">Arr√™t :
            <input id="stopPick" list="stopList" type="text" placeholder="ex: Thionville" />
          </label>
          <button id="stopAdd">Ajouter</button>
          <span class="sep">|</span>
          <label class="muted">
            <input id="stopUseMax" type="checkbox" />
            utiliser le MAX (sinon moyenne)
          </label>
        </div>

        <div class="chips" id="stopSel"></div>

        <canvas id="chart_stop_over_days" height="150" style="margin-top:10px;"></canvas>
      </div>

      <!-- Profil d‚Äôun train sur ses arr√™ts (jour s√©lectionn√©) -->
      <div class="dcard" style="grid-column: 1 / -1;">
        <div class="dhead">
          <div class="dtitle">Profil d‚Äôun train (jour s√©lectionn√©) : retard par arr√™t</div>
          <div class="dcount muted">ordre = ordre ‚Äústops‚Äù du JSON</div>
        </div>

        <div class="row" style="margin-top:10px;">
          <label class="muted">Train (jour) :
            <input id="profileTrainPick" list="trainList" type="text" placeholder="ex: 88773" />
          </label>
          <button id="profileRun">Afficher</button>
          <span class="muted" id="profileMeta">‚Äî</span>
        </div>

        <canvas id="chart_train_profile" height="130" style="margin-top:10px;"></canvas>
        <div class="muted" style="margin-top:8px;font-size:12px;">
          ‚ö†Ô∏è GTFSRT ‚Äúhistory‚Äù ne fournit pas toujours un ordre officiel des arr√™ts : on suit l‚Äôordre tel qu‚Äôil appara√Æt dans l‚Äôobjet <code>stops</code>.
        </div>
      </div>
    </div>
  </div>

  <div class="log" id="log">Log‚Ä¶</div>

  <script>
    // ===== Helpers / DOM =====
    const $ = (id) => document.getElementById(id);
    const drop = $("drop");
    const fileInput = $("file");
    const runBtn = $("run");
    const runRangeBtn = $("runRange");
    const last7Btn = $("last7");
    const logEl = $("log");
    const kpis = $("kpis");
    const details = $("details");

    const dateEl = $("date");
    const startEl = $("start");
    const endEl = $("end");

    const availableWrap = $("availableWrap");
    const availableEl = $("available");

    // Compare UI
    const trainPick = $("trainPick");
    const trainAdd = $("trainAdd");
    const trainStopPick = $("trainStopPick");
    const trainSel = $("trainSel");

    const stopPick = $("stopPick");
    const stopAdd = $("stopAdd");
    const stopUseMax = $("stopUseMax");
    const stopSel = $("stopSel");

    const profileTrainPick = $("profileTrainPick");
    const profileRun = $("profileRun");
    const profileMeta = $("profileMeta");

    // ===== State =====
    let currentFile = null;
    let cachedObjectsByDate = null;  // Map(date -> obj)
    let parsingInProgress = false;
    let availableDates = [];         // sorted YYYY-MM-DD
    let computedByDate = new Map();  // date -> { total, delayed, cancelled, partial, notOnTime, pct, buckets }

    // For datalists
    let allTrainIds = new Set();
    let allStopNames = new Set();

    // Selections
    let selectedTrainIds = []; // array
    let selectedStopNames = []; // array

    // ===== Charts (global) =====
    let chartPct = null;
    let chartStack = null;
    let chartDonut = null;
    let chartBuckets = null;

    // ===== Charts (compare) =====
    let chartTrainOverDays = null;
    let chartStopOverDays = null;
    let chartTrainProfile = null;

    function log(msg) { logEl.textContent = msg; }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // ===== KPI rendering =====
    function setKPIs({date, total, delayed, cancelled, partial, notOnTime, pct}) {
      $("k_date").textContent = date || "‚Äî";
      $("total").textContent = total ?? "‚Äî";
      $("delayed").textContent = delayed ?? "‚Äî";
      $("cancelled").textContent = cancelled ?? "‚Äî";
      $("partial").textContent = partial ?? "‚Äî";
      $("notOnTime").textContent = notOnTime ?? "‚Äî";
      $("pct").textContent = (isFinite(pct) ? pct.toFixed(2) : "0.00") + " %";
      kpis.style.display = "";
    }

    function fmtList(arr) {
      if (!arr || arr.length === 0) return "‚Äî";
      const sorted = [...arr].sort((a,b) => {
        const na = Number(a), nb = Number(b);
        if (Number.isFinite(na) && Number.isFinite(nb)) return na - nb;
        return String(a).localeCompare(String(b));
      });
      return sorted.join(", ");
    }

    function setDetailsBuckets(b) {
      const map = [
        ["c_5_9", "l_5_9", b.r5_9],
        ["c_10_19", "l_10_19", b.r10_19],
        ["c_20_39", "l_20_39", b.r20_39],
        ["c_40p", "l_40p", b.r40p],
        ["c_cancel", "l_cancel", b.cancels],
        ["c_partial", "l_partial", b.partials],
      ];
      for (const [cid, lid, arr] of map) {
        $(cid).textContent = (arr?.length ?? 0) + " train(s)";
        $(lid).textContent = fmtList(arr);
      }
      details.style.display = "";
    }

    // ===== File parsing =====
    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error);
        r.readAsArrayBuffer(file);
      });
    }

    function decodeUTF8(uint8) {
      return new TextDecoder("utf-8").decode(uint8);
    }

    function splitJsonl(text) {
      return text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    }

    function dateRangeISO(startISO, endISO) {
      const out = [];
      const start = new Date(startISO + "T00:00:00");
      const end = new Date(endISO + "T00:00:00");
      for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
        out.push(d.toISOString().slice(0,10));
      }
      return out;
    }

    function clampToAvailable(iso) {
      if (!availableDates.length) return iso;
      if (availableDates.includes(iso)) return iso;
      const idx = availableDates.findIndex(d => d > iso);
      if (idx === -1) return availableDates[availableDates.length - 1];
      if (idx === 0) return availableDates[0];
      return availableDates[idx - 1];
    }

    function renderAvailableDatesChips() {
      availableEl.innerHTML = "";
      if (!availableDates.length) { availableWrap.style.display = "none"; return; }
      const show = availableDates.slice(-20);
      for (const d of show) {
        const chip = document.createElement("button");
        chip.className = "chip";
        chip.textContent = d;
        chip.title = "Cliquer pour s√©lectionner ce jour";
        chip.addEventListener("click", () => { dateEl.value = d; runOne(); });
        availableEl.appendChild(chip);
      }
      availableWrap.style.display = "";
    }

    function syncDateInputsMinMax() {
      if (!availableDates.length) return;
      const min = availableDates[0];
      const max = availableDates[availableDates.length - 1];
      for (const el of [dateEl, startEl, endEl]) { el.min = min; el.max = max; }
      if (!dateEl.value) dateEl.value = max;
      if (!startEl.value) startEl.value = min;
      if (!endEl.value) endEl.value = max;
    }

    function rebuildDatalists() {
      const trainList = $("trainList");
      const stopList = $("stopList");
      trainList.innerHTML = "";
      stopList.innerHTML = "";

      [...allTrainIds].sort((a,b)=>Number(a)-Number(b)).slice(0, 5000).forEach(t => {
        const opt = document.createElement("option");
        opt.value = String(t);
        trainList.appendChild(opt);
      });

      [...allStopNames].sort((a,b)=>a.localeCompare(b)).slice(0, 5000).forEach(s => {
        const opt = document.createElement("option");
        opt.value = s;
        stopList.appendChild(opt);
      });
    }

    function extractUniverse() {
      allTrainIds = new Set();
      allStopNames = new Set();

      for (const [d, obj] of cachedObjectsByDate.entries()) {
        const trains = obj?.trains || {};
        for (const [tid, t] of Object.entries(trains)) {
          allTrainIds.add(tid);
          const stops = t?.stops || {};
          if (stops && typeof stops === "object") {
            for (const s of Object.keys(stops)) allStopNames.add(s);
          }
        }
      }
      rebuildDatalists();
      $("comparePanel").style.display = ""; // on active le comparateur d√®s qu'on a un fichier
    }

    async function parseFileOnce(file) {
      if (cachedObjectsByDate || parsingInProgress) return;
      parsingInProgress = true;

      log("Lecture du fichier‚Ä¶");
      const buf = await readFileAsArrayBuffer(file);

      let text = "";
      if (file.name.endsWith(".gz")) {
        log("D√©compression .gz‚Ä¶");
        const uint8 = new Uint8Array(buf);
        const inflated = window.pako.inflate(uint8);
        text = decodeUTF8(inflated);
      } else {
        text = decodeUTF8(new Uint8Array(buf));
      }

      const map = new Map();
      const lines = splitJsonl(text);

      if (lines.length > 1) {
        log(`Parsing JSONL‚Ä¶ (${lines.length} lignes)`);
        let ok = 0, bad = 0;
        for (const line of lines) {
          try {
            const obj = JSON.parse(line);
            if (obj && obj.date) map.set(obj.date, obj);
            ok++;
          } catch (e) { bad++; }
        }
        cachedObjectsByDate = map;
        availableDates = [...map.keys()].sort();
        log(`‚úÖ Fichier pars√©. Lignes OK=${ok}, ignor√©es=${bad}. Jours: ${availableDates.join(", ") || "aucun"}`);
      } else {
        log("Pas vraiment JSONL ‚Üí tentative JSON complet‚Ä¶");
        const obj = JSON.parse(text);
        if (obj?.date) map.set(obj.date, obj);
        cachedObjectsByDate = map;
        availableDates = [...map.keys()].sort();
        log(`‚úÖ JSON charg√©. Jours: ${availableDates.join(", ") || "aucun"}`);
      }

      syncDateInputsMinMax();
      renderAvailableDatesChips();
      extractUniverse();

      parsingInProgress = false;
    }

    // ===== Core logic GTFSRT history =====
    function maxStopDelayMinutes(stopsObj) {
      if (!stopsObj || typeof stopsObj !== "object") return 0;
      let m = 0;
      for (const v of Object.values(stopsObj)) {
        const n = Number(v);
        if (Number.isFinite(n) && n > m) m = n;
      }
      return m;
    }

    function computeForDay(dayObj) {
      const trains = dayObj?.trains || {};
      const ids = Object.keys(trains);
      const total = Number(dayObj?.count ?? ids.length);

      let delayed = 0, cancelled = 0, partial = 0;
      const notOnTimeSet = new Set();

      const buckets = { r5_9: [], r10_19: [], r20_39: [], r40p: [], cancels: [], partials: [] };

      for (const tid of ids) {
        const t = trains[tid] || {};
        const status = String(t.status || "").toUpperCase();
        const d = maxStopDelayMinutes(t.stops);

        const isCancelled = (status === "CANCELED" || status === "CANCELLED");
        const isPartial = (status === "PARTIAL_CANCELLATION" || status === "PARTIALLY_CANCELED");
        const isDelayed = (!isCancelled && !isPartial) && (status === "DELAYED" || d > 0);

        if (isDelayed) delayed++;
        if (isPartial) partial++;
        if (isCancelled) cancelled++;

        if (isDelayed || isPartial || isCancelled) notOnTimeSet.add(tid);

        if (isDelayed && d > 0) {
          if (d >= 5 && d <= 9) buckets.r5_9.push(tid);
          else if (d >= 10 && d <= 19) buckets.r10_19.push(tid);
          else if (d >= 20 && d <= 39) buckets.r20_39.push(tid);
          else if (d >= 40) buckets.r40p.push(tid);
        }

        if (isCancelled) buckets.cancels.push(tid);
        if (isPartial) buckets.partials.push(tid);
      }

      const notOnTime = notOnTimeSet.size;
      const pct = total ? (notOnTime / total) * 100 : 0;
      return { total, delayed, cancelled, partial, notOnTime, pct, buckets };
    }

    // ===== Charts: global =====
    function onTimeCount(res) {
      return Math.max(0, (res.total || 0) - (res.notOnTime || 0));
    }

    function ensureChartsVisible() { $("charts").style.display = ""; }

    function computeSeriesForRange(startISO, endISO) {
      const daysAll = dateRangeISO(startISO, endISO);
      const days = daysAll.filter(d => cachedObjectsByDate.has(d));

      const labels = [];
      const pct = [], delayed = [], partial = [], cancelled = [];

      for (const d of days) {
        const obj = cachedObjectsByDate.get(d);
        const res = computeForDay(obj);
        computedByDate.set(d, res);

        labels.push(d);
        pct.push(Number(res.pct || 0));
        delayed.push(Number(res.delayed || 0));
        partial.push(Number(res.partial || 0));
        cancelled.push(Number(res.cancelled || 0));
      }

      return { labels, pct, delayed, partial, cancelled, daysPresent: days.length, daysTotal: daysAll.length };
    }

    function renderCharts(rangeStart, rangeEnd, selectedDate) {
      ensureChartsVisible();

      const series = computeSeriesForRange(rangeStart, rangeEnd);
      $("chart_note").textContent = `${rangeStart} ‚Üí ${rangeEnd} (jours pr√©sents: ${series.daysPresent}/${series.daysTotal})`;
      $("chart_day").textContent = selectedDate || "‚Äî";

      const ctxPct = $("chart_pct").getContext("2d");
      if (chartPct) chartPct.destroy();
      chartPct = new Chart(ctxPct, {
        type: "line",
        data: { labels: series.labels, datasets: [{ label: "% pas √† l‚Äôheure", data: series.pct, tension: 0.25, pointRadius: 3 }] },
        options: { responsive: true, plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true, ticks: { callback: (v) => v + "%" } } } }
      });

      const ctxStack = $("chart_stack").getContext("2d");
      if (chartStack) chartStack.destroy();
      chartStack = new Chart(ctxStack, {
        type: "bar",
        data: {
          labels: series.labels,
          datasets: [
            { label: "Retard√©s", data: series.delayed, stack: "s" },
            { label: "Partiels", data: series.partial, stack: "s" },
            { label: "Supprim√©s", data: series.cancelled, stack: "s" },
          ]
        },
        options: { responsive: true, plugins: { legend: { display: true } }, scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } } }
      });

      const dayObj = cachedObjectsByDate.get(selectedDate);
      if (!dayObj) return;

      const dayRes = computedByDate.get(selectedDate) || computeForDay(dayObj);
      computedByDate.set(selectedDate, dayRes);

      const ctxDonut = $("chart_donut").getContext("2d");
      if (chartDonut) chartDonut.destroy();
      chartDonut = new Chart(ctxDonut, {
        type: "doughnut",
        data: {
          labels: ["√Ä l‚Äôheure", "Retard√©s", "Partiels", "Supprim√©s"],
          datasets: [{ data: [onTimeCount(dayRes), dayRes.delayed, dayRes.partial, dayRes.cancelled] }]
        },
        options: { responsive: true, plugins: { legend: { display: true } } }
      });

      const ctxBuckets = $("chart_buckets").getContext("2d");
      if (chartBuckets) chartBuckets.destroy();
      const b = dayRes.buckets || { r5_9:[], r10_19:[], r20_39:[], r40p:[] };
      chartBuckets = new Chart(ctxBuckets, {
        type: "bar",
        data: {
          labels: ["5‚Äì9", "10‚Äì19", "20‚Äì39", "‚â•40"],
          datasets: [{ label: "Nombre de trains", data: [b.r5_9.length, b.r10_19.length, b.r20_39.length, b.r40p.length] }]
        },
        options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } }
      });
    }

    // ===== Stats par arr√™t (jour) =====
    function computeStopStatsForDay(dayObj) {
      const trains = dayObj?.trains || {};
      const ids = Object.keys(trains);

      const map = new Map(); // stop -> stats

      function getStop(s) {
        if (!map.has(s)) {
          map.set(s, { stop: s, trains: 0, delayed: 0, sumDelay: 0, maxDelay: 0, cancelledTrains: 0 });
        }
        return map.get(s);
      }

      for (const tid of ids) {
        const t = trains[tid] || {};
        const status = String(t.status || "").toUpperCase();
        const isCancelled = (status === "CANCELED" || status === "CANCELLED");

        const stops = t.stops || {};
        if (!stops || typeof stops !== "object") continue;

        for (const [stopName, val] of Object.entries(stops)) {
          const delay = Number(val);
          if (!Number.isFinite(delay)) continue;

          const s = getStop(stopName);
          s.trains++;

          if (delay > 0) {
            s.delayed++;
            s.sumDelay += delay;
            if (delay > s.maxDelay) s.maxDelay = delay;
          }

          if (isCancelled) s.cancelledTrains++;
        }
      }

      const arr = [...map.values()].map(s => ({
        ...s,
        pctDelayed: s.trains ? (s.delayed / s.trains) * 100 : 0,
        avgDelay: s.delayed ? (s.sumDelay / s.delayed) : 0,
      }));

      arr.sort((a,b) => (b.pctDelayed - a.pctDelayed) || (b.maxDelay - a.maxDelay) || a.stop.localeCompare(b.stop));
      return arr;
    }

    function renderStopStatsTable(rows, filterText="") {
      const panel = $("stopsPanel");
      const tbody = $("stopsTable").querySelector("tbody");
      const meta = $("stopsMeta");

      const f = (filterText || "").trim().toLowerCase();
      const filtered = f ? rows.filter(r => r.stop.toLowerCase().includes(f)) : rows;

      tbody.innerHTML = "";
      for (const r of filtered) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${escapeHtml(r.stop)}</td>
          <td class="num">${r.trains}</td>
          <td class="num">${r.delayed}</td>
          <td class="num">${r.pctDelayed.toFixed(1)}%</td>
          <td class="num">${r.avgDelay.toFixed(1)}</td>
          <td class="num">${r.maxDelay}</td>
          <td class="num">${r.cancelledTrains}</td>
        `;
        tbody.appendChild(tr);
      }

      meta.textContent = `${filtered.length} arr√™t(s) affich√©(s) / ${rows.length} total`;
      panel.style.display = "";
    }

    // ===== Comparateur: UI chips =====
    function renderChips(container, items, onRemove) {
      container.innerHTML = "";
      for (const it of items) {
        const chip = document.createElement("button");
        chip.className = "chip";
        chip.innerHTML = `<b>${escapeHtml(it)}</b> <span class="x">‚úï</span>`;
        chip.title = "Retirer";
        chip.addEventListener("click", () => onRemove(it));
        container.appendChild(chip);
      }
    }

    function addUnique(arr, v, limit=6) {
      v = String(v || "").trim();
      if (!v) return arr;
      if (arr.includes(v)) return arr;
      if (arr.length >= limit) arr.shift(); // on garde les plus r√©cents
      return [...arr, v];
    }

    function removeItem(arr, v) { return arr.filter(x => x !== v); }

    // ===== Comparateur: donn√©es =====
    function getDayObj(dateISO) { return cachedObjectsByDate?.get(dateISO); }

    function getTrainDelayValue(t, stopNameOrNull) {
      if (!t) return null;
      const status = String(t.status || "").toUpperCase();
      if (status === "CANCELED" || status === "CANCELLED") return null; // on n'interpr√®te pas un "retard" pour un train annul√©
      if (stopNameOrNull) {
        const v = t.stops?.[stopNameOrNull];
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      }
      // sinon: max(stops)
      const d = maxStopDelayMinutes(t.stops);
      return Number.isFinite(d) ? d : 0;
    }

    function getStopMetricForDay(dayObj, stopName, useMax) {
      // retourne moyenne ou max pour cet arr√™t
      const trains = dayObj?.trains || {};
      let count = 0, sum = 0, max = 0;

      for (const t of Object.values(trains)) {
        const status = String(t?.status || "").toUpperCase();
        if (status === "CANCELED" || status === "CANCELLED") continue;

        const v = t?.stops?.[stopName];
        const n = Number(v);
        if (!Number.isFinite(n)) continue;

        count++;
        sum += n;
        if (n > max) max = n;
      }

      if (!count) return null;
      return useMax ? max : (sum / count);
    }

    // ===== Comparateur: charts =====
    function renderTrainOverDays() {
      const s = clampToAvailable(startEl.value || dateEl.value);
      const e = clampToAvailable(endEl.value || dateEl.value);
      const days = dateRangeISO(s, e).filter(d => cachedObjectsByDate.has(d));
      const stopName = String(trainStopPick.value || "").trim() || null;

      const datasets = selectedTrainIds.map(tid => {
        const data = days.map(d => {
          const obj = getDayObj(d);
          const t = obj?.trains?.[tid];
          const val = getTrainDelayValue(t, stopName);
          return (val === null ? null : val);
        });
        return { label: stopName ? `${tid} @ ${stopName}` : `${tid} (max)`, data, tension: 0.25, spanGaps: true, pointRadius: 2 };
      });

      const ctx = $("chart_train_over_days").getContext("2d");
      if (chartTrainOverDays) chartTrainOverDays.destroy();

      chartTrainOverDays = new Chart(ctx, {
        type: "line",
        data: { labels: days, datasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: { y: { beginAtZero: true, title: { display: true, text: "minutes" } } }
        }
      });
    }

    function renderStopOverDays() {
      const s = clampToAvailable(startEl.value || dateEl.value);
      const e = clampToAvailable(endEl.value || dateEl.value);
      const days = dateRangeISO(s, e).filter(d => cachedObjectsByDate.has(d));
      const useMax = !!stopUseMax.checked;

      const datasets = selectedStopNames.map(stopName => {
        const data = days.map(d => {
          const obj = getDayObj(d);
          return getStopMetricForDay(obj, stopName, useMax);
        });
        return { label: useMax ? `${stopName} (max)` : `${stopName} (moy)`, data, tension: 0.25, spanGaps: true, pointRadius: 2 };
      });

      const ctx = $("chart_stop_over_days").getContext("2d");
      if (chartStopOverDays) chartStopOverDays.destroy();

      chartStopOverDays = new Chart(ctx, {
        type: "line",
        data: { labels: days, datasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: { y: { beginAtZero: true, title: { display: true, text: "minutes" } } }
        }
      });
    }

    function renderTrainProfileForSelectedDay(tid) {
      const d = clampToAvailable(dateEl.value);
      const dayObj = getDayObj(d);
      const t = dayObj?.trains?.[tid];

      if (!t) {
        profileMeta.textContent = `Train ${tid} introuvable le ${d}`;
        // clear chart
        const ctx = $("chart_train_profile").getContext("2d");
        if (chartTrainProfile) chartTrainProfile.destroy();
        chartTrainProfile = new Chart(ctx, { type:"line", data:{labels:[],datasets:[]}, options:{responsive:true}});
        return;
      }

      const status = String(t.status || "").toUpperCase();
      if (status === "CANCELED" || status === "CANCELLED") {
        profileMeta.textContent = `Train ${tid} : CANCELED (profil indisponible) ‚Äì ${d}`;
      } else {
        profileMeta.textContent = `Train ${tid} ‚Äì ${d} (status=${status})`;
      }

      const stopsEntries = Object.entries(t.stops || {});
      const labels = stopsEntries.map(([name]) => name);
      const values = stopsEntries.map(([,v]) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : 0;
      });

      const ctx = $("chart_train_profile").getContext("2d");
      if (chartTrainProfile) chartTrainProfile.destroy();

      chartTrainProfile = new Chart(ctx, {
        type: "line",
        data: {
          labels,
          datasets: [{ label: `Retard par arr√™t (min)`, data: values, tension: 0.25, pointRadius: 2 }]
        },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: "minutes" } },
            x: { ticks: { maxRotation: 60, minRotation: 0 } }
          }
        }
      });
    }

    function refreshCompareChartsIfPossible() {
      if (!cachedObjectsByDate) return;
      if (selectedTrainIds.length) renderTrainOverDays();
      if (selectedStopNames.length) renderStopOverDays();
    }

    // ===== Buttons enable =====
    function enableButtons() {
      const ready = !!currentFile;
      runBtn.disabled = !ready;
      runRangeBtn.disabled = !ready;
      last7Btn.disabled = !ready;
    }

    // ===== Main actions =====
    async function runOne() {
      if (!currentFile) return;

      runBtn.disabled = true; runRangeBtn.disabled = true; last7Btn.disabled = true;

      try {
        await parseFileOnce(currentFile);

        const targetDate = clampToAvailable(dateEl.value);
        dateEl.value = targetDate;

        const dayObj = cachedObjectsByDate.get(targetDate);
        if (!dayObj) {
          log(`‚ùå Aucun objet trouv√© pour ${targetDate}. (Le fichier contient: ${availableDates.join(", ") || "rien"})`);
          setKPIs({date: targetDate, total:0, delayed:0, cancelled:0, partial:0, notOnTime:0, pct:0});
          details.style.display = "none";
          $("charts").style.display = "none";
          $("stopsPanel").style.display = "none";
          return;
        }

        const res = computeForDay(dayObj);
        computedByDate.set(targetDate, res);

        setKPIs({date: targetDate, ...res});
        setDetailsBuckets(res.buckets);

        // Stop stats
        const stopRows = computeStopStatsForDay(dayObj);
        renderStopStatsTable(stopRows, $("stopFilter")?.value || "");

        // charts: default range = inputs
        const rs = clampToAvailable(startEl.value || targetDate);
        const re = clampToAvailable(endEl.value || targetDate);
        startEl.value = rs; endEl.value = re;

        renderCharts(rs, re, targetDate);

        // comparateur
        refreshCompareChartsIfPossible();

        log(
          `‚úÖ ${targetDate} (generated_at=${dayObj.generated_at || "?"})\n` +
          `Total=${res.total} | Retard√©s=${res.delayed} | Supprim√©s=${res.cancelled} | Partiels=${res.partial}\n` +
          `Pas √† l'heure=${res.notOnTime} (${res.pct.toFixed(2)}%)\n\n` +
          `Graphiques + stats par arr√™t + comparateur pr√™ts.`
        );
      } catch (e) {
        console.error(e);
        log("‚ùå Erreur: " + (e?.message || String(e)));
      } finally {
        enableButtons();
      }
    }

    async function runRange(startISO, endISO) {
      if (!currentFile) return;

      runBtn.disabled = true; runRangeBtn.disabled = true; last7Btn.disabled = true;

      try {
        await parseFileOnce(currentFile);

        let s = clampToAvailable(startISO);
        let e = clampToAvailable(endISO);
        if (s > e) { const tmp = s; s = e; e = tmp; }
        startEl.value = s; endEl.value = e;

        const daysAll = dateRangeISO(s, e);
        const days = daysAll.filter(d => cachedObjectsByDate.has(d));

        let out = `üìÖ R√©sum√© ${s} ‚Üí ${e}\n`;
        out += `(jours pr√©sents: ${days.length}/${daysAll.length})\n\n`;

        if (!days.length) {
          out += "‚ùå Aucun jour de cette plage n'est pr√©sent.\n";
          log(out);
          $("charts").style.display = "none";
          return;
        }

        for (const d of days) {
          const obj = cachedObjectsByDate.get(d);
          const res = computeForDay(obj);
          computedByDate.set(d, res);
          out += `${d} : Total=${res.total}, Retard√©s=${res.delayed}, Supprim√©s=${res.cancelled}, Partiels=${res.partial}, Pas √† l'heure=${res.notOnTime} (${res.pct.toFixed(2)}%)\n`;
        }

        // pick selected day for donut/details
        let selected = clampToAvailable(dateEl.value || days[days.length - 1]);
        if (!cachedObjectsByDate.has(selected) || selected < s || selected > e) selected = days[days.length - 1];
        dateEl.value = selected;

        const selObj = cachedObjectsByDate.get(selected);
        const selRes = computedByDate.get(selected) || computeForDay(selObj);
        computedByDate.set(selected, selRes);
        setKPIs({date: selected, ...selRes});
        setDetailsBuckets(selRes.buckets);

        // Stop stats for selected day (not range)
        const stopRows = computeStopStatsForDay(selObj);
        renderStopStatsTable(stopRows, $("stopFilter")?.value || "");

        // global charts for range
        renderCharts(s, e, selected);

        // compare charts depend on range too
        refreshCompareChartsIfPossible();

        out += `\n(D√©tails + arr√™t : jour s√©lectionn√© = ${selected})\n`;
        log(out);
      } catch (e) {
        console.error(e);
        log("‚ùå Erreur: " + (e?.message || String(e)));
      } finally {
        enableButtons();
      }
    }

    async function runLast7() {
      if (!currentFile) return;
      await parseFileOnce(currentFile);
      if (!availableDates.length) return;

      const max = availableDates[availableDates.length - 1];
      const idxStart = Math.max(0, availableDates.length - 7);
      const min7 = availableDates[idxStart];

      startEl.value = min7;
      endEl.value = max;
      await runRange(min7, max);
    }

    // ===== UI events: file load =====
    drop.addEventListener("dragover", (e) => { e.preventDefault(); drop.style.borderColor = "#333"; });
    drop.addEventListener("dragleave", () => { drop.style.borderColor = "#aaa"; });
    drop.addEventListener("drop", async (e) => {
      e.preventDefault();
      drop.style.borderColor = "#aaa";
      const f = e.dataTransfer.files?.[0];
      if (f) {
        currentFile = f;
        cachedObjectsByDate = null;
        availableDates = [];
        computedByDate = new Map();
        allTrainIds = new Set();
        allStopNames = new Set();
        selectedTrainIds = [];
        selectedStopNames = [];

        details.style.display = "none";
        kpis.style.display = "none";
        $("charts").style.display = "none";
        $("stopsPanel").style.display = "none";
        $("comparePanel").style.display = "none";
        availableWrap.style.display = "none";
        trainSel.innerHTML = "";
        stopSel.innerHTML = "";

        log(`Fichier s√©lectionn√©: ${f.name} (${Math.round(f.size/1024)} Ko)\n‚û°Ô∏è Clique ‚ÄúCalculer (jour)‚Äù ou ‚ÄúCalculer (plage)‚Äù.`);
        enableButtons();
      }
    });

    fileInput.addEventListener("change", () => {
      const f = fileInput.files?.[0];
      if (f) {
        currentFile = f;
        cachedObjectsByDate = null;
        availableDates = [];
        computedByDate = new Map();
        allTrainIds = new Set();
        allStopNames = new Set();
        selectedTrainIds = [];
        selectedStopNames = [];

        details.style.display = "none";
        kpis.style.display = "none";
        $("charts").style.display = "none";
        $("stopsPanel").style.display = "none";
        $("comparePanel").style.display = "none";
        availableWrap.style.display = "none";
        trainSel.innerHTML = "";
        stopSel.innerHTML = "";

        log(`Fichier s√©lectionn√©: ${f.name} (${Math.round(f.size/1024)} Ko)\n‚û°Ô∏è Clique ‚ÄúCalculer (jour)‚Äù ou ‚ÄúCalculer (plage)‚Äù.`);
        enableButtons();
      }
    });

    // ===== UI events: main =====
    runBtn.addEventListener("click", runOne);
    runRangeBtn.addEventListener("click", () => runRange(startEl.value, endEl.value));
    last7Btn.addEventListener("click", runLast7);

    $("stopFilter")?.addEventListener("input", () => {
      const d = clampToAvailable(dateEl.value);
      const obj = cachedObjectsByDate?.get(d);
      if (!obj) return;
      const rows = computeStopStatsForDay(obj);
      renderStopStatsTable(rows, $("stopFilter").value);
    });

    // ===== UI events: compare =====
    trainAdd.addEventListener("click", () => {
      const v = String(trainPick.value || "").trim();
      if (!v) return;
      if (!allTrainIds.has(v)) {
        log(`‚ö†Ô∏è Train "${v}" inconnu dans le fichier (v√©rifie l‚ÄôID).`);
        return;
      }
      selectedTrainIds = addUnique(selectedTrainIds, v, 6);
      renderChips(trainSel, selectedTrainIds, (x) => {
        selectedTrainIds = removeItem(selectedTrainIds, x);
        renderChips(trainSel, selectedTrainIds, arguments.callee);
        refreshCompareChartsIfPossible();
      });
      trainPick.value = "";
      refreshCompareChartsIfPossible();
    });

    stopAdd.addEventListener("click", () => {
      const v = String(stopPick.value || "").trim();
      if (!v) return;
      if (!allStopNames.has(v)) {
        log(`‚ö†Ô∏è Arr√™t "${v}" inconnu dans le fichier (orthographe ? accents ?).`);
        return;
      }
      selectedStopNames = addUnique(selectedStopNames, v, 6);
      renderChips(stopSel, selectedStopNames, (x) => {
        selectedStopNames = removeItem(selectedStopNames, x);
        renderChips(stopSel, selectedStopNames, arguments.callee);
        refreshCompareChartsIfPossible();
      });
      stopPick.value = "";
      refreshCompareChartsIfPossible();
    });

    trainStopPick.addEventListener("change", () => refreshCompareChartsIfPossible());
    stopUseMax.addEventListener("change", () => refreshCompareChartsIfPossible());
    startEl.addEventListener("change", () => refreshCompareChartsIfPossible());
    endEl.addEventListener("change", () => refreshCompareChartsIfPossible());
    dateEl.addEventListener("change", () => {
      // met √† jour profil si un train est d√©j√† renseign√©
      if (String(profileTrainPick.value || "").trim()) renderTrainProfileForSelectedDay(String(profileTrainPick.value).trim());
    });

    profileRun.addEventListener("click", () => {
      const tid = String(profileTrainPick.value || "").trim();
      if (!tid) return;
      renderTrainProfileForSelectedDay(tid);
    });

    // ===== Init =====
    enableButtons();
    log("Pr√™t. Charge gtfsrt_history.jsonl.gz pour commencer.");
  </script>
</body>
</html>
