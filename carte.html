<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <title>Carte Nancy ‚Üî Luxembourg ‚Äî R√©seaux + Gares + Trains (GTFS sans shapes)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root{ color-scheme: dark;
      --marker-font:clamp(14px, 1.8vw, 18px);
      --marker-gap:clamp(4px, 1vw, 8px);
      --marker-num-font:clamp(11px, 1.4vw, 13px);
      --marker-num-pad:2px 6px;
      --marker-delay-font:clamp(10px, 1.25vw, 12px);
      --station-font:clamp(14px, 1.6vw, 16px);
      --station-pad:2px 4px;
    }
      body{ margin:0; background:#050b15; color:#e6f1ff; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; min-height:100vh; overflow:hidden; background-image:radial-gradient(1400px 900px at 12% 20%, rgba(0,240,255,0.08), transparent),radial-gradient(1200px 800px at 88% 12%, rgba(160,255,0,0.08), transparent),linear-gradient(135deg, rgba(0,240,255,0.06), rgba(10,16,28,0.85) 38%, rgba(0,255,170,0.04)); background-attachment:fixed; }
      header{ position:fixed; top:0; left:0; right:0; z-index:1200; padding:12px 16px; background:linear-gradient(135deg, #0b1423 0%, #09101d 40%, #0a1a2f 100%); border-bottom:1px solid #1c2a3f; box-shadow:0 10px 28px rgba(0,0,0,0.38), 0 0 24px rgba(0,240,255,0.12); backdrop-filter:blur(10px); }
      .header-inner{ display:grid; grid-template-columns:auto 1fr; align-items:center; gap:12px; width:100%; }
      .brand-link{ display:inline-flex; align-items:center; justify-content:center; border-radius:14px; padding:8px; background:linear-gradient(145deg, rgba(12,18,30,0.9), rgba(14,28,46,0.9)); border:1px solid #1f324b; box-shadow:0 8px 18px rgba(0,0,0,0.35), 0 0 18px rgba(0,240,255,0.25); transition:transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
    .brand-link:hover{ border-color:#5bd6ff; transform:translateY(-1px); }
      .brand-logo{ height:46px; width:auto; display:block; filter:drop-shadow(0 0 12px rgba(0,240,255,0.35)); }
      .header-texts{ display:flex; flex-direction:column; gap:3px; min-width:0; }
      .header-title{ font-weight:750; font-size:17px; color:#e8f5ff; letter-spacing:0.02em; text-shadow:0 2px 10px rgba(0,0,0,0.35); white-space:normal; overflow:visible; line-height:1.25; }
    #map{ height:100vh; }
      .panel{ position:fixed; left:50%; transform:translateX(-50%); top:76px; width:min(1100px, calc(100% - 24px)); display:flex; gap:12px; align-items:center; padding:12px 14px; background:linear-gradient(145deg, rgba(10,16,28,0.92), rgba(8,14,24,0.9)); border:1px solid #1f324b; border-radius:16px; box-shadow:0 12px 26px rgba(0,0,0,0.35), 0 0 18px rgba(0,240,255,0.14); flex-wrap:wrap; z-index:1180; backdrop-filter:blur(10px); transition:transform 0.25s ease, opacity 0.25s ease; }
    body:not(.controls-open) .panel{ transform:translate(-50%, -10px) scale(0.98); opacity:0; pointer-events:none; }
      .badge{ padding:3px 8px; border:1px solid #2a3b55; border-radius:6px; font-size:12px; background:rgba(12,18,30,0.78); box-shadow:0 0 12px rgba(0,240,255,0.1); letter-spacing:0.02em; }
      .muted{ opacity:.85; font-size:12px; color:#9ab1d6; }
    .ctrl{ display:flex; align-items:center; gap:8px; }
    .ctrl input[type="range"]{ width:160px; }
    .legend-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
    .dot-rfn{ background:#00f0ff; }
    .dot-cfl{ background:#ff00e0; }
    .err{ color:#ffb4b4 }
    .cow-marker{ display:flex; align-items:center; gap:var(--marker-gap); font-size:var(--marker-font); text-shadow:0 0 4px rgba(0,0,0,0.6); border:none; background:transparent; color:inherit; padding:0; margin:0; line-height:1; }
    .cow-marker:focus-visible{ outline:2px solid #a0ff00; outline-offset:2px; }
    .cow-glyph{ position:relative; display:inline-flex; align-items:center; justify-content:center; }
    .cow-glyph--cancelled::after{ content:'‚úñ'; position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:0.72em; color:#ff4d6d; text-shadow:0 0 6px rgba(0,0,0,0.55); transform:translate(0.1em,-0.25em) scale(1.1); }
    .cow-marker .train-num{ font-size:var(--marker-num-font); font-weight:600; padding:var(--marker-num-pad); border-radius:6px; border:1px solid #2a3b55; background:rgba(14,23,38,0.9); color:#e0f0ff; white-space:nowrap; }
    .cow-marker.train-sncf .train-num{ border-color:#1b3b73; background:rgba(18,38,73,0.92); color:#9fc3ff; box-shadow:0 0 10px rgba(27,59,115,0.45); }
    .cow-marker.train-cfl .train-num{ border-color:#ff5869; background:rgba(96,16,32,0.92); color:#ffd6d9; box-shadow:0 0 10px rgba(255,88,105,0.45); }
    .cow-marker.train-tgv-roi .train-num{ border-color:#f5d97b; background:rgba(70,52,12,0.94); color:#fff0c2; box-shadow:0 0 12px rgba(245,217,123,0.55); }
    .cow-marker .train-delay-badge{ display:inline-flex; align-items:center; justify-content:center; font-size:var(--marker-delay-font); font-weight:700; padding:2px 7px; border-radius:999px; margin-left:6px; border:1px solid rgba(255,196,128,0.7); background:rgba(120,72,16,0.85); color:#0b0f1a; white-space:nowrap; box-shadow:0 0 6px rgba(0,0,0,0.35); text-transform:none; letter-spacing:.01em; }
    .cow-marker .train-delay-badge--moderate{ background:rgba(255,189,92,0.92); border-color:rgba(255,210,150,0.95); color:#101b2b; }
    .cow-marker .train-delay-badge--major{ background:rgba(255,145,86,0.92); border-color:rgba(255,185,140,0.95); color:#0f1828; }
    .cow-marker .train-delay-badge--severe{ background:rgba(255,86,86,0.94); border-color:rgba(255,160,160,0.96); color:#fff; }
    .cow-marker .train-delay-badge--cancelled{ background:rgba(128,32,52,0.92); border-color:rgba(255,150,190,0.95); color:#ffe4ef; text-transform:uppercase; letter-spacing:.05em; }
    .cow-marker.train-cancelled .train-num{ border-color:#ff7a7a; background:rgba(70,16,28,0.92); color:#ffd7d7; box-shadow:0 0 12px rgba(255,64,96,0.45); }
    .station-marker{ display:inline-flex; align-items:center; justify-content:center; min-width:24px; min-height:24px; border-radius:6px; border:1px solid transparent; background:transparent; color:#d9f27f; font-size:var(--station-font); text-shadow:none; box-shadow:none; cursor:pointer; padding:var(--station-pad); margin:0; line-height:1; }
    .station-marker.station-major{ color:#ffe28a; border-color:#ffc85740; background:rgba(255,200,87,0.08); }
    .station-marker.station-regular{ color:#c5f36f; border-color:#6cad3a33; background:rgba(111,173,58,0.07); }
    .station-marker:focus-visible{ outline:2px solid #a0ff00; outline-offset:2px; }
    .trip-panel{ position:fixed; top:96px; right:18px; width:320px; max-height:calc(100vh - 140px); background:rgba(11,15,26,0.95); border:1px solid #20324b; border-radius:14px; box-shadow:0 18px 36px rgba(0,0,0,0.35); padding:16px; display:flex; flex-direction:column; gap:12px; backdrop-filter:blur(6px); overflow:hidden; z-index:3000; transition:transform 0.26s ease, opacity 0.22s ease; }
    .trip-panel.hidden{ display:none; }
    .trip-panel-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .trip-panel-body{ display:flex; flex-direction:column; gap:12px; overflow:auto; padding-right:2px; }
    .trip-panel-title{ display:flex; align-items:center; gap:8px; font-weight:700; font-size:16px; }
    .trip-panel-icon{ font-size:20px; filter: drop-shadow(0 0 4px rgba(0,0,0,0.6)); }
    .trip-panel-close{ border:none; background:rgba(32,50,75,0.6); color:#e0f0ff; font-size:18px; width:28px; height:28px; border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    .trip-panel-close:hover{ background:rgba(160,255,0,0.25); color:#0b0f1a; }
    .trip-panel-summary{ font-size:13px; line-height:1.4; color:#aabbd1; }
    .trip-progress{ display:flex; flex-direction:column; gap:6px; }
    .trip-progress-bar{ position:relative; height:6px; width:100%; background:#162233; border-radius:999px; overflow:hidden; }
    .trip-progress-bar-fill{ position:absolute; top:0; left:0; height:100%; background:linear-gradient(90deg,#00f0ff,#a0ff00); width:0%; transition:width 0.4s ease; }
    .trip-progress-text{ font-size:12px; color:#94a7c4; }
    .trip-stops{ flex:1; overflow:auto; padding-right:4px; display:flex; flex-direction:column; gap:10px; }
    .trip-stops.station-mode{ gap:8px; }
    .trip-stops-title{ font-size:12px; color:#8093b5; text-transform:uppercase; letter-spacing:.08em; }
    .trip-stop{ position:relative; display:flex; gap:12px; align-items:flex-start; padding-left:12px; --connector-progress:0; }
    .trip-stop::before{ content:''; position:absolute; left:0; top:6px; width:10px; height:10px; border-radius:50%; background:#2a3b55; box-shadow:0 0 6px rgba(0,240,255,0.3); transition:transform 0.3s ease, box-shadow 0.3s ease; }
    .trip-stop.passed::before{ background:#2c8bff; opacity:0.6; box-shadow:none; }
    .trip-stop.current::before{ background:#00f0ff; box-shadow:0 0 10px rgba(0,240,255,0.8); }
    .trip-stop.enroute::before{ transform:scale(1.05); box-shadow:0 0 14px rgba(0,240,255,0.85); }
    .trip-stop.upcoming::before{ background:#243249; }
    .trip-stop.approaching::before{ background:#1e3049; box-shadow:0 0 8px rgba(0,240,255,0.45); }
    .trip-stop.passed{ --connector-progress:1; }
    .trip-stop:not(:last-child)::after{ content:''; position:absolute; left:4px; top:16px; bottom:-10px; width:2px; background:linear-gradient(180deg, rgba(0,240,255,0.55) 0%, rgba(0,240,255,0.55) calc(var(--connector-progress, 0) * 100%), rgba(36,50,73,0.6) calc(var(--connector-progress, 0) * 100%), rgba(36,50,73,0.6) 100%); transition:background 0.3s ease; }
    .trip-stop:last-child::after{ display:none; }
    .stop-time{ display:flex; flex-direction:column; gap:2px; align-items:flex-end; font-size:12px; color:#90a1b8; min-width:86px; font-variant-numeric:tabular-nums; }
    .stop-time .time-entry{ line-height:1.1; padding:0; margin:0; }
    .stop-time .time-arr{ color:#8fa1be; }
    .stop-time .time-dep{ color:#d6e6ff; font-weight:600; }
   .stop-time .time-neutral{ color:#90a1b8; }
    .stop-time .time-entry-plan{ display:block; }
    .stop-time .time-entry-rt{ display:block; font-size:11px; opacity:0.85; }
    .stop-time .time-entry-rt--delay{ color:#ffc48a; }
    .stop-time .time-entry-rt--advance{ color:#9eff9e; }
    .stop-time .time-entry-rt--ontime{ color:#a0ff00; opacity:0.75; }
    .trip-stop.cancelled .stop-name{ color:#ffb4b4; text-decoration:line-through; }
    .trip-stop.cancelled .time-entry-plan,
    .trip-stop.cancelled .time-entry-rt{ color:#ff8989; text-decoration:line-through; }
    .trip-stop.cancelled .time-entry-rt{ opacity:1; }
    .time-entry.cancelled{ color:#ff8989; }
    .time-entry.cancelled .time-entry-plan,
    .time-entry.cancelled .time-entry-rt{ color:inherit; text-decoration:line-through; }
    .trip-panel.cancelled .trip-panel-summary{ color:#ffb4b4; }
    .trip-panel.cancelled .trip-panel-realtime strong{ color:#ffb4b4; }
    .trip-panel.cancelled .trip-panel-realtime-diff{ color:#ff8989; }
    .stop-main{ display:flex; flex-direction:column; gap:3px; }
    .stop-name{ font-weight:600; font-size:14px; color:#e0f0ff; }
    .stop-note{ font-size:11px; color:#7f92b1; text-transform:uppercase; letter-spacing:.04em; }
    .stop-note strong{ color:#a0ff00; font-weight:600; }
    .trip-panel-delay{ display:inline-flex; flex-direction:column; gap:2px; margin-top:8px; padding:6px 10px; border-radius:10px; border:1px solid rgba(255,200,120,0.55); background:rgba(46,32,12,0.55); color:#ffd8a0; font-size:12px; box-shadow:0 0 8px rgba(0,0,0,0.2); }
    .trip-panel-delay.delay-moderate{ border-color:rgba(255,210,150,0.65); background:rgba(128,76,12,0.55); color:#ffddb0; }
    .trip-panel-delay.delay-major{ border-color:rgba(255,170,120,0.7); background:rgba(128,52,12,0.55); color:#ffc7aa; }
    .trip-panel-delay.delay-severe{ border-color:rgba(255,150,150,0.75); background:rgba(128,24,24,0.6); color:#ffb6b6; }
    .trip-panel-delay.delay-cancelled{ border-color:rgba(255,150,190,0.75); background:rgba(120,24,52,0.58); color:#ffdce9; text-transform:uppercase; letter-spacing:.05em; }
    .trip-panel-delay .trip-panel-delay-context{ font-size:11px; color:#c8d9f0; opacity:0.9; }
    .trip-panel-disruption{ margin-top:8px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,176,96,0.7); background:rgba(110,56,10,0.55); color:#ffd3a0; font-size:12px; box-shadow:0 0 10px rgba(0,0,0,0.2); }
    .trip-panel-disruption strong{ color:#ffe0b8; }
    .trip-panel-disruption.is-cancelled{ border-color:rgba(255,120,140,0.75); background:rgba(100,22,32,0.6); color:#ffc4ce; box-shadow:0 0 10px rgba(0,0,0,0.28); }
    .trip-panel-disruption.is-cancelled strong{ color:#ffd3da; }
    .trip-panel-realtime{ font-size:12px; color:#ffc48a; margin-top:6px; display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
    .trip-panel-realtime strong{ color:#ffd8a0; }
    .trip-panel-realtime-diff{ font-size:11px; color:#ffb066; font-weight:600; }
    .hidden{ display:none !important; }
    .fab-button{ border:1px solid #2a3b55; background:linear-gradient(135deg, rgba(11,15,26,0.9), rgba(10,24,38,0.9)); color:#e6f1ff; border-radius:12px; padding:10px 14px; font-size:13px; display:inline-flex; align-items:center; gap:8px; box-shadow:0 10px 22px rgba(0,0,0,0.35), 0 0 14px rgba(0,240,255,0.12); cursor:pointer; backdrop-filter:blur(8px); transition:border-color 0.2s ease, color 0.2s ease, background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease; }
    .fab-button:hover{ border-color:#5bd6ff; color:#a0ff00; transform:translateY(-1px); box-shadow:0 12px 24px rgba(0,0,0,0.45), 0 0 18px rgba(0,240,255,0.18); }
    .fab-button:focus-visible{ outline:2px solid #a0ff00; outline-offset:3px; }
    .fab-button .accent{ font-weight:700; color:#a0ff00; }
    .info-fab{ position:fixed; left:14px; bottom:14px; z-index:1250; display:inline-flex; gap:6px; align-items:center; }
    .info-panel{ position:fixed; bottom:92px; left:18px; right:18px; max-width:420px; margin:0 auto; background:rgba(8,12,20,0.95); border:1px solid #20324b; border-radius:14px; padding:14px 16px; color:#d2e2ff; box-shadow:0 16px 32px rgba(0,0,0,0.35); z-index:3200; backdrop-filter:blur(8px); }
    .info-panel.hidden{ display:none; }
    .info-panel h3{ margin:0 0 8px; font-size:14px; color:#a0ff00; }
    .info-panel ul{ margin:0; padding-left:16px; display:flex; flex-direction:column; gap:4px; font-size:12px; }
    .leaflet-marker-icon { pointer-events: auto !important; }
    .cow-marker, .cow-marker * { pointer-events: auto; cursor: pointer; }
    .station-event{ display:flex; gap:12px; align-items:flex-start; padding:10px 12px; border-radius:12px; border:1px solid #20324b; background:rgba(9,15,24,0.65); box-shadow:0 6px 18px rgba(0,0,0,0.22); }
    .station-event-main{ flex:1; display:flex; flex-direction:column; gap:4px; }
    .station-event-title{ font-weight:600; color:#e0f0ff; font-size:14px; }
    .station-event-note{ font-size:12px; color:#8fa1be; }
    .station-event-times{ display:flex; flex-direction:column; gap:2px; font-size:12px; color:#d6e6ff; }
    .station-event-status{ font-size:11px; color:#a0ff00; text-transform:uppercase; letter-spacing:.05em; }
    .station-event.empty{ justify-content:center; color:#8fa1be; font-size:13px; padding:16px; text-align:center; }
    .station-train-link{ display:inline-flex; align-items:center; gap:6px; border:1px solid #2a3b55; border-radius:8px; padding:6px 10px; background:rgba(11,15,26,0.8); color:#e0f0ff; font-size:12px; cursor:pointer; text-shadow:0 0 4px #000; }
    .station-train-link:hover{ border-color:#5bd6ff; color:#a0ff00; }
    .station-train-link:focus-visible{ outline:2px solid #a0ff00; outline-offset:2px; }
    .station-time-plan{ font-weight:600; color:#d6e6ff; }
    .station-time-rt{ display:inline-block; margin-left:4px; font-size:11px; }
    .station-time-rt--delay{ color:#ffc48a; }
    .station-time-rt--advance{ color:#9eff9e; }
    .station-time-rt--ontime{ color:#a0ff00; opacity:0.75; }
    .controls-toggle{ position:fixed; right:14px; bottom:14px; z-index:1250; }
    @media (max-width: 900px){
      header{ padding:10px 12px; font-size:14px; text-align:center; }
      header{ padding:12px 12px; font-size:14px; text-align:center; }
      .header-inner{ grid-template-columns:1fr; justify-items:center; row-gap:10px; }
      .brand-link{ padding:7px 9px; }
      .brand-logo{ height:42px; }
      .header-texts{ align-items:center; text-align:center; }
      .header-title{ font-size:16px; }
      .panel{ top:auto; bottom:78px; width:min(720px, calc(100% - 20px)); flex-direction:column; align-items:stretch; gap:10px; padding:12px; }
      .panel .ctrl{ flex-wrap:wrap; gap:6px 12px; }
      .panel .badge{ font-size:11px; }
      .panel label{ font-size:12px; }
      .ctrl input[type="range"]{ width:140px; }
      .trip-panel{ position:fixed; top:auto; bottom:12px; left:50%; right:auto; width:calc(100% - 24px); max-height:50vh; min-height:36vh; transform:translate(-50%, 110%); border-radius:18px 18px 14px 14px; }
      body.trip-panel-open .trip-panel{ transform:translate(-50%, 0); }
      .trip-panel-header{ position:sticky; top:0; padding:4px 0 8px; margin:0 -2px; background:linear-gradient(180deg, rgba(11,15,26,0.98) 0%, rgba(11,15,26,0.94) 70%, rgba(11,15,26,0.88) 100%); z-index:1; }
      .trip-panel-body{ max-height:calc(50vh - 64px); padding-right:6px; }
      .trip-panel-header{ flex-wrap:wrap; }
      .trip-panel-title{ font-size:15px; }
      .trip-panel-summary{ font-size:12px; }
      .trip-stops{ max-height:40vh; }
      :root{
        --marker-font:clamp(14px, 3vw, 17px);
        --marker-gap:clamp(4px, 1.4vw, 7px);
        --marker-num-font:clamp(11px, 2.4vw, 12px);
        --marker-num-pad:2px 5px;
        --marker-delay-font:clamp(10px, 2.2vw, 11px);
        --station-font:clamp(13px, 2.5vw, 15px);
        --station-pad:2px 3px;
      }
      .controls-toggle{ display:inline-flex; }
    }

    @media (max-width: 520px){
      header{ text-align:center; padding:12px 10px; }
      .brand-logo{ height:38px; }
      .header-title{ font-size:15px; }
      .panel{ gap:8px; padding:12px; border-radius:14px; }
      .trip-panel{ bottom:10px; width:calc(100% - 16px); padding:14px; }
      .trip-panel-body{ max-height:calc(50vh - 56px); }
      .trip-panel-title{ justify-content:center; width:100%; }
      .trip-panel-close{ width:26px; height:26px; font-size:16px; }
      .trip-panel-summary{ text-align:left; }
      .trip-stops-title{ font-size:11px; }
      .stop-name{ font-size:13px; }
      .stop-time{ font-size:11px; min-width:72px; }
      .stop-time .time-entry-rt{ font-size:10px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner">
      <a class="brand-link" href="https://x.com/BERNancyMetzLux" target="_blank" rel="noopener">
        <img class="brand-logo" src="logobetaillere.png" alt="Logo La B√©taill√®re">
      </a>
      <div class="header-texts">
        <div class="header-title">La map des b√©taill√®res sur Nancy-Metz-Lux</div>
        <div class="muted">B√©taill√©res plac√©es par interpolation entre gares √† partir des donn√©es opendata </div>
      </div>
    </div>
  </header>

  <div id="map"></div>

  <div id="controls-panel" class="panel" tabindex="-1">
    <span class="badge"><span class="legend-dot dot-rfn"></span>SNCF</span>
    <span class="badge"><span class="legend-dot dot-cfl"></span>CFL</span>
    <div class="ctrl">
      <label class="muted">Rafra√Æchissement: <span id="hz">10</span>s</label>
      <input id="period" type="range" min="1" max="30" step="1" value="10">
      <label class="muted"><input id="smooth" type="checkbox" checked> animation fluide</label>
    </div>
    <div class="ctrl">
      <span class="muted">Ic√¥nes :</span>
      <label class="muted"><input id="toggle-major" type="checkbox" checked> gares prioritaires</label>
      <label class="muted"><input id="toggle-regular" type="checkbox" checked> gares secondaires</label>
      <label class="muted"><input id="toggle-trains" type="checkbox" checked> b√©taill√®res</label>
    </div>
    <div class="ctrl">
      <span class="muted">Trains :</span>
      <label class="muted"><input id="toggle-ter" type="checkbox" checked> TER</label>
      <label class="muted"><input id="toggle-tgv" type="checkbox" checked> TGV</label>
      <label class="muted"><input id="toggle-cfl" type="checkbox" checked> CFL (RE/IC/RB)</label>
      <label class="muted"><input id="toggle-delays" type="checkbox" checked> afficher retards</label>
    </div>
    <span id="clock" class="muted">‚Äî</span>
    <span id="counts" class="muted">‚Äî</span>
    <span id="status" class="muted"></span>
  </div>

  <button id="controls-toggle" class="fab-button controls-toggle" type="button" aria-expanded="false" aria-controls="controls-panel">‚öôÔ∏è <span class="accent">Filtres</span></button>

  <button id="info-button" class="fab-button info-fab" type="button" aria-expanded="false" aria-controls="info-panel">‚ÑπÔ∏è <span class="accent">Infos</span></button>

  <div id="info-panel" class="info-panel hidden" role="dialog" aria-modal="true" aria-label="Sources et explications">
    <h3>Sources de donn√©es</h3>
    <ul>
      <li>Trac√©s et fonds de carte : OpenStreetMap.</li>
      <li>Donn√©es statiques : jeux GTFS publi√©s par le Minist√®re de l'Am√©nagement du territoire (FR) et par l'administration des transports publics (LU) </li>
      <li>Temps r√©el SNCF : API SNCF et flux GTFS-RT consolid√©s.</li>
      <li>Temps r√©el CFL : API HAFAS pour les lignes RE, IC et RB.</li>
    </ul>
  </div>

  <div id="trip-panel" class="trip-panel hidden" aria-live="polite">
    <div class="trip-panel-header">
      <div class="trip-panel-title">
        <span id="trip-panel-icon" class="trip-panel-icon" aria-hidden="true">üêÑ</span>
        <span id="trip-panel-train">S√©lectionnez une b√©taill√®re ou une gare</span>
      </div>
      <button id="trip-panel-close" class="trip-panel-close" type="button" aria-label="Fermer">√ó</button>
    </div>
    <div class="trip-panel-body">
      <div id="trip-panel-summary" class="trip-panel-summary">Cliquez sur une ic√¥ne vache ou grange pour afficher le d√©tail.</div>
      <div class="trip-progress hidden" id="trip-progress">
        <div class="trip-progress-bar"><div id="trip-progress-fill" class="trip-progress-bar-fill"></div></div>
        <div id="trip-progress-text" class="trip-progress-text"></div>
      </div>
      <div id="trip-stops-title" class="trip-stops-title hidden">Gares desservies</div>
      <div id="trip-stops" class="trip-stops"></div>
    </div>
  </div>
  
  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ---------- Bases: 1) VPS GTFS static, 2) local /data/, 3) GitHub RAW ----------
  const BASES = [
    'https://vps.labetaillere.fr/gtfs/static/',
    location.origin + '/data/',
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/data/'
  ];

  // ---------- Fichiers attendus ----------
  const FILES = {
    // r√©seaux (noms selon ton repo)
    rfn:    'lignes-du-rfn.geojson',
    cfl:    'lignes_cfl-ajust√©.geojson',

    // GTFS requis / optionnels
    stops:        'stops.txt',
    stop_times:   'stop_times.txt',
    trips:        'trips.txt',          // optionnel
    routes:       'routes.txt',         // optionnel (pour labels)
    calendar:     'calendar.txt',       // optionnel (jours de circulation)
    calendar_dates: 'calendar_dates.txt'// optionnel (exceptions jour)
  };

   const CFL_BASES = [
    location.origin + '/CFL/',
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/CFL/'
  ];

  const CFL_FILES = {
    stops: 'stopscfl.txt',
    stop_times: 'stop_timescfl.txt',
    trips: 'tripscfl.txt',
    routes: 'routescfl.txt',
    calendar: 'calendarcfl.txt',
    calendar_dates: 'calendar_datescfl.txt'
  };

  const CFL_ROUTE_IDS_ALLOWED = new Set(['302','300','299','297']); // pas de TER 

  // ---------- Helpers fetch multi-bases ----------
  function urlFor(name, baseIndex=0, bases=BASES){ return bases[baseIndex] + name; }

  async function fetchJSONAny(name, bases = BASES){
    for (let i=0;i<bases.length;i++){
      try { const r = await fetch(urlFor(name,i,bases), {mode:'cors'}); if (r.ok) return await r.json(); } catch(_) {}
    }
    throw new Error('Introuvable: '+name);
  }

  async function fetchTextAny(name, bases = BASES){
    for (let i=0;i<bases.length;i++){
      try { const r = await fetch(urlFor(name,i,bases), {mode:'cors'}); if (r.ok) return await r.text(); } catch(_) {}
    }
    throw new Error('Introuvable: '+name);
  }

  function parseCSVAny(name, bases = BASES){
    return new Promise(async (resolve, reject) => {
      try {
        const csv = await fetchTextAny(name, bases);
        Papa.parse(csv, { header:true, dynamicTyping:false, skipEmptyLines:true,
          complete: (res)=>resolve(res.data), error: reject
        });
      } catch(e){ reject(e); }
    });
  }

   const statusState = { base:'', baseErr:false, realtime:'' };

  function renderStatus(){
    const el = document.getElementById('status');
    if (!el) return;
    const parts = [];
    if (statusState.base) parts.push(statusState.base);
    if (statusState.realtime) parts.push(statusState.realtime);
    const message = parts.filter(Boolean).join(' ‚Äî ');
    if (!message){
      el.textContent = '';
      return;
    }
    if (statusState.baseErr){
      el.innerHTML = '';
      const span = document.createElement('span');
      span.className = 'err';
      span.textContent = message;
      el.appendChild(span);
    } else {
      el.textContent = message;
    }
  }
    
  function setStatus(msg, isErr=false){
    statusState.base = msg || '';
    statusState.baseErr = !!isErr;
    renderStatus();
  }

  function setRealtimeStatus(msg){
    statusState.realtime = msg || '';
    renderStatus();
  }
    
function escapeHTML(str){
    return String(str ?? '').replace(/[&<>"']/g, c=>({
      '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;'
    })[c]);
  }
  function escapeAttr(str){
    return String(str ?? '').replace(/[&<>"']/g, c=>({
      '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;'
    })[c]);
  }
  function extractTrainNumberCandidate(value){
    if (value == null) return null;
    const raw = String(value).trim();
    if (!raw) return null;
    const candidates = [];
    const pushCandidate = (val, position = 0)=>{
      const str = String(val || '').replace(/^0+(?=\d)/, '').trim();
      if (!/^\d{3,}$/.test(str)) return;
      candidates.push({ value: str, position, length: str.length });
    };
    const tokens = raw.split(/[:\s]/).filter(Boolean);
    tokens.forEach((token, idx)=>{
      const matches = Array.from(token.matchAll(/\d{3,}/g));
      for (const match of matches){
        pushCandidate(match[0], idx);
      }
    });

    const fallbackDigits = Array.from(raw.matchAll(/\d{3,}/g));
    for (const match of fallbackDigits){
      pushCandidate(match[0], tokens.length + 1);
    }
    if (!candidates.length) return null;

    candidates.sort((a,b)=>{
      if (b.length !== a.length) return b.length - a.length;
      return b.position - a.position;
    });

    return candidates[0]?.value || null;
  }
 function normalizeTrainNumberKey(value){
  if (value == null) return null;
  const raw = String(value).trim();
  if (!raw) return null;
  const trimmed = raw.replace(/^0+/, '');
  if (trimmed.length) return trimmed;
  return raw.length ? '0' : null;
}

  const TRAIN_NUMBER_EQUIVALENCE_GROUPS = [
    ['2870','2871'],
    ['2864','2865'],
    ['2806','2807'],
    ['2872','2873'],
    ['2816','2817'],
    ['88504','88505'],
    ['88502','88503'],
    ['88500','88501'],
    ['88529','88530'],
    ['88531','88532'],
    ['88533','88534']
  ];

  function registerTrainNumberEquivalenceGroup(targetMap, values){
    if (!(targetMap instanceof Map) || !Array.isArray(values) || values.length < 2) return;
    const normalized = Array.from(new Set(
      values
        .map(v => normalizeTrainNumberKey(v))
        .filter(v => v != null)
        .map(v => String(v))
        .filter(Boolean)
    ));
    if (normalized.length < 2) return;
    for (const key of normalized){
      targetMap.set(key, normalized);
    }
  }

  function buildTrainNumberEquivalenceIndex(groups){
    const map = new Map();
    if (!Array.isArray(groups)) return map;
    for (const group of groups){
      registerTrainNumberEquivalenceGroup(map, Array.isArray(group) ? group : []);
    }
    return map;
  }

  const TRAIN_NUMBER_EQUIVALENTS = buildTrainNumberEquivalenceIndex(TRAIN_NUMBER_EQUIVALENCE_GROUPS);
  const dynamicTrainNumberEquivalents = new Map();

  function equivalentTrainNumbers(key){
    const norm = normalizeTrainNumberKey(key);
    if (norm == null) return [];
    const keyStr = String(norm);
    if (!keyStr) return [];
    const seen = new Set();
    const result = [];
    const collect = (map)=>{
      if (!(map instanceof Map)) return;
      const group = map.get(keyStr);
      if (!Array.isArray(group) || group.length < 2) return;
      for (const value of group){
        const str = value == null ? '' : String(value);
        if (!str || seen.has(str)) continue;
        seen.add(str);
        result.push(str);
      }
    };
    collect(TRAIN_NUMBER_EQUIVALENTS);
    collect(dynamicTrainNumberEquivalents);
    return result;
  }

  const DEFAULT_REALTIME_SOURCE_ORDER = ['sncf','gtfs','hafas'];
  const CFL_REALTIME_SOURCE_ORDER = ['hafas','sncf','gtfs'];
  const REALTIME_STATUS_DISPLAY_ORDER = ['sncf','hafas','gtfs'];
  const REALTIME_SOURCE_PRIORITY = { sncf: 3, hafas: 2, gtfs: 1 };

  function normalizeRealtimeSourceKey(value){
    if (!value && value !== 0) return '';
    return String(value).trim().toLowerCase();
  }

  function hasSncfRealtimeAffinity(target){
    if (!target || typeof target !== 'object') return false;
    const directSource = normalizeRealtimeSourceKey(target.source);
    if (directSource === 'sncf') return true;
    if (Array.isArray(target.mergedSources)){
      for (const src of target.mergedSources){
        if (normalizeRealtimeSourceKey(src) === 'sncf') return true;
      }
    }
    return false;
  }

  function shouldUseCflRealtimeOrder(target){
    if (!target || typeof target !== 'object'){
      return normalizeRealtimeSourceKey(target) === 'cfl';
    }
    if (hasSncfRealtimeAffinity(target)) return false;
    const categoryKey = normalizeRealtimeSourceKey(target.branding?.category);
    if (categoryKey === 'cfl') return true;
    const normalizedSource = normalizeRealtimeSourceKey(target.source);
    return normalizedSource === 'cfl';
  }  

  function resolvePreferredRealtimeSourceOrder(target){
    if (Array.isArray(target)){
      return target.filter(Boolean).map(normalizeRealtimeSourceKey).filter(Boolean);
    }
    const useCflOrder = shouldUseCflRealtimeOrder(target);
    const order = useCflOrder ? CFL_REALTIME_SOURCE_ORDER : DEFAULT_REALTIME_SOURCE_ORDER;
    return order.map(normalizeRealtimeSourceKey);
  }

  function classifyStopRealtimeNetwork(stopMeta){
    if (!stopMeta) return null;
    if (stopMeta.source === 'CFL') return 'cfl';
    const id = (stopMeta.stop_id || '').toUpperCase();
    const parent = (stopMeta.parent_station || '').toUpperCase();
    const isCflCode = (value)=> value && (/^CFL:/.test(value) || /^STOP(?:POINT|AREA):OCE82/.test(value));
    if (isCflCode(id) || isCflCode(parent)) return 'cfl';
    const isSncfCode = (value)=> value && /^STOP(?:POINT|AREA):OCE87/.test(value);
    if (isSncfCode(id) || isSncfCode(parent)) return 'sncf';
    return null;
  }

  function resolveStopRealtimeSourceOrder(stopMeta, baseOrder){
    const network = classifyStopRealtimeNetwork(stopMeta);
    if (network === 'cfl') return CFL_REALTIME_SOURCE_ORDER;
    if (network === 'sncf') return DEFAULT_REALTIME_SOURCE_ORDER;
    return Array.isArray(baseOrder) && baseOrder.length ? baseOrder : DEFAULT_REALTIME_SOURCE_ORDER;
  }

  function realtimeOptionsForTrain(train){
    return { preferredSources: resolvePreferredRealtimeSourceOrder(train) };
  }

  function getRealtimePerStationMaps(normalizedKey, preferredOrder){
    const keyStr = normalizedKey == null ? null : String(normalizedKey);
    if (!keyStr) return [];
    const order = Array.isArray(preferredOrder) && preferredOrder.length
      ? preferredOrder
      : DEFAULT_REALTIME_SOURCE_ORDER;
    const result = [];
    const seen = new Set();
    for (const sourceKey of order){
      const normalizedSource = normalizeRealtimeSourceKey(sourceKey);
      if (!normalizedSource || seen.has(normalizedSource)) continue;
      seen.add(normalizedSource);
      const src = realtimeSources[normalizedSource];
      if (!src || !(src.map instanceof Map) || !src.map.size) continue;
      const perStation = src.map.get(keyStr);
      if (perStation instanceof Map && perStation.size){
        result.push({ sourceKey: normalizedSource, perStation });
      }
    }
    return result;
  }
    
  function trainNumberForTrip(trip, route, tripId){
    const candidates = [
      trip?.trip_short_name,
      trip?.headsign,
      tripId ? tripId.split(':')[0] : null,
      route?.short
    ];
    for (const candidate of candidates){
      const num = extractTrainNumberCandidate(candidate);
      if (num) return num;
    }
    if (trip?.trip_short_name) return trip.trip_short_name;
    if (trip?.headsign) return trip.headsign;
    if (route?.short) return route.short;
    if (route?.long) return route.long;
    return tripId;
  }

 const CFL_ROUTE_PREFIXES = new Map([
    ['RE', 'RE'],
    ['RB', 'RB'],
    ['IC', 'IC'],
    ['TGV', 'TGV ROI']
  ]);

  function computeTrainBranding(tripId, trip, route, rawNumber, rawNumberKey){
    const isCfl = (tripId && tripId.startsWith('CFL:')) || trip?.source === 'CFL' || route?.source === 'CFL';
    const routeShort = (route?.short || '').trim();
    const routeLong = (route?.long || '').trim();
    const headsign = (trip?.headsign || '').trim();
    const tripShortName = (trip?.trip_short_name || '').trim();
    const normalizedShort = routeShort.toUpperCase();
    const brandingTokens = [routeShort, routeLong, headsign, tripShortName].filter(Boolean);
    const tripIdToken = (tripId || '').toUpperCase();

    const tokenMatches = (regex) => brandingTokens.some(value => regex.test(value));
    const mentionsTgv = tokenMatches(/\bTGV\b/i);
    const mentionsInoui = tokenMatches(/\bINOU[IY]\b/i);
    const mentionsOuigo = tokenMatches(/\bOUIGO\b/i);
    const tripIdHintsTgv = /:(?:OUI|TGV|INOU[IY]|OUIGO):/i.test(tripIdToken);
    const isTgv = mentionsTgv || mentionsInoui || mentionsOuigo || tripIdHintsTgv;

    let category = 'sncf';
    if (isCfl) category = 'cfl';
    if (isTgv) category = 'tgv-roi';

    let prefix = null;
    if (category === 'tgv-roi'){
      prefix = 'TGV ROI';
    } else if (isCfl && CFL_ROUTE_PREFIXES.has(normalizedShort)){
      prefix = CFL_ROUTE_PREFIXES.get(normalizedShort);
    }

    const rawDigits = rawNumberKey != null ? String(rawNumberKey) : null;
    let digits = rawDigits;
    if (digits && (isCfl || category === 'tgv-roi')){
      const trimmed = digits.replace(/^0+/, '');
      digits = trimmed || '0';
    }

    let displayNumber = null;
    if (prefix){
      displayNumber = digits ? `${prefix} ${digits}` : prefix;
    } else if (digits){
      displayNumber = digits;
    } else if (rawNumber){
      displayNumber = rawNumber;
    }

    const panelTitle = displayNumber || prefix || rawNumber || null;
    const className = category === 'tgv-roi' ? 'train-tgv-roi' : (category === 'cfl' ? 'train-cfl' : 'train-sncf');

    return {
      category,
      className,
      prefix,
      digits,
      displayNumber,
      panelTitle,
      rawDigits
    };
  }

  function trainLabelParts(train, fallbackId){
    if (!train) return { label:'', category:'sncf' };
    const label = train.branding?.panelTitle || train.number || train.headsign || fallbackId || '';
    const category = train.branding?.category || 'sncf';
    return { label, category };
  }

  function formatTrainLabel(train, { includeTrainWord = true, fallbackId } = {}){
    const { label, category } = trainLabelParts(train, fallbackId);
    if (!label) return fallbackId || '';
    if (!includeTrainWord || category === 'tgv-roi') return label;
    return `Train ${label}`;
  }

  function formatTrainAriaLabel(train, fallbackId){
    const { label, category } = trainLabelParts(train, fallbackId);
    if (!label) return 'train';
    const prefix = category === 'tgv-roi' ? '' : 'train ';
    return `${prefix}${label}`.trim();
  }   

  const luxTimeFormatter = new Intl.DateTimeFormat('fr-FR', {
    timeZone:'Europe/Luxembourg',
    hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
  });
  function formatLuxTime(date){ return luxTimeFormatter.format(date); }
    
  const luxDateFormatterIso = new Intl.DateTimeFormat('en-CA', {
    timeZone:'Europe/Luxembourg', year:'numeric', month:'2-digit', day:'2-digit'
  });
  const luxTimeFormatterIso = new Intl.DateTimeFormat('en-GB', {
    timeZone:'Europe/Luxembourg', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
  });
  function formatLuxDateISO(date){
    const parts = Object.fromEntries(luxDateFormatterIso.formatToParts(date).map(p=>[p.type, p.value]));
    return `${parts.year}-${parts.month}-${parts.day}`;
  }
  function formatLuxTimeISO(date){
    const parts = Object.fromEntries(luxTimeFormatterIso.formatToParts(date).map(p=>[p.type, p.value]));
    return `${parts.hour}:${parts.minute}:${parts.second}`;
  }

  const stationNameNormalizeCache = new Map();
  const stopNameCandidatesCache = new Map();  
  function normalizeStationName(name){
    if (name == null) return '';
    const raw = String(name);
    if (stationNameNormalizeCache.has(raw)) return stationNameNormalizeCache.get(raw);
    const normalized = raw
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[\u2019]/g, "'")
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .trim();
    stationNameNormalizeCache.set(raw, normalized);
    return normalized;
  }

  /* ---------- GTFS-RT : loader centralis√© + auto-apply ---------- */
  const SAME_ORIGIN_JSON = (()=>{
    // /carte.html -> /retards_nancymetzlux.json (si tu le seras un jour en local)
    const base = location.origin + location.pathname.replace(/\/[^\/]*$/, '/');
    return base + 'retards_nancymetzlux.json';
  })();
  
  // Ordre : m√™me origine (si jamais tu le copies localement) -> RAW GitHub -> jsDelivr -> API GitHub  
  const GTFS_RT_CANDIDATES = [
    'https://vps.labetaillere.fr/gtfs/retards_nancymetzlux.json',
    SAME_ORIGIN_JSON,
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/Assistant-train/retards_nancymetzlux.json',
    'https://cdn.jsdelivr.net/gh/TekMaTe-lux/Assistant-train@main/Assistant-train/retards_nancymetzlux.json'
  ];
  const GTFS_RT_REFRESH_INTERVAL_MS = 60000;
  const SNCF_RT_CACHE_URL = 'https://vps.labetaillere.fr/gtfs/retards_carte.json';
  const SNCF_RT_REFRESH_INTERVAL_MS = 5 * 60 * 1000;
  const SNCF_RT_STATUS_CANDIDATES = [
    'https://vps.labetaillere.fr/gtfs/retards_carte_status.html',
    'https://vps.labetaillere.fr/gtfs/retards_carte_status.json'
  ];
  const SNCF_RT_STATUS_REFRESH_INTERVAL_MS = 5 * 60 * 1000;

    const HAFAS_PROXY_SAME_ORIGIN = (()=>{
    const base = location.origin + location.pathname.replace(/\/[^\/]*$/, '/');
    return base + 'retards_cfl.json';
  })();

  const HAFAS_PROXY_CANDIDATES = [
    'https://vps.labetaillere.fr/gtfs/retards_cfl.json',
    HAFAS_PROXY_SAME_ORIGIN,
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/Assistant-train/retards_cfl.json',
    'https://cdn.jsdelivr.net/gh/TekMaTe-lux/Assistant-train@main/Assistant-train/retards_cfl.json'
  ];

  const HAFAS_LOOKAHEAD_MINUTES = 120;
  const HAFAS_REFRESH_INTERVAL_MS = 120000;
  const HAFAS_MAX_JOURNEYS = 20;
  const HAFAS_STATIONS = [
    { axisId:'rodange', hafasId:'220903011', label:'Rodange', names:['Rodange','Rodange, Gare'] },
    { axisId:'petange', hafasId:'220902007', label:'P√©tange', names:['P√©tange','Petange','P√©tange, Gare'] },
    { axisId:'bascharage-sanem', hafasId:'190101027', label:'Bascharage-Sanem', names:['Bascharage-Sanem','Bascharage/Sanem','Bascharage/Sanem, Gare','Bascharage, Gare'] },
    { axisId:'niederkorn', hafasId:'220203006', label:'Niederkorn', names:['Niederkorn','Niederkorn, Gare'] },
    { axisId:'differdange', hafasId:'220201021', label:'Differdange', names:['Differdange','Differdange, Gare'] },
    { axisId:'oberkorn', hafasId:'220201032', label:'Oberkorn', names:['Oberkorn','Oberkorn, Gare'] },
    { axisId:'belvaux-soleuvre', hafasId:'221301010', label:'Belvaux-Soleuvre', names:['Belvaux-Soleuvre','Belvaux Soleuvre','Belvaux-Soleuvre, Gare'] },
    { axisId:'belval-redange', hafasId:'221301002', label:'Belval-R√©dange', names:['Belval-R√©dange','Belval Redange','Belval-R√©dange, Gare'] },
    { axisId:'belval-lycee', hafasId:'221301023', label:'Belval-Lyc√©e', names:['Belval-Lyc√©e','Belval Lyc√©e','Belval (Lyc√©e), Gare'] },
    { axisId:'belval-universite', hafasId:'220401002', label:'Belval-Universit√©', names:['Belval-Universit√©','Belval Universit√©','Belval (Universit√©), Gare'] },
    { axisId:'esch', hafasId:'220402046', label:'Esch-sur-Alzette', names:['Esch-sur-Alzette','Esch sur Alzette','Esch-sur-Alzette, Gare'] },
    { axisId:'schifflange', hafasId:'221401002', label:'Schifflange', names:['Schifflange','Schifflange, Gare'] },
    { axisId:'noertzange', hafasId:'220105006', label:'Noertzange', names:['Noertzange','Noertzange, Gare'] },
    { axisId:'berchem', hafasId:'221101001', label:'Berchem', names:['Berchem','Berchem, Gare'] },
    { axisId:'pfaffenthal-kirchberg', hafasId:'200417051', label:'Pfaffenthal-Kirchberg', names:['Pfaffenthal-Kirchberg','Pfaffenthal-Kirchberg, Gare'] },
    { axisId:'dommeldange', hafasId:'200409015', label:'Dommeldange', names:['Dommeldange','Dommeldange, Gare'] },
    { axisId:'walferdange', hafasId:'201004001', label:'Walferdange', names:['Walferdange','Walferdange, Gare'] },
    { axisId:'heisdorf', hafasId:'200802003', label:'Heisdorf', names:['Heisdorf','Heisdorf, Gare'] },
    { axisId:'lorentzweiler', hafasId:'160807006', label:'Lorentzweiler', names:['Lorentzweiler','Lorentzweiler, Gare'] },
    { axisId:'lintgen', hafasId:'160702002', label:'Lintgen', names:['Lintgen','Lintgen, Gare'] },
    { axisId:'mersch', hafasId:'160904011', label:'Mersch', names:['Mersch','Mersch, Gare'] },
    { axisId:'cruchten', hafasId:'161001008', label:'Cruchten', names:['Cruchten','Cruchten, Gare'] },
    { axisId:'colmar-berg', hafasId:'141302004', label:'Colmar-Berg', names:['Colmar-Berg','Colmar-Berg, Gare'] },
    { axisId:'schieren', hafasId:'141301003', label:'Schieren', names:['Schieren','Schieren, Gare'] },
    { axisId:'ettelbruck', hafasId:'140701022', label:'Ettelbruck', names:['Ettelbruck','Ettelbruck, Gare'] },
    { axisId:'michelau', hafasId:'140307001', label:'Michelau', names:['Michelau','Michelau, Gare'] },
    { axisId:'goebelsmuhle', hafasId:'140304002', label:'Goebelsm√ºhle', names:['Goebelsm√ºhle','Goebelsm√ºhle, Gare'] },
    { axisId:'kautenbach', hafasId:'120603003', label:'Kautenbach', names:['Kautenbach','Kautenbach, Gare'] },
    { axisId:'wiltz', hafasId:'120903020', label:'Wiltz', names:['Wiltz','Wiltz, Gare'] },
    { axisId:'clervaux', hafasId:'110101016', label:'Clervaux', names:['Clervaux','Clervaux, Gare'] },
    { axisId:'drauffelt', hafasId:'110109004', label:'Drauffelt', names:['Drauffelt','Drauffelt, Gare'] },
    { axisId:'troisvierges', hafasId:'110606008', label:'Troisvierges', names:['Troisvierges','Troisvierges, Gare'] },
    { axisId:'cents-hamm', hafasId:'200406025', label:'Cents-Hamm', names:['Cents-Hamm','Cents-Hamm, Gare'] },
    { axisId:'sandweiler-contern', hafasId:'200601016', label:'Sandweiler-Contern', names:['Sandweiler-Contern','Sandweiler-Contern, Gare'] },
    { axisId:'oetrange', hafasId:'200204007', label:'Oetrange', names:['Oetrange','Oetrange, Gare'] },
    { axisId:'munsbach', hafasId:'200701001', label:'Munsbach', names:['Munsbach','Munsbach, Gare'] },
    { axisId:'roodt', hafasId:'180106009', label:'Roodt-sur-Syre', names:['Roodt-sur-Syre','Roodt-sur-Syre, Gare'] },
    { axisId:'wecker', hafasId:'180210005', label:'Wecker', names:['Wecker','Wecker, Gare'] },
    { axisId:'manternach', hafasId:'180603002', label:'Manternach', names:['Manternach','Manternach, Gare'] },
    { axisId:'mertert', hafasId:'180701004', label:'Mertert', names:['Mertert','Mertert, Gare'] },
    { axisId:'wasserbillig', hafasId:'180703009', label:'Wasserbillig', names:['Wasserbillig','Wasserbillig, Gare'] },
    { axisId:'luxembourg', hafasId:'200405060', label:'Luxembourg', names:['Luxembourg','Luxembourg, Gare Centrale'] },
    { axisId:'bettembourg', hafasId:'220102018', label:'Bettembourg', names:['Bettembourg','Bettembourg, Gare'] },
    { axisId:'howald', hafasId:'200304014', label:'Howald', names:['Howald','Howald, Gare'] },
    { axisId:'dudelange-usines', hafasId:'220301041', label:'Dudelange-Usines', names:['Dudelange-Usines','Dudelange (Usines), Gare'] },
    { axisId:'dudelange-ville', hafasId:'220301082', label:'Dudelange-Ville', names:['Dudelange-Ville','Dudelange (Ville), Gare'] },
    { axisId:'dudelange-centre', hafasId:'220301015', label:'Dudelange-Centre', names:['Dudelange-Centre','Dudelange (Centre), Gare'] },
    { axisId:'lamadelaine', hafasId:'220901011', label:'Lamadelaine', names:['Lamadelaine','Lamadelaine, Gare'] },
    { axisId:'bascharage-sanem', hafasId:'190101027', label:'Bascharage-Sanem', names:['Bascharage-Sanem','Bascharage/Sanem','Bascharage/Sanem, Gare','Bascharage, Gare'] },
    { axisId:'kleinbettingen', hafasId:'191103004', label:'Kleinbettingen', names:['Kleinbettingen','Kleinbettingen, Gare'] },
    { axisId:'capellen', hafasId:'190901001', label:'Capellen', names:['Capellen','Capellen, Gare'] },
    { axisId:'mamer', hafasId:'190903008', label:'Mamer', names:['Mamer','Mamer, Gare'] },
    { axisId:'bertrange-strassen', hafasId:'200101024', label:'Bertrange-Strassen', names:['Bertrange-Strassen','Bertrange, Gare'] },
    { axisId:'thionville', hafasId:'400000098', label:'Thionville', names:['Thionville','Thionville, Gare'] },
    { axisId:'metz', hafasId:'400000071', label:'Metz', names:['Metz','Metz-Ville','Metz-Ville, Gare'] }
  ];

    const HAFAS_COVERAGE_GAP_STATIONS = new Set([
    'pfaffenthal-kirchberg','dommeldange','walferdange','heisdorf','lorentzweiler','lintgen','mersch','cruchten','colmar-berg','schieren','ettelbruck','michelau','goebelsmuhle','kautenbach','wiltz','clervaux','drauffelt','troisvierges','cents-hamm','sandweiler-contern','oetrange','munsbach','roodt','wecker','manternach','mertert','wasserbillig','luxembourg','bettembourg','howald','berchem','noertzange','schifflange','esch','belval-universite','belval-lycee','belval-redange','belvaux-soleuvre','differdange','oberkorn','niederkorn','petange','rodange','dudelange-usines','dudelange-ville','dudelange-centre','dudelange-burange','lamadelaine','bascharage-sanem','kleinbettingen','capellen','mamer','bertrange-strassen'
  ]);

  const HAFAS_COVERAGE_GAP_REGEX = [
    /metz/i,
    /thionville/i,
    /nancy/i,
    /forbach/i,
    /longwy/i,
    /longuyon/i,
    /pagny/i,
    /pont[- ]?a[- ]?mousson/i,
    /audun/i,
    /lorraine/i,
    /france/i
  ];

  function isLikelyHafasCoverageGap(dep, station){
    if (!dep || !station) return false;
    const axisId = station.axisId || station.id || null;
    if (!axisId || !HAFAS_COVERAGE_GAP_STATIONS.has(axisId)) return false;

    const directionTokens = [dep.direction, dep.dirTxt, dep.dir, dep.Product?.direction, dep.Product?.dest];
    for (const token of directionTokens){
      if (!token) continue;
      const text = String(token);
      if (HAFAS_COVERAGE_GAP_REGEX.some(re => re.test(text))) return true;
    }

    const operatorTokens = [dep.Product?.operatorCode, dep.Product?.operator, dep.operator, dep.Product?.name, dep.Product?.line, dep.Product?.catOut, dep.Product?.catIn, dep.name];
    for (const token of operatorTokens){
      if (!token) continue;
      const lower = String(token).toLowerCase();
      if (lower.includes('sncf') || lower.includes('ter ') || lower.startsWith('ter') || lower.includes('tgv')) return true;
    }

    return false;
  }

  const realtimeRawData = { sncf:null, gtfs:null, hafas:null };
  const realtimeSources = {
    sncf: { key:'sncf', displayName:'API SNCF', origin:'', map:new Map(), lastUpdated:null, rawSource:'', error:null },
    gtfs: { key:'gtfs', displayName:'GTFS-RT', origin:'', map:new Map(), lastUpdated:null, rawSource:'', error:null },
    hafas: { key:'hafas', displayName:'HAFAS', origin:'API HAFAS', map:new Map(), lastUpdated:null, rawSource:'', error:null }
  };
  const sncfDisruptionsByTrain = new Map();  
  let trainDelaysByNumber = new Map();
  let trainDelaySourceLabel = '';
  let trainDelayLastUpdated = null;
  let trainDelayTooltipSuffix = '';
  let gtfsRtRefreshTimer = null;
  let hafasRefreshTimer = null;
  let sncfRefreshTimer = null;
  let sncfStatusRefreshTimer = null;
  let pendingGtfsRtPromise = null;
  let pendingHafasPromise = null;
  let pendingSncfPromise = null;
  let pendingSncfStatusPromise = null;

  function describeRealtimeSource(src){
    if (!src) return '';
    if (src === 'GitHub API') return 'GitHub API';
    try {
      const url = new URL(src, location.href);
      const host = url.hostname;
      if (host === location.hostname) return 'local';
      if (/githubusercontent\.com$/i.test(host)) return 'GitHub raw';
      if (/jsdelivr\.net$/i.test(host)) return 'jsDelivr';
      return host;
    } catch {
      return src;
    }
  }

  function setRealtimeSourceError(key, message){
    const src = realtimeSources[key];
    if (!src) return;
    src.error = message || null;
    updateRealtimeStatus();
  }

  function computeRealtimeDelayIndexSnapshot(sources){
    const combinedByTrain = new Map();
    const labelParts = [];
    let newest = null;

    const mergeEntry = (combined, norm, entry, sourceKey)=>{
      if (!combined || !norm) return;
      if (entry && !entry.sourceKey && sourceKey) entry.sourceKey = sourceKey;
      const incomingPriority = entry ? (REALTIME_SOURCE_PRIORITY[entry.sourceKey] ?? REALTIME_SOURCE_PRIORITY[sourceKey] ?? 0) : 0;
      const existing = combined.get(norm);
      const incomingCancelled = entry?.value == null;
      const existingCancelled = existing?.value == null;
      if (existing){
        const existingPriority = REALTIME_SOURCE_PRIORITY[existing.sourceKey] ?? 0;
        if (incomingPriority < existingPriority){
          return;
        }
        if (incomingPriority === existingPriority){
          if (existingCancelled && !incomingCancelled){
            combined.set(norm, entry);
            return;
          }
        }
      }
      combined.set(norm, entry);
    };

    for (const key of REALTIME_STATUS_DISPLAY_ORDER){
      const src = sources[key];
      if (!src) continue;
      let hadData = false;
      if (src.map && src.map.size){
        for (const [trainNumRaw, perStation] of src.map.entries()){
          const normalizedKey = normalizeTrainNumberKey(trainNumRaw) ?? trainNumRaw;
          const targets = new Set([String(trainNumRaw), String(normalizedKey)]);
          for (const alt of equivalentTrainNumbers(normalizedKey)){
            targets.add(String(alt));
          }
          for (const trainNum of targets){
            let combined = combinedByTrain.get(trainNum);
            if (!combined){
              combined = new Map();
              combinedByTrain.set(trainNum, combined);
            }
            for (const [norm, entry] of perStation.entries()){
              mergeEntry(combined, norm, entry, src.key);
            }
          }
        }
        hadData = true;
      }
      if (hadData || src.lastUpdated){
        const label = src.displayName || src.key.toUpperCase();
        labelParts.push(label);
        if (src.lastUpdated){
          newest = (!newest || src.lastUpdated > newest) ? src.lastUpdated : newest;
        }
      }
    }

    return { delaysByNumber: combinedByTrain, labelParts, newest };
  }

  function rebuildRealtimeDelayIndex(){
    const snapshot = computeRealtimeDelayIndexSnapshot(realtimeSources);
    trainDelaysByNumber = snapshot.delaysByNumber;

    realtimeStopDataByTrip.clear();
    trainDelaySourceLabel = snapshot.labelParts.join(' + ');
    trainDelayLastUpdated = snapshot.newest;
    trainDelayTooltipSuffix = '';
    updateRealtimeStatus();
    try { tick(); } catch(_){ }
  }

  function runRealtimePrioritySelfTest(){
    try {
      const now = Date.now();
      const sampleSources = {
        sncf: { key:'sncf', displayName:'API SNCF', map:new Map(), lastUpdated:now },
        gtfs: { key:'gtfs', displayName:'GTFS-RT', map:new Map(), lastUpdated:now - 1000 },
        hafas: { key:'hafas', displayName:'HAFAS', map:new Map(), lastUpdated:now - 2000 }
      };

      const sncfPerStation = new Map([
        ['stopA', { value: 600, sourceKey:'sncf' }],
        ['stopB', { value: null, sourceKey:'sncf' }]
      ]);
      sampleSources.sncf.map.set('88526', sncfPerStation);

      const gtfsPerStation = new Map([
        ['stopA', { value: 120, sourceKey:'gtfs' }],
        ['stopB', { value: 900, sourceKey:'gtfs' }]
      ]);
      sampleSources.gtfs.map.set('88526', gtfsPerStation);

      const hafasPerStation = new Map([
        ['stopC', { value: 180, sourceKey:'hafas' }]
      ]);
      sampleSources.hafas.map.set('88526', hafasPerStation);

      const snapshot = computeRealtimeDelayIndexSnapshot(sampleSources);
      const merged = snapshot.delaysByNumber.get('88526') || new Map();
      const stopA = merged.get('stopA');
      const stopB = merged.get('stopB');
      const stopC = merged.get('stopC');

      const tests = [
        { name:'SNCF prioritaire sur GTFS-RT', pass: stopA?.value === 600 && stopA?.sourceKey === 'sncf' },
        { name:'Suppression SNCF conserv√©e face √† GTFS-RT', pass: stopB?.value === null && stopB?.sourceKey === 'sncf' },
        { name:'HAFAS conserv√© si seul fournisseur', pass: stopC?.value === 180 && stopC?.sourceKey === 'hafas' }
      ];

      const failed = tests.filter(t => !t.pass);
      if (failed.length){
        console.warn('Self-test priorit√©s temps r√©el: ECHEC', failed);
      } else {
        console.info('Self-test priorit√©s temps r√©el: OK');
      }
    } catch(err){
      console.warn('Self-test priorit√©s temps r√©el: erreur', err);
    }
  }

  function updateRealtimeStatus(){
    const parts = [];
    const baseLabel = 'Retards temps r√©el activ√©s';
    parts.push(baseLabel);
    if (trainDelayLastUpdated){
      parts.push(`MAJ ${formatLuxTime(new Date(trainDelayLastUpdated))}`);
    }
    const errorParts = [];
    for (const key of REALTIME_STATUS_DISPLAY_ORDER){
      const src = realtimeSources[key];
      if (src?.error){
        const label = src.displayName || src.key.toUpperCase();
        errorParts.push(`${label}: ${src.error}`);
      }
    }
    if (errorParts.length){
      parts.push(errorParts.join(' | '));
    }

    const message = parts.filter(Boolean).join(' ‚Äî ');
    setRealtimeStatus(message);
  }

    const GTFS_RT_DELAY_MINUTE_KEYS = [
    'delay_minutes','delayMinutes','delay_minute','delay_min','delayMin','delay',
    'minutes','minute','mins','min','retard','retard_minutes','retardMinutes',
    'value','arrival_delay','departure_delay','arrDelay','depDelay','delayMin'
  ];
  const GTFS_RT_DELAY_SECOND_KEYS = [
    'delay_seconds','delaySeconds','seconds','secondes','sec','secs','delay_sec','delaySec'
  ];
const GTFS_RT_STOP_META_KEYS = new Set([
    'train_id','trainid','train_number','trainnumber','trip_id','tripid','trip',
    'status','state','current_status','currentstatus','source','count','counts','counters',
    'generated_at','generatedat','updated_at','updatedat','last_updated','lastupdated','timestamp',
    'cancelled_stops','cancelledstops','canceled_stops','canceledstops','suppressed_stops','deleted_stops'
  ]);

  function parseGtfsRtTimestamp(value){
    if (!value && value !== 0) return null;
    const str = String(value).trim();
    if (!str) return null;
    const parsed = Date.parse(str);
    return Number.isNaN(parsed) ? null : parsed;
  }
    
  function normalizeStatusToken(status){
    if (status == null) return '';
    return String(status)
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .trim()
      .toUpperCase();
  }

  function isCancelledStatus(status){
    const token = normalizeStatusToken(status);
    if (!token) return false;
    if (token === 'CANCELLED' || token === 'CANCELED' || token === 'DELETED' || token === 'REMOVED') return true;
    if (token.startsWith('SUPPRIM') || token.startsWith('SUPPRESS')) return true;
    return false;
  }

  function coerceGtfsRtDelayValue(rawValue, { trainStatus } = {}){
    if (isCancelledStatus(trainStatus)) return null;
    if (rawValue == null) return null;

    if (typeof rawValue === 'number'){ return Number.isFinite(rawValue) ? rawValue : undefined; }

    if (typeof rawValue === 'string'){
      if (isCancelledStatus(rawValue)) return null;
      const normalized = Number(rawValue.replace(',', '.'));
      if (Number.isFinite(normalized)) return normalized;
      const match = rawValue.match(/-?\d+(?:[.,]\d+)?/);
      if (match){
        const num = Number(match[0].replace(',', '.'));
        if (Number.isFinite(num)) return num;
      }
      return undefined;
    }

    if (typeof rawValue === 'boolean') return undefined;

    if (Array.isArray(rawValue)){
      for (const entry of rawValue){
        const val = coerceGtfsRtDelayValue(entry, { trainStatus });
        if (val !== undefined) return val;
      }
      return undefined;
    }

    if (typeof rawValue === 'object'){
      if (rawValue.cancelled === true || rawValue.canceled === true || rawValue.suppressed === true) return null;
      if (isCancelledStatus(rawValue.status || rawValue.state)) return null;

      for (const key of GTFS_RT_DELAY_MINUTE_KEYS){
        if (rawValue[key] != null){
          const num = Number(String(rawValue[key]).replace(',', '.'));
          if (Number.isFinite(num)) return num;
        }
      }

      for (const key of GTFS_RT_DELAY_SECOND_KEYS){
        if (rawValue[key] != null){
          const num = Number(String(rawValue[key]).replace(',', '.'));
          if (Number.isFinite(num)) return Math.round((num / 60) * 10) / 10;
        }
      }

      const nestedKeys = ['departure','arrival','dep','arr','outbound','inbound'];
      for (const key of nestedKeys){
        if (rawValue[key] != null && rawValue[key] !== rawValue){
          const nested = coerceGtfsRtDelayValue(rawValue[key], { trainStatus });
          if (nested !== undefined) return nested;
        }
      }

      return undefined;
    }

    return undefined;
  }

    function buildGtfsStopKeyVariants(name){
    const variants = new Set();
    const raw = name == null ? '' : String(name);
    const push = (value)=>{
      const norm = normalizeStationName(value);
      if (norm) variants.add(norm);
    };
    push(raw);
    if (raw){
      const colonless = raw.replace(/[:_-]+/g, ' ');
      if (colonless !== raw) push(colonless);
      const digits = raw.match(/\d{4,}/g) || [];
      for (const d of digits){
        push(d);
        push(`StopPoint ${d}`);
        push(`StopArea ${d}`);
        push(`Gare ${d}`);
      }
    }
    return Array.from(variants);
  }

  function registerGtfsRetards(data, source){
    if (!data || typeof data !== 'object') return;
    realtimeRawData.gtfs = data;
    const perTrain = new Map();
    const trainEntries = [];
    if (data.trains && typeof data.trains === 'object' && !Array.isArray(data.trains)){
      for (const [trainKey, payload] of Object.entries(data.trains)){
        trainEntries.push([trainKey, payload]);
      }
    }
    if (!trainEntries.length){
      for (const [trainKey, payload] of Object.entries(data)){
        if (trainKey === 'trains') continue;
        if (GTFS_RT_STOP_META_KEYS.has(String(trainKey).toLowerCase())) continue;
        trainEntries.push([trainKey, payload]);
      }
    }

    function collectGtfsCancellationStops(payload){
      if (!payload || typeof payload !== 'object') return [];
      const names = new Set();
      const candidateKeys = [
        'cancelled_stops','canceled_stops','cancelledStops','canceledStops','suppressed_stops','deleted_stops'
      ];
      const pushName = (name)=>{
        if (!name) return;
        const trimmed = String(name).trim();
        if (trimmed) names.add(trimmed);
      };
      for (const key of candidateKeys){
        if (!(key in payload)) continue;
        const value = payload[key];
        if (value == null) continue;
        if (Array.isArray(value)){
          for (const entry of value){
            if (entry == null) continue;
            if (typeof entry === 'string'){ pushName(entry); continue; }
            if (typeof entry === 'object'){
              const label = entry.station || entry.stop || entry.name || entry.label;
              if (label){ pushName(label); continue; }
              const keys = Object.keys(entry);
              if (keys.length === 1) pushName(keys[0]);
            }
          }
          continue;
        }
        if (typeof value === 'object'){
          for (const [stationName, flag] of Object.entries(value)){
            if (flag === false) continue;
            pushName(stationName);
          }
          continue;
        }
        if (typeof value === 'string') pushName(value);
      }
      return Array.from(names);
    }

    for (const [trainKey, payload] of trainEntries){
      if (payload == null) continue;
      const hasStopsContainer = typeof payload === 'object' && payload != null && !Array.isArray(payload);
      const trainStatus = hasStopsContainer
        ? (payload.status || payload.state || payload.train_status || payload.current_status)
        : null;
      const stopsData = hasStopsContainer && payload.stops && typeof payload.stops === 'object' && !Array.isArray(payload.stops)
        ? payload.stops
        : payload;
      if (!stopsData || typeof stopsData !== 'object') continue;
      
      const perStation = new Map();
      const registerStationEntry = (stationName, value)=>{
        const metaKey = stationName && typeof stationName === 'string' ? stationName.toLowerCase() : '';
        if (metaKey && GTFS_RT_STOP_META_KEYS.has(metaKey)) return false;
        const resolved = resolveRealtimeStationReference(stationName);
        const displayName = resolved.label || stationName;
        const stationId = resolved.stopId || null;
        const variantSet = new Set(buildGtfsStopKeyVariants(stationName));
        if (stationId){
          for (const variant of buildGtfsStopKeyVariants(stationId)) variantSet.add(variant);
        }
        if (displayName && displayName !== stationName){
          for (const variant of buildGtfsStopKeyVariants(displayName)) variantSet.add(variant);
        }
        const variants = Array.from(variantSet);
        if (!variants.length) return false;
        let stored = false;
        for (const key of variants){
          if (!key || GTFS_RT_STOP_META_KEYS.has(key)) continue;
          perStation.set(key, { original: displayName, value, source: 'GTFS-RT', sourceKey: 'gtfs', raw: stationName, stationId });
          stored = true;
        }
        return stored;
      };

      for (const [stationName, rawValue] of Object.entries(stopsData)){
        const value = coerceGtfsRtDelayValue(rawValue, { trainStatus });
        if (value === undefined) continue;
        registerStationEntry(stationName, value);
      }

      const cancelledStops = collectGtfsCancellationStops(payload);
      for (const stationName of cancelledStops){
        registerStationEntry(stationName, null);
      }
      if (perStation.size){
        const rawNumberCandidates = [
          hasStopsContainer ? payload.train_number : null,
          hasStopsContainer ? payload.trainNumber : null,
          hasStopsContainer ? payload.number : null,
          hasStopsContainer ? payload.trip_id : null,
          hasStopsContainer ? payload.tripId : null,
          trainKey
        ];
        let rawKey = trainKey;
        for (const candidate of rawNumberCandidates){
          if (candidate == null) continue;
          rawKey = String(candidate);
          break;
        }
        const normalizedKey = normalizeTrainNumberKey(rawKey) || rawKey;
        perTrain.set(normalizedKey, perStation);
      }
    }
    
    const originLabel = describeRealtimeSource(source);
    const generatedAtTs = parseGtfsRtTimestamp(
      data.generated_at || data.generatedAt || data.updated_at || data.updatedAt || data.last_updated || data.timestamp
    );
    realtimeSources.gtfs.origin = originLabel || realtimeSources.gtfs.origin;
    realtimeSources.gtfs.map = perTrain;
    realtimeSources.gtfs.lastUpdated = generatedAtTs || Date.now();
    realtimeSources.gtfs.rawSource = source || '';
    realtimeSources.gtfs.error = null;
    rebuildRealtimeDelayIndex();
  }

  function parseNavitiaDateTime(value){
    if (!value && value !== 0) return null;
    const str = String(value).trim();
    if (!str) return null;
    if (/^\d{8}T\d{6}$/i.test(str)){
      const year = Number(str.slice(0,4));
      const month = Number(str.slice(4,6)) - 1;
      const day = Number(str.slice(6,8));
      const hour = Number(str.slice(9,11));
      const minute = Number(str.slice(11,13));
      const second = Number(str.slice(13,15));
      return Date.UTC(year, month, day, hour, minute, second);
    }
    if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}(?::\d{2})?$/.test(str)){
      const normalized = str.length === 16 ? `${str}:00` : str;
      const parsed = Date.parse(normalized.endsWith('Z') ? normalized : `${normalized}Z`);
      return Number.isNaN(parsed) ? null : parsed;
    }
    let parsed = Date.parse(str);
    if (!Number.isNaN(parsed)) return parsed;
    parsed = Date.parse(`${str}Z`);
    return Number.isNaN(parsed) ? null : parsed;
  }

  function parseNavitiaTimeOfDay(value){
    if (value == null) return null;
    const str = String(value).trim();
    if (!/^\d{4}(\d{2})?$/.test(str)) return null;
    const hours = Number(str.slice(0, 2));
    const minutes = Number(str.slice(2, 4));
    const seconds = str.length >= 6 ? Number(str.slice(4, 6)) : 0;
    if (![hours, minutes, seconds].every(Number.isFinite)) return null;
    return (hours * 3600 + minutes * 60 + seconds) * 1000;
  }

  function diffNavitiaMinutes(real, base){
    const realTs = parseNavitiaDateTime(real);
    const baseTs = parseNavitiaDateTime(base);
    const diffFromDate = (realTs != null && baseTs != null)
      ? (realTs - baseTs) / 60000
      : null;

    if (diffFromDate != null && Number.isFinite(diffFromDate)) return diffFromDate;

    const realTod = parseNavitiaTimeOfDay(real);
    const baseTod = parseNavitiaTimeOfDay(base);
    if (realTod == null || baseTod == null) return null;

    const diff = (realTod - baseTod) / 60000;
    return Number.isFinite(diff) ? diff : null;
  }

  function computeSncfStopDelay(stopTime){
    if (!stopTime) return null;
    const tokens = [
      stopTime.stop_time_status,
      stopTime.stop_time_state,
      stopTime.status,
      stopTime.state,
      stopTime.stop_point?.status,
      stopTime.stop_point?.state,
      stopTime.stop_point?.stop_area?.status,
      stopTime.stop_point?.stop_area?.state
    ];
    if (Array.isArray(stopTime.properties)){
      for (const prop of stopTime.properties){
        if (!prop) continue;
        if (prop.value != null) tokens.push(prop.value);
        if (prop.text != null) tokens.push(prop.text);
      }
    }
    const cancelled = tokens.some(token => isCancelledStatus(token));
    
    const arrivalDelay = diffNavitiaMinutes(
      stopTime.arrival_date_time || stopTime.arrival_time || stopTime.amended_arrival_date_time || stopTime.amended_arrival_time,
      stopTime.base_arrival_date_time || stopTime.base_arrival_time
    );
    const departureDelay = diffNavitiaMinutes(
      stopTime.departure_date_time || stopTime.departure_time || stopTime.amended_departure_date_time || stopTime.amended_departure_time,
      stopTime.base_departure_date_time || stopTime.base_departure_time
    );
    
    const minutes = arrivalDelay ?? departureDelay;
    if (minutes == null && !cancelled) return null;
    return { cancelled, minutes };
  }

  function extractSncfStopCause(stopTime){
    if (!stopTime || typeof stopTime !== 'object') return null;
    const messageParts = [];
    const push = (v)=>{ if (v) messageParts.push(String(v)); };

    push(stopTime.cause || stopTime.reason || stopTime.message || stopTime.comment);
    push(stopTime.stop_time_effect || stopTime.effect || stopTime.status);

    if (Array.isArray(stopTime.notes)){
      for (const note of stopTime.notes){
        if (!note) continue;
        push(note.text || note.value || note.title || note.label);
      }
    }

    if (Array.isArray(stopTime.properties)){
      for (const prop of stopTime.properties){
        if (!prop) continue;
        push(prop.text || prop.value || prop.label);
      }
    }

    return messageParts.map(s => s.trim()).find(Boolean) || null;
  }
    
  function buildNavitiaDisruptionMessage(disruption){
    if (!disruption || typeof disruption !== 'object') return null;
    const texts = [];
    const push = (v)=>{ if (v) texts.push(String(v).trim()); };

    push(disruption.cause);
    
    if (Array.isArray(disruption.messages)){
      for (const msg of disruption.messages){
        if (!msg) continue;
        push(msg.text || msg.message || msg.title);
      }
    }
    
    if (Array.isArray(disruption.comments)){
      for (const msg of disruption.comments){
        if (!msg) continue;
        push(msg.text || msg.comment || msg.title);
      }
    }
    const severity = disruption.severity || {};
    const severityText = severity.name || severity.effect;
    const statusText = disruption.status;
    const rawEffect = (severity.effect || severity.name || statusText || '').toLowerCase();
    const isCancelled = rawEffect.includes('cancel') || rawEffect.includes('no_service');

    const primaryText = texts.find(Boolean) || severityText || null;
    if (!primaryText) return null;

    const label = isCancelled ? 'Suppression' : 'Retard';
    return `${label} : ${primaryText}`;
  }

  function registerSncfDisruptionTarget(map, ptObject, disruptionText){
    if (!ptObject || !disruptionText) return;
    const candidates = new Set();
    const id = ptObject.id || ptObject.label || ptObject.name;
    if (id) candidates.add(String(id));
    const extracted = extractTrainNumberCandidate(id || ptObject.label || ptObject.name);
    if (extracted) candidates.add(String(normalizeTrainNumberKey(extracted)));
    for (const key of candidates){
      if (!key) continue;
      if (!map.has(key)){
        map.set(key, disruptionText);
      }
    }
  }

  function parseSncfDisruptions(payload){
    const disruptions = new Map();
    const list = Array.isArray(payload?.disruptions) ? payload.disruptions : [];
    for (const disruption of list){
      const message = buildNavitiaDisruptionMessage(disruption);
      if (!message) continue;
      const impacted = Array.isArray(disruption.impacted_objects) ? disruption.impacted_objects : [];
      for (const obj of impacted){
        if (!obj) continue;
        registerSncfDisruptionTarget(disruptions, obj.pt_object || obj.ref_object || obj.object, message);
      }
    }
    return disruptions;
  }

  function mergeSncfDisruptions(disruptions, { replace = false } = {}){
    if (!(disruptions instanceof Map)) return;
    if (replace) sncfDisruptionsByTrain.clear();
    for (const [k,v] of disruptions.entries()){
      const key = String(k);
      if (!key || !v) continue;
      if (replace || !sncfDisruptionsByTrain.has(key)){
        sncfDisruptionsByTrain.set(key, v);
      }
    }
  }


  function registerSncfStationEntry(perStation, stationName, { stopPointId, stopAreaId } = {}, value){
    const resolved = resolveRealtimeStationReference(stationName || stopAreaId || stopPointId || '');
    const displayName = resolved.label || stationName || stopAreaId || stopPointId || '';
    const stationId = resolved.stopId || null;
    const variants = new Set();
    const pushVariants = (raw)=>{
      if (!raw) return;
      for (const variant of buildGtfsStopKeyVariants(raw)){
        if (variant) variants.add(variant);
      }
    };
    pushVariants(stationName);
    pushVariants(stopPointId);
    pushVariants(stopAreaId);
    if (displayName && displayName !== stationName) pushVariants(displayName);
    if (stationId) pushVariants(stationId);
    if (!variants.size) return false;
    for (const key of variants){
      if (!key || GTFS_RT_STOP_META_KEYS.has(key)) continue;
      perStation.set(key, { original: displayName || stationName, value, source: 'SNCF API', sourceKey: 'sncf', stationId, raw: stationName });
    }
    return true;
  }

  function buildSncfJourneyEntry(journey){
    if (!journey || typeof journey !== 'object') return null;
    const stopTimes = Array.isArray(journey.stop_times) ? journey.stop_times : [];
    if (!stopTimes.length) return null;
    let journeyCause = journey.cause || journey.reason || journey.disruption?.cause || journey.message;
    const numberCandidates = [
      journey.name,
      journey.vehicle_journey_name,
      journey.headsign,
      journey.id,
      journey.trip?.name,
      journey.trip?.id
    ];
    let keyCandidate = null;
    for (const candidate of numberCandidates){
      const extracted = extractTrainNumberCandidate(candidate);
      if (extracted){
        keyCandidate = extracted;
        break;
      }
    }
    if (keyCandidate == null && journey.id){
      keyCandidate = journey.id;
    }
    const normalizedKey = normalizeTrainNumberKey(keyCandidate);
    if (normalizedKey == null && normalizedKey !== 0) return null;
    const perStation = new Map();
    for (const stopTime of stopTimes){
      const stopPoint = stopTime?.stop_point || {};
      const stopArea = stopPoint.stop_area || {};
      const stationName = stopArea.name || stopArea.label || stopPoint.name || stopPoint.label || stopArea.id || stopPoint.id;
      if (!stationName) continue;
      const delay = computeSncfStopDelay(stopTime);
      if (!delay) continue;
      if (!journeyCause){
        journeyCause = extractSncfStopCause(stopTime);
      }
      const value = delay.cancelled ? null : delay.minutes;
      registerSncfStationEntry(perStation, stationName, { stopPointId: stopPoint.id, stopAreaId: stopArea.id }, value);
    }
    if (!perStation.size) return null;
    const disruptionText = journeyCause ? String(journeyCause).trim() : null;
    return { key: String(normalizedKey), perStation, disruptionText };
  }

  function parseSncfRealtimeContainer(raw, contextRaw){
    if (!raw || typeof raw !== 'object') return null;
    const payload = raw.data && typeof raw.data === 'object' && !Array.isArray(raw.data)
      ? raw.data
      : raw;
    
    const journeys = Array.isArray(payload.vehicle_journeys) ? payload.vehicle_journeys : [];
    const perTrain = new Map();
    const disruptions = parseSncfDisruptions(payload);
    
    for (const journey of journeys){
      const entry = buildSncfJourneyEntry(journey);
      if (entry){
        perTrain.set(entry.key, entry.perStation);
        if (entry.disruptionText){
          registerSncfDisruptionTarget(disruptions, { id: journey.id || journey.name || entry.key, name: journey.name || journey.id || entry.key }, entry.disruptionText);
        }
      }
    }
    
    const updatedAt = parseNavitiaDateTime(
      payload.context?.current_datetime
      || raw.context?.current_datetime
      || contextRaw?.context?.current_datetime
      || raw.generated_at
      || contextRaw?.generated_at
      || raw.updated_at
      || contextRaw?.updated_at
      || raw.timestamp
      || contextRaw?.timestamp
    ) || Date.now();

    return { perTrain, updatedAt, disruptions };
  }

  function parseSncfRealtimeData(raw){
    const aggregated = new Map();
    const disruptions = new Map();
    let newest = null;

    const mergeParsed = (parsed)=>{
      if (!parsed) return;
      if (parsed.disruptions instanceof Map){
        for (const [k,v] of parsed.disruptions.entries()){
          if (!k || !v) continue;
          if (!disruptions.has(k)) disruptions.set(k, v);
        }
      }
      if (parsed.perTrain instanceof Map){
        for (const [trainKey, perStation] of parsed.perTrain.entries()){
          if (!(perStation instanceof Map) || !perStation.size) continue;
          const existing = aggregated.get(trainKey);
          if (!existing || (parsed.updatedAt != null && (existing.updatedAt == null || parsed.updatedAt > existing.updatedAt))){
            aggregated.set(trainKey, { perStation, updatedAt: parsed.updatedAt });
          }
        }
      }
      if (parsed.updatedAt != null){
        newest = newest == null ? parsed.updatedAt : Math.max(newest, parsed.updatedAt);
      }
    };

    const parseContainer = (container, contextRaw)=>{
      const parsed = parseSncfRealtimeContainer(container, contextRaw);
      mergeParsed(parsed);
    };

    if (Array.isArray(raw)){
      for (const entry of raw){
        parseContainer(entry, raw);
      }
    } else if (raw && typeof raw === 'object'){
      const hasVehicleJourneys = Array.isArray(raw.vehicle_journeys) || Array.isArray(raw.data?.vehicle_journeys);
      const looksLikeNavitiaMap = Object.keys(raw).some(k => /vehicle_journey/i.test(k));
      if (hasVehicleJourneys){
        parseContainer(raw);
      } else if (looksLikeNavitiaMap){
        for (const value of Object.values(raw)){
          if (value && typeof value === 'object') parseContainer(value, raw);
        }
      } else {
        parseContainer(raw);
      }
    }

    const perTrain = new Map();
    for (const [key, entry] of aggregated.entries()){
      if (entry?.perStation instanceof Map && entry.perStation.size){
        perTrain.set(String(key), entry.perStation);
      }
    }

    return { perTrain, updatedAt: newest, disruptions };
  }

  function registerSncfVehicleJourneys(perTrainMap, { fetchedAt, disruptions } = {}){
    const normalized = new Map();
    if (perTrainMap instanceof Map){
      for (const [key, perStation] of perTrainMap.entries()){
        if (!(perStation instanceof Map) || !perStation.size) continue;
        normalized.set(String(key), perStation);
      }
    }
    realtimeRawData.sncf = perTrainMap instanceof Map ? perTrainMap : new Map();
    realtimeSources.sncf.map = normalized;
    realtimeSources.sncf.lastUpdated = fetchedAt || Date.now();
    mergeSncfDisruptions(disruptions, { replace:true });
    realtimeSources.sncf.error = null;
    rebuildRealtimeDelayIndex();
  }

  function normalizeSncfCachePayload(raw){
    if (!raw || typeof raw !== 'object') return raw;

      // Cas "Navitia brut" d√©j√† g√©r√© ‚Üí on ne touche √† rien
    if (Array.isArray(raw.vehicle_journeys) || (raw.data && Array.isArray(raw.data.vehicle_journeys))) {
      return raw;
    }

  // Cas "map de caches" du VPS : on fusionne tous les entry.data.*
    const merged = {
      vehicle_journeys: [],
      disruptions: [],
      context: {}
    };

    let newestCtx = null;
    const seen = new Set();
    const candidates = [];

    const pushCandidate = (obj)=>{
      if (!obj || typeof obj !== 'object') return;
      if (seen.has(obj)) return;
      seen.add(obj);
      candidates.push(obj);
      if (obj.trains && typeof obj.trains === 'object'){
        for (const v of Object.values(obj.trains)) pushCandidate(v);
      }
    };

   pushCandidate(raw);

    for (const entry of candidates){
      const data = entry.data;
      if (!data || typeof data !== 'object') continue;

    if (Array.isArray(data.vehicle_journeys)) {
        merged.vehicle_journeys.push(...data.vehicle_journeys);
      }
      if (Array.isArray(data.disruptions)) {
        merged.disruptions.push(...data.disruptions);
      }

      const ctx = data.context;
      if (ctx && ctx.current_datetime) {
        // on garde le plus r√©cent
        if (!newestCtx || parseNavitiaDateTime(ctx.current_datetime) > parseNavitiaDateTime(newestCtx)) {
          newestCtx = ctx.current_datetime;
        }
      }
    }
    
      if (!merged.vehicle_journeys.length) {
      // rien de d√©tect√© ‚Üí on rend le raw tel quel (pour ne pas casser)
      return raw;
    }

    if (newestCtx) {
      merged.context.current_datetime = newestCtx;
    }

    return merged;
  }
  
  async function loadSncfRealtime({ forceFresh = false } = {}){
  if (pendingSncfPromise) return pendingSncfPromise;

  pendingSncfPromise = (async()=>{
    const withBuster = (u)=> u + (u.includes('?') ? '&' : '?') + 't=' + (forceFresh ? Date.now() : 'soft');
    const url = withBuster(SNCF_RT_CACHE_URL);
    console.log('[SNCF] tentative:', url);
    const res = await fetchWithTimeoutNoHeaders(url, 10000);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const ct = (res.headers.get('content-type') || '').toLowerCase();
    const raw = ct.includes('application/json') ? await res.json() : JSON.parse(await res.text());

    // üî¥ NOUVEAU : adapter le format "cache VPS" ‚Üí format Navitia
    const data = normalizeSncfCachePayload(raw);

    const parsed = parseSncfRealtimeData(data);
    console.log('[SNCF] ‚úÖ via', SNCF_RT_CACHE_URL);
    realtimeSources.sncf.origin = 'cache VPS';
    realtimeSources.sncf.rawSource = SNCF_RT_CACHE_URL;
    registerSncfVehicleJourneys(parsed.perTrain, { fetchedAt: parsed.updatedAt, disruptions: parsed.disruptions });
    setRealtimeSourceError('sncf', null);
  })();

  try {
    await pendingSncfPromise;
  } catch(err){
    console.error('[SNCF] ‚ùå retards indisponibles', err);
    const hadData = realtimeSources.sncf.lastUpdated != null;
    setRealtimeSourceError('sncf', hadData ? 'rafra√Æchissement en √©chec' : 'indisponibles');
    throw err;
  } finally {
    pendingSncfPromise = null;
  }
}


    function pickStatusDisruption(entry){
    if (!entry || typeof entry !== 'object') return null;
    const keys = [
      'disruption', 'cause', 'reason', 'message', 'comment', 'status', 'status_text',
      'motif', 'motif_court', 'motif_long', 'incident', 'info', 'text', 'detail', 'details', 'description'
    ];
    for (const key of keys){
      const value = entry[key];
      if (value == null) continue;
      const str = String(value).trim();
      if (str) return str;
    }
    return null;
  }

  function parseSncfStatusPayload(raw){
    const disruptions = new Map();
    const register = (name, disruption)=>{
      if (!name || !disruption) return;
      registerSncfDisruptionTarget(disruptions, { id:String(name), name:String(name) }, String(disruption));
    };

    const handleEntry = (entry)=>{
      if (!entry || typeof entry !== 'object') return;
      const name = entry.name || entry.id || entry.tail;
      const disruption = pickStatusDisruption(entry);
      if (name && disruption) register(name, disruption);
    };

    if (typeof raw === 'string'){
      try { return parseSncfStatusPayload(JSON.parse(raw)); } catch(_){ }
      if (typeof DOMParser !== 'undefined'){
        try {
          const doc = new DOMParser().parseFromString(raw, 'text/html');
          doc.querySelectorAll('table tr').forEach(row=>{
            const cells = Array.from(row.querySelectorAll('td'));
            if (!cells.length) return;
            const name = cells[0].textContent?.trim();
            let disruption = null;
            const bodyCells = cells.slice(1);
            for (const cell of bodyCells){
              const text = cell.textContent?.trim();
              if (!text) continue;
              if (/d[√©e]tails?/i.test(text)) continue;
              if (/[a-zA-Z√Ä-√ø]/.test(text)){
                disruption = text;
                break;
              }
              disruption = disruption || text;
            }
            if (!disruption && bodyCells.length){
              disruption = bodyCells[bodyCells.length - 1]?.textContent?.trim();
            }
            if (name && disruption) register(name, disruption);
          });
        } catch(_){ }
      }
      return disruptions;
    }

    if (Array.isArray(raw)){
      for (const entry of raw) handleEntry(entry);
    } else if (raw && typeof raw === 'object'){
      const entries = Array.isArray(raw.entries) ? raw.entries : Array.isArray(raw.data) ? raw.data : null;
      if (entries){
        for (const entry of entries) handleEntry(entry);
      }
    }
    return disruptions;
  }

  async function loadSncfStatus(){
    if (pendingSncfStatusPromise) return pendingSncfStatusPromise;
    pendingSncfStatusPromise = (async()=>{
      const errors = [];
      for (const candidate of SNCF_RT_STATUS_CANDIDATES){
        const url = candidate + '?t=' + Date.now();
        try {
          const res = await fetchWithTimeoutNoHeaders(url, 8000);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const text = await res.text();
          const parsed = parseSncfStatusPayload(text);
          mergeSncfDisruptions(parsed);
          console.log('[SNCF] status via', candidate);
          return;
        } catch(err){
          errors.push({ candidate, err });
        }
      }
      const first = errors[0];
      const message = first ? `${first.candidate} ‚Üí ${first.err}` : 'Aucune source status disponible';
      throw new Error(message);
    })();
    try {
      await pendingSncfStatusPromise;
    } catch(err){
      console.warn('[SNCF] status indisponible', err);
    } finally {
      pendingSncfStatusPromise = null;
    }
  }

    function parseHafasProxyTimestamp(value){
    if (value == null) return null;
    if (typeof value === 'number' && Number.isFinite(value)){
      if (value > 1e12) return Math.round(value);
      if (value > 1e5) return Math.round(value * 1000);
      return Math.round(value * 1000);
    }
    const str = String(value).trim();
    if (!str) return null;
    let parsed = Date.parse(str);
    if (!Number.isNaN(parsed)) return parsed;
    parsed = Date.parse(`${str}Z`);
    if (!Number.isNaN(parsed)) return parsed;
    return null;
  }

  function parseHafasProxyDelayValue(raw){
    if (raw == null) return { cancellation:true, minutes:null, hasMinutes:false };
    if (typeof raw === 'number'){
      if (Number.isFinite(raw)) return { cancellation:false, minutes: raw, hasMinutes:true };
      return { cancellation:false, minutes:null, hasMinutes:false };
    }
    if (typeof raw === 'string'){
      const trimmed = raw.trim();
      if (!trimmed) return { cancellation:false, minutes:null, hasMinutes:false };
      const cancellation = /cancel|suppr|delete|annul/i.test(trimmed);
      const numeric = Number(trimmed.replace(',', '.'));
      if (!Number.isNaN(numeric)){
        return { cancellation, minutes:numeric, hasMinutes:true };
      }
      return { cancellation, minutes:null, hasMinutes:false };
    }
    if (Array.isArray(raw)){
      let cancellation = false;
      let minutes = null;
      let hasMinutes = false;
      if (raw.length === 2 && typeof raw[0] === 'string'){
        const nested = parseHafasProxyDelayValue(raw[1]);
        const cancellationHint = /cancel|suppr|delete|annul/i.test(raw[0]);
        return {
          cancellation: nested.cancellation || cancellationHint,
          minutes: nested.minutes,
          hasMinutes: nested.hasMinutes
        };
      }
      for (const item of raw){
        const nested = parseHafasProxyDelayValue(item);
        if (nested.cancellation) cancellation = true;
        if (nested.hasMinutes && (!hasMinutes || Math.abs(nested.minutes) > Math.abs(minutes ?? 0))){
          minutes = nested.minutes;
          hasMinutes = true;
        }
      }
      return { cancellation, minutes, hasMinutes };
    }
    if (typeof raw === 'object'){
      let cancellation = false;
      let minutes = null;
      let hasMinutes = false;
      if (raw.cancelled != null) cancellation = cancellation || Boolean(raw.cancelled);
      const status = raw.status || raw.state || raw.rtStatus || raw.rtState || raw.note;
      if (status && /cancel|suppr|delete|annul/i.test(String(status))) cancellation = true;
      const keys = ['delay','minutes','value','rtDelay','delayMinutes','min','rt','realtime','rtMinutes'];
      for (const key of keys){
        if (raw[key] == null) continue;
        const nested = parseHafasProxyDelayValue(raw[key]);
        if (nested.cancellation) cancellation = true;
        if (nested.hasMinutes && (!hasMinutes || Math.abs(nested.minutes) > Math.abs(minutes ?? 0))){
          minutes = nested.minutes;
          hasMinutes = true;
        }
      }
      return { cancellation, minutes, hasMinutes };
    }
    return { cancellation:false, minutes:null, hasMinutes:false };
  }

  function appendHafasProxyStationEntry(map, stationName, rawValue){
    if (!stationName) return;
    const norm = normalizeStationName(stationName);
    if (!norm) return;
    const { cancellation, minutes, hasMinutes } = parseHafasProxyDelayValue(rawValue);
    if (cancellation){
      map.set(norm, { original: stationName, value: null, source: 'HAFAS', sourceKey: 'hafas' });
      return;
    }
    if (!hasMinutes) return;
    const value = Number(minutes);
    if (!Number.isFinite(value)) return;
    const existing = map.get(norm);
    if (existing && existing.value != null){
      const existingVal = Number(existing.value);
      if (Number.isFinite(existingVal) && Math.abs(existingVal) >= Math.abs(value)) return;
    }
    map.set(norm, { original: stationName, value, source: 'HAFAS', sourceKey: 'hafas' });
  }

  function buildHafasProxyStationMap(raw){
    const perStation = new Map();
    if (!raw) return perStation;
    if (Array.isArray(raw)){
      for (const entry of raw){
        if (entry == null) continue;
        if (Array.isArray(entry)){
          if (!entry.length) continue;
          const stationName = entry[0];
          const value = entry.length > 1 ? entry[1] : null;
          appendHafasProxyStationEntry(perStation, stationName, value);
          continue;
        }
        if (typeof entry === 'object'){
          const stationName = entry.station || entry.stop || entry.name || entry.label;
          if (stationName){
            const value = entry.delay ?? entry.minutes ?? entry.value ?? entry.rtDelay ?? entry.delayMinutes ?? entry.min ?? entry.rt ?? entry.realtime;
            appendHafasProxyStationEntry(perStation, stationName, value ?? entry);
            continue;
          }
          const keys = Object.keys(entry);
          if (keys.length === 1){
            const key = keys[0];
            appendHafasProxyStationEntry(perStation, key, entry[key]);
          }
          continue;
        }
      }
      return perStation;
    }
    if (typeof raw === 'object'){
      for (const [stationName, value] of Object.entries(raw)){
        appendHafasProxyStationEntry(perStation, stationName, value);
      }
    }
    return perStation;
  }

  function parseHafasProxyData(data){
    const perTrain = new Map();
    if (!data || typeof data !== 'object'){
      return { perTrain, updatedAt: null };
    }
    let container = null;
    for (const candidate of [data.data, data.trains, data.journeys, data]){
      if (candidate && typeof candidate === 'object' && !Array.isArray(candidate)){
        container = candidate;
        break;
      }
    }
    if (container){
      for (const [trainKey, raw] of Object.entries(container)){
        if (!trainKey) continue;
        const stationMap = buildHafasProxyStationMap(raw);
        if (!stationMap.size) continue;
        const candidate = extractTrainNumberCandidate(trainKey);
        const rawKey = candidate != null ? String(candidate) : String(trainKey);
        const normalizedKey = normalizeTrainNumberKey(rawKey) || rawKey;
        perTrain.set(normalizedKey, stationMap);
      }
    }
    const updatedAt = parseHafasProxyTimestamp(
      data.updatedAt || data.updated_at || data.generatedAt || data.generated_at || data.lastUpdated || data.timestamp
    );
    return { perTrain, updatedAt };
  }

  async function fetchHafasProxySnapshot(){
    const withBuster = (u)=> u + (u.includes('?') ? '&' : '?') + 't=' + Date.now();
    let lastErr = null;
    for (const candidate of HAFAS_PROXY_CANDIDATES){
      if (!candidate) continue;
      const url = withBuster(candidate);
      try {
        console.log('[HAFAS proxy] tentative:', url);
        const res = await fetchWithTimeoutNoHeaders(url, 8000);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const ct = (res.headers.get('content-type') || '').toLowerCase();
        let data;
        if (ct.includes('application/json')){
          data = await res.json();
        } else {
          data = JSON.parse(await res.text());
        }
        const parsed = parseHafasProxyData(data);
        return { perTrain: parsed.perTrain, updatedAt: parsed.updatedAt, source: candidate };
      } catch(err){
        console.warn('[HAFAS proxy] √©chec sur', candidate, err);
        lastErr = err;
      }
    }
    if (lastErr) throw lastErr;
    throw new Error('Proxy HAFAS indisponible');
  }

  function registerHafasRetards(perTrainMap, { fetchedAt } = {}){
    const normalized = new Map();
    if (perTrainMap instanceof Map){
      for (const [trainNum, perStation] of perTrainMap.entries()){
        if (!(perStation instanceof Map) || !perStation.size) continue;
        const stationMap = new Map();
        for (const [norm, entry] of perStation.entries()){
          if (!norm || !entry) continue;
          stationMap.set(String(norm), { original: entry.original, value: entry.value, source: 'HAFAS' });
        }
        if (stationMap.size){
          const rawKey = String(trainNum);
          const normalizedKey = normalizeTrainNumberKey(rawKey) || rawKey;
          normalized.set(normalizedKey, stationMap);
        }
      }
    }
    realtimeRawData.hafas = perTrainMap instanceof Map ? perTrainMap : new Map();
    realtimeSources.hafas.map = normalized;
    realtimeSources.hafas.lastUpdated = fetchedAt || Date.now();
    realtimeSources.hafas.error = null;
    rebuildRealtimeDelayIndex();
  }

  function normalizeHafasDate(value){
    if (!value && value !== 0) return null;
    const str = String(value).trim();
    if (!str) return null;
    if (/^\d{8}$/.test(str)) return `${str.slice(0,4)}-${str.slice(4,6)}-${str.slice(6)}`;
    return str;
  }

  function normalizeHafasTime(value){
    if (!value && value !== 0) return null;
    const str = String(value).trim();
    if (!str) return null;
    if (/^\d{6}$/.test(str)) return `${str.slice(0,2)}:${str.slice(2,4)}:${str.slice(4,6)}`;
    if (/^\d{4}$/.test(str)) return `${str.slice(0,2)}:${str.slice(2,4)}:00`;
    if (/^\d{2}:\d{2}$/.test(str)) return `${str}:00`;
    return str;
  }

  function extractHafasTrainNumber(dep){
    if (!dep || typeof dep !== 'object') return null;
    const candidates = [
      dep.trainNumber,
      dep.name,
      dep.number,
      dep.line,
      dep.Line,
      dep.Product?.line,
      dep.Product?.name,
      dep.Product?.catOut,
      dep.Product?.catIn,
      dep.Product?.lineId,
      dep.Product?.number,
      dep.JourneyDetailRef?.ref,
      dep.id
    ];
    for (const candidate of candidates){
      const num = extractTrainNumberCandidate(candidate);
      if (num) return num;
    }
    return null;
  }

  function computeHafasDelay(dep, station){
    const cancelTokens = [dep?.cancelled, dep?.status, dep?.rtStatus, dep?.rtState];
    const isCancelled = cancelTokens.some(token => {
      if (token == null) return false;
      const str = String(token).toLowerCase();
      return str === 'true' || str === 'yes' || str === 'cancelled' || str === 'canceled' || str === 'deleted';
    });
    if (isCancelled && !isLikelyHafasCoverageGap(dep, station)) return { cancelled:true, minutes:null };
    if (isCancelled) return { cancelled:false, minutes:null };

    const plannedDate = normalizeHafasDate(dep?.date);
    const plannedTime = normalizeHafasTime(dep?.time);
    const rtDate = normalizeHafasDate(dep?.rtDate || dep?.rtDateTime || dep?.rtDateTimeOut || dep?.date);
    const rtTime = normalizeHafasTime(dep?.rtTime || dep?.rtTimeOut || dep?.rtDepartureTime);

    if (plannedDate && plannedTime && rtTime){
      const scheduled = new Date(`${plannedDate}T${plannedTime}`);
      const realtime = new Date(`${(rtDate || plannedDate)}T${rtTime}`);
      if (!Number.isNaN(scheduled.getTime()) && !Number.isNaN(realtime.getTime())){
        const diff = (realtime - scheduled) / 60000;
        if (Number.isFinite(diff)) return { cancelled:false, minutes: diff };
      }
    }

    if (dep?.rtDelay != null){
      const val = Number(dep.rtDelay);
      if (Number.isFinite(val)) return { cancelled:false, minutes: val };
    }
    if (dep?.delay != null){
      const val = Number(dep.delay);
      if (Number.isFinite(val)) return { cancelled:false, minutes: val };
    }

    if (plannedTime && rtTime){
      const scheduled = new Date(`1970-01-01T${plannedTime}`);
      const realtime = new Date(`1970-01-01T${rtTime}`);
      if (!Number.isNaN(scheduled.getTime()) && !Number.isNaN(realtime.getTime())){
        const diff = (realtime - scheduled) / 60000;
        if (Number.isFinite(diff)) return { cancelled:false, minutes: diff };
      }
    }

    return { cancelled:false, minutes: 0 };
  }

  async function loadHafasDelays({ duration = HAFAS_LOOKAHEAD_MINUTES } = {}){
    if (pendingHafasPromise) return pendingHafasPromise;
    pendingHafasPromise = (async()=>{
    let snapshot = null;
      try {
        snapshot = await fetchHafasProxySnapshot();
      } catch(err){
        console.warn('[HAFAS] proxy indisponible', err);
      }
      if (snapshot){
        realtimeSources.hafas.origin = 'Proxy CFL';
        realtimeSources.hafas.rawSource = snapshot.source || '';
        registerHafasRetards(snapshot.perTrain, { fetchedAt: snapshot.updatedAt || Date.now() });
        setRealtimeSourceError('hafas', null);
        return;
      }

      setRealtimeSourceError('hafas', 'indisponibles');
      throw new Error('Proxy HAFAS indisponible');
    })();

    try {
      await pendingHafasPromise;
    } finally {
      pendingHafasPromise = null;
    }
  }
    
  function shouldIgnoreCancellation(entry, train){
    if (!entry || entry.value !== null) return false;
    const source = (entry.source || '').toUpperCase();
    if (source !== 'HAFAS') return false;
    if (!train) return false;
    if (Array.isArray(train.mergedSources)){
      return train.mergedSources.some(src => String(src).toUpperCase() === 'SNCF');
    }
    return String(train.source || '').toUpperCase() === 'SNCF';
  }

  function resolveRealtimeNumberKey(train){
    if (!train) return null;
    const candidates = [
      train.numberKey,
      extractTrainNumberCandidate(train.number),
      extractTrainNumberCandidate(train.id)
    ];
    for (const candidate of candidates){
      const norm = normalizeTrainNumberKey(candidate);
      if (norm || norm === 0) return norm;
    }
    return null;
  }

  function isTrainFullyCancelled(train){
    if (!train) return null;
    const seq = stopTimesByTrip.get(train.id);
    if (!seq || !seq.length) return null;
    const numberKey = resolveRealtimeNumberKey(train);
    const profile = realtimeStopDataByTrip.get(train.id)
      || computeRealtimeStopData(train.id, seq, numberKey ?? train.id, realtimeOptionsForTrain(train));
    if (!profile || !profile.stops || !profile.stops.length) return null;
    const cancellation = profile.cancellation;
    if (cancellation && cancellation.index === 0) return true;
    const allCancelled = profile.stops.every(st => st?.cancelled);
    if (allCancelled) return true;
    return false;
  }

  function buildDelayInfo(entry, train){
    if (!entry) return null;
    if (entry.value == null){
      if (shouldIgnoreCancellation(entry, train)) return null;
      const station = entry.original || null;
      let title = station ? `Train supprim√© √† ${station}` : 'Train supprim√©';
      const panelText = station ? `Train supprim√© √† ${station}` : 'Train supprim√© (temps r√©el)';
      return {
        label:'Supprim√©',
        minutes:null,
        station,
        severity:'cancelled',
        badgeClass:'train-delay-badge train-delay-badge--cancelled',
        title,
        panelText,
        panelContext: '',
        sourceLabel: trainDelaySourceLabel
      };
    }
    const minutes = Number(entry.value);
    if (!Number.isFinite(minutes) || minutes <= 0) return null;
    const rounded = Math.round(minutes);
    let severity = 'moderate';
    if (rounded >= 15) severity = 'severe';
    else if (rounded >= 10) severity = 'major';
    const station = entry.original || null;
    const label = `+${rounded} min`;
    const where = station ? ` √† ${station}` : '';
    let title = `Retard estim√© ${label}${where}`;
    const panelText = `Retard ${label}${where}`;
    return {
      label,
      minutes,
      rounded,
      station,
      severity,
      badgeClass:`train-delay-badge train-delay-badge--${severity}`,
      title,
      panelText,
      panelContext: '',
      sourceLabel: trainDelaySourceLabel
    };
  }

  function computeDelayInfoFromPerStation(perStation, train){
    if (!perStation || !perStation.size) return null;

    const fullyCancelled = isTrainFullyCancelled(train);

    const candidateOrder = [];
    const seen = new Set();
    const pushCandidate = (name)=>{
      if (!name) return;
      const norm = normalizeStationName(name);
      if (!norm || seen.has(norm)) return;
      seen.add(norm);
      candidateOrder.push({ norm, original: name });
    };

    if (train.segmentProgress != null){
      if (train.segmentProgress <= 0.25 && train.from) pushCandidate(train.from);
      if (train.to) pushCandidate(train.to);
      if (train.from) pushCandidate(train.from);
    } else {
      if (train.to) pushCandidate(train.to);
      if (train.from) pushCandidate(train.from);
    }

    for (const candidate of candidateOrder){
      const entry = perStation.get(candidate.norm);
      if (!entry) continue;
      if (entry.value == null){
        if (fullyCancelled === false) continue;
        const info = buildDelayInfo(entry, train);
        if (info) return info;
        continue;
      }
      const info = buildDelayInfo(entry, train);
      if (info) return info;
    }

    let fallback = null;
    for (const entry of perStation.values()){
      if (fallback && fallback.severity === 'cancelled') break;
      if (entry.value == null){
        if (fullyCancelled === false) continue;
        const info = buildDelayInfo(entry, train);
        if (info) fallback = info;
        continue;
      }
      const info = buildDelayInfo(entry, train);
      if (!info) continue;
      if (!fallback || (fallback.minutes != null && info.minutes > fallback.minutes)){
        fallback = info;
      }
    }
    return fallback;
  }
  function computeTrainDelayInfo(train){
    if (!train || !trainDelaysByNumber.size) return null;
    const candidateKeys = [];
    const pushKey = (value)=>{
      if (value == null) return;
      const candidate = extractTrainNumberCandidate(value) ?? value;
      const normalized = normalizeTrainNumberKey(candidate);
      if (!normalized && normalized !== 0) return;
      const keyStr = String(normalized);
      if (!keyStr) return;
      if (candidateKeys.includes(keyStr)) return;
      candidateKeys.push(keyStr);
    };

    pushKey(train.numberKey);
    if (Array.isArray(train.delayNumberKeys)){
      for (const key of train.delayNumberKeys) pushKey(key);
    }
    pushKey(train.numberDigits);
    pushKey(train.number);
    pushKey(train.numberRaw);
    pushKey(train.branding?.digits);
    pushKey(train.id);

    if (!candidateKeys.length) return null;

    let cancelledInfo = null;
    const preferredOrder = resolvePreferredRealtimeSourceOrder(train);
    for (const key of candidateKeys){
      const sourceMaps = getRealtimePerStationMaps(key, preferredOrder);
      for (const { perStation } of sourceMaps){
        const info = computeDelayInfoFromPerStation(perStation, train);
        if (!info) continue;
        if (info.severity === 'cancelled'){
          if (!cancelledInfo) cancelledInfo = info;
          continue;
        }
        return info;
      }
      const perStation = trainDelaysByNumber.get(String(key));
      if (!perStation) continue;
      const info = computeDelayInfoFromPerStation(perStation, train);
      if (!info) continue;
      if (info.severity === 'cancelled'){
        if (!cancelledInfo) cancelledInfo = info;
        continue;
      }
      return info;
    }
    return cancelledInfo;
  }

  
  function findSncfDisruptionForTrain(train){
    const candidates = [];
    const push = (v)=>{ if (v!=null) candidates.push(v); };
    push(buildSncfTailForTrain(train));
    push(train.id);
    push(train.numberKey);
    push(train.numberDigits);
    push(train.number);
    push(train.numberRaw);
    push(train.branding?.digits);
    for (const candidate of candidates){
      if (candidate == null) continue;
      const norm = normalizeTrainNumberKey(candidate);
      const keyList = [String(candidate)];
      if (norm != null || norm === 0) keyList.push(String(norm));
      for (const k of keyList){
        if (sncfDisruptionsByTrain.has(k)) return sncfDisruptionsByTrain.get(k);
      }
    }
    return null;
  }  
    
 function getStopNameCandidates(stopMeta){
    if (!stopMeta) return [];
    const key = stopMeta.stop_id || null;
    if (key && stopNameCandidatesCache.has(key)) return stopNameCandidatesCache.get(key);
    const names = new Set();
    const add = (value)=>{ if (value) names.add(String(value)); };
    add(stopMeta.name);
    add(stopMeta.stop_name);
    add(stopMeta.stop_desc || stopMeta.desc);
    if (stopMeta.parent_station){
      const parent = stopsById.get(stopMeta.parent_station);
      if (parent){
        add(parent.name);
        add(parent.stop_name);
        add(parent.stop_desc || parent.desc);
      }
    }
    const axisStation = axisStationByStopId.get(stopMeta.stop_id) || (stopMeta.parent_station ? axisStationByStopId.get(stopMeta.parent_station) : null);
    if (axisStation){
      add(axisStation.label);
    }
    const derived = [];
    for (const name of names){
      const simplified = name.replace(/^gare(?:\s+(de|du|des|d'))?\s*/i,'').trim();
      if (simplified && simplified.length && simplified !== name){
        derived.push(simplified);
      }
    }
    for (const name of derived) names.add(name);
    const arr = Array.from(names).filter(Boolean);
    if (key) stopNameCandidatesCache.set(key, arr);
    return arr;
  }
function buildStopMetaKeyCandidates(stopMeta){
    const variants = new Set();
    const consider = (raw)=>{
      if (!raw && raw !== 0) return;
      const str = String(raw);
      const push = (value)=>{
        const norm = normalizeStationName(value);
        if (norm) variants.add(norm);
      };
      push(str);
      const stripped = str.replace(/[:_-]+/g, ' ');
      if (stripped !== str) push(stripped);
      const digits = str.match(/\d{4,}/g) || [];
      for (const d of digits){
        push(d);
        push(`StopPoint ${d}`);
        push(`StopArea ${d}`);
        push(`Gare ${d}`);
      }
    };
    consider(stopMeta?.stop_id);
    consider(stopMeta?.parent_station);
    return Array.from(variants);
  }

function adaptDelayEntryForStop(entry, stopMeta){
    if (!entry) return entry;
    const preferredName = bestNameForStopMeta(stopMeta);
    if (preferredName && preferredName !== entry.original){
      return { ...entry, original: preferredName };
    }
    if (stopMeta?.name && stopMeta.name !== entry.original){
      return { ...entry, original: stopMeta.name };
    }
    return entry;
  }
    
  function findDelayEntryForStop(perStation, stopMeta){
    if (!perStation || !perStation.size || !stopMeta) return null;
    const candidates = getStopNameCandidates(stopMeta);
    for (const name of candidates){
      const norm = normalizeStationName(name);
      if (!norm) continue;
      const entry = perStation.get(norm);
      if (entry) return adaptDelayEntryForStop(entry, stopMeta);
    }
    const metaKeys = buildStopMetaKeyCandidates(stopMeta);
    for (const key of metaKeys){
      const entry = perStation.get(key);
      if (entry) return adaptDelayEntryForStop(entry, stopMeta);
    }
    return null;
  }

  function computeReferenceTimesForSeq(seq){
    const ref = new Array(seq.length).fill(null);
    let last = null;
    for (let i=0;i<seq.length;i++){
      const stop = seq[i];
      let value = null;
      if (i === 0){
        value = stop.departure ?? stop.arrival ?? null;
      } else {
        value = stop.arrival ?? stop.departure ?? last;
      }
      if (value == null){
        value = last;
      }
      if (value == null) value = 0;
      ref[i] = value;
      if (value != null) last = value;
    }
    return ref;
  }

  function fillRealtimeDelays(seq, delays, refTimes, options = {}){
    const rawEffectiveLength = options && Number.isFinite(options.effectiveLength)
      ? Math.floor(options.effectiveLength)
      : delays.length;
    const effectiveLength = Math.max(0, Math.min(delays.length, rawEffectiveLength));
    if (effectiveLength <= 0) return;
    const known = [];
    for (let i=0;i<effectiveLength;i++){
      if (typeof delays[i] === 'number' && isFinite(delays[i])){
        delays[i] = Math.round(delays[i]);
        known.push(i);
      }
    }
    if (!known.length){
      for (let i=0;i<effectiveLength;i++) delays[i] = 0;
      return;
    }
    const firstIdx = known[0];
    for (let i=0;i<firstIdx;i++) delays[i] = delays[firstIdx];
    const lastIdx = known[known.length - 1];
    for (let i=lastIdx+1;i<effectiveLength;i++) delays[i] = delays[lastIdx];
    for (let j=0;j<known.length-1;j++){
      const startIdx = known[j];
      const endIdx = known[j+1];
      const delayStart = delays[startIdx];
      const delayEnd = delays[endIdx];
      const timeStart = refTimes[startIdx];
      const timeEnd = refTimes[endIdx];
      if (!isFinite(timeStart) || !isFinite(timeEnd) || timeEnd <= timeStart){
        for (let k=startIdx+1;k<endIdx;k++){
          if (k >= effectiveLength) break;
          delays[k] = delayStart;
        }
        continue;
      }
      for (let k=startIdx+1;k<endIdx;k++){
        if (k >= effectiveLength) break;
        const t = refTimes[k] ?? timeStart;
        const ratio = Math.max(0, Math.min(1, (t - timeStart)/(timeEnd - timeStart)));
        delays[k] = Math.round(delayStart + (delayEnd - delayStart) * ratio);
      }
    }
  }

  function computeRealtimeStopData(tripId, seq, numberKey, options = {}){
    if (!seq || !seq.length){
      realtimeStopDataByTrip.delete(tripId);
      return null;
    }
    const normalizedKey = normalizeTrainNumberKey(numberKey);
    const preferredSources = Array.isArray(options.preferredSources) && options.preferredSources.length
      ? options.preferredSources
      : resolvePreferredRealtimeSourceOrder(null);
    const perSourceMaps = new Map();
    if (normalizedKey != null){
      const matches = getRealtimePerStationMaps(String(normalizedKey), preferredSources);
      for (const match of matches){
        if (!match) continue;
        const normalizedSource = normalizeRealtimeSourceKey(match.sourceKey);
        if (!normalizedSource || perSourceMaps.has(normalizedSource)) continue;
        if (!(match.perStation instanceof Map) || !match.perStation.size) continue;
        perSourceMaps.set(normalizedSource, match.perStation);
      }
    }
    let combinedFallback = null;
    if (normalizedKey != null){
      const candidate = trainDelaysByNumber.get(String(normalizedKey));
      if (candidate instanceof Map && candidate.size){
        combinedFallback = candidate;
      }
    }
    const startPlanned = seq[0]?.departure ?? seq[0]?.arrival ?? null;
    const lastStop = seq[seq.length - 1] || null;
    const endPlanned = lastStop?.arrival ?? lastStop?.departure ?? null;
    const stops = seq.map(st=>({
      stop_id: st.stop_id,
      arrivalPlanned: st.arrival ?? null,
      departurePlanned: st.departure ?? null,
      arrivalRealtime: st.arrival ?? null,
      departureRealtime: st.departure ?? null,
      delaySec: 0,
      delayMinutes: 0,
      delaySource: null,
      cancelled: false
    }));

    if (!perSourceMaps.size && !combinedFallback){
      const data = {
        stops,
        startPlanned,
        endPlanned,
        startRealtime: startPlanned,
        endRealtime: endPlanned,
        hasRealtime: false
      };
      realtimeStopDataByTrip.set(tripId, data);
      return data;
    }

    const delays = new Array(seq.length).fill(null);
    const refTimes = computeReferenceTimesForSeq(seq);
    let cancellationStartIdx = null;
    let cancellationSource = null;
    const cancelledIndices = [];

    for (let i=0;i<seq.length;i++){
      const stopMeta = stopsById.get(seq[i].stop_id);
      const stopOrder = resolveStopRealtimeSourceOrder(stopMeta, preferredSources);
      let entry = null;
      if (Array.isArray(stopOrder) && stopOrder.length){
        for (const rawSource of stopOrder){
          const normalizedSource = normalizeRealtimeSourceKey(rawSource);
          if (!normalizedSource) continue;
          const sourceMap = perSourceMaps.get(normalizedSource);
          if (!sourceMap) continue;
          entry = findDelayEntryForStop(sourceMap, stopMeta);
          if (entry){
            break;
          }
        }
      }
      if (!entry && combinedFallback){
        entry = findDelayEntryForStop(combinedFallback, stopMeta);
      }
      if (!entry) continue;
      if (entry.value == null){
        const sourceLabel = entry.original || stopMeta?.name || null;
        stops[i].cancelled = true;
        stops[i].delaySource = sourceLabel;
        stops[i].name = stopMeta?.name || null;
        cancelledIndices.push(i);
        continue;
      }
      const delaySec = Math.round(Number(entry.value) * 60);
      if (!Number.isFinite(delaySec)) continue;
      delays[i] = delaySec;
      stops[i].delaySource = entry.original || stopMeta?.name || null;
      stops[i].name = stopMeta?.name || null;
    }

    if (cancelledIndices.length){
      const sorted = cancelledIndices.sort((a,b)=>a-b);
      for (const idx of sorted){
        let tailCancelled = true;
        for (let j=idx;j<stops.length;j++){
          if (!stops[j].cancelled){ tailCancelled = false; break; }
        }
        if (tailCancelled){
          cancellationStartIdx = idx;
          cancellationSource = stops[idx]?.delaySource || stops[idx]?.name || null;
          const fallbackLabel = cancellationSource || stops[idx]?.delaySource || stops[idx]?.name || null;
          for (let j=idx;j<stops.length;j++){
            if (!stops[j].delaySource) stops[j].delaySource = fallbackLabel;
          }
          break;
        }
      }
    }

    const activeLength = cancellationStartIdx != null ? Math.max(0, cancellationStartIdx) : delays.length;
    let hasActiveNumeric = false;
    for (let i=0;i<activeLength;i++){
      if (Number.isFinite(delays[i])){ hasActiveNumeric = true; break; }
    }
    if (hasActiveNumeric){
      fillRealtimeDelays(seq, delays, refTimes, { effectiveLength: activeLength });
    } else {
      for (let i=0;i<activeLength;i++) delays[i] = 0;
    }
    if (activeLength < delays.length){
      for (let i=activeLength;i<delays.length;i++) delays[i] = null;
    }

    for (let i=0;i<seq.length;i++){
      const info = stops[i];
      const isCancelled = Boolean(info.cancelled);
      const delayValue = delays[i];
      if (isCancelled){
        info.delaySec = null;
        info.delayMinutes = null;
        info.arrivalRealtime = null;
        info.departureRealtime = null;
        continue;
      }
      const delaySec = Number.isFinite(delayValue) ? delayValue : 0;
      info.delaySec = delaySec;
      info.delayMinutes = delaySec / 60;
      if (info.arrivalPlanned != null){
        info.arrivalRealtime = info.arrivalPlanned + delaySec;
      }
      if (info.departurePlanned != null){
        info.departureRealtime = info.departurePlanned + delaySec;
      }
      if (info.arrivalRealtime == null && info.departureRealtime != null){
        info.arrivalRealtime = info.departureRealtime;
      }
      if (info.departureRealtime == null && info.arrivalRealtime != null){
        info.departureRealtime = info.arrivalRealtime;
      }
    }

    const firstDelay = Number.isFinite(delays[0]) ? delays[0] : 0;
    const lastActiveIdx = activeLength > 0 ? activeLength - 1 : -1;
    let lastDelay = firstDelay;
    if (lastActiveIdx >= 0){
      const candidate = delays[lastActiveIdx];
      if (Number.isFinite(candidate)) lastDelay = candidate;
      else if (!Number.isFinite(lastDelay)) lastDelay = 0;
    }
    const startRealtime = (activeLength > 0 && startPlanned != null && Number.isFinite(delays[0]))
      ? startPlanned + delays[0]
      : null;
    let endRealtime = null;
    if (cancellationStartIdx == null){
      if (endPlanned != null && Number.isFinite(lastDelay)){
        endRealtime = endPlanned + lastDelay;
      } else if (endPlanned != null){
        endRealtime = endPlanned;
      }
    } else if (lastActiveIdx >= 0){
      const refStop = seq[lastActiveIdx] || null;
      const plannedActiveEnd = refStop?.arrival ?? refStop?.departure ?? null;
      if (plannedActiveEnd != null && Number.isFinite(lastDelay)){
        endRealtime = plannedActiveEnd + lastDelay;
      } else if (plannedActiveEnd != null){
        endRealtime = plannedActiveEnd;
      }
    }

    const cancellationInfo = cancellationStartIdx != null ? {
      index: cancellationStartIdx,
      stopId: seq[cancellationStartIdx]?.stop_id || null,
      station: stops[cancellationStartIdx]?.delaySource || stops[cancellationStartIdx]?.name || cancellationSource || null
    } : null;

    const data = {
      stops,
      startPlanned,
      endPlanned,
      startRealtime,
      endRealtime,
      hasRealtime: hasActiveNumeric,
      cancellation: cancellationInfo
    };
    realtimeStopDataByTrip.set(tripId, data);
    return data;
  }
    
  async function fetchWithTimeoutNoHeaders(url, ms = 8000){
    const ctrl = new AbortController();
    const timeout = setTimeout(()=>ctrl.abort(), ms);
    try {
      return await fetch(url, { cache:'no-store', signal: ctrl.signal });
    } finally {
      clearTimeout(timeout);
    }
  }

  async function fetchFromGitHubAPI(){
    const apiUrls = [
      'https://api.github.com/repos/TekMaTe-lux/Assistant-train/contents/Assistant-train/retards_nancymetzlux.json',
      'https://api.github.com/repos/TekMaTe-lux/Assistant-train/contents/retards_nancymetzlux.json'
    ];
    for (const apiUrl of apiUrls){
      try {
        const res = await fetch(apiUrl, {
          cache:'no-store',
          headers:{ 'Accept':'application/vnd.github+json' }
        });
        if (!res.ok) continue;
        const meta = await res.json();
        if (meta && meta.content){
          const text = atob(String(meta.content).replace(/\n/g,''));
          return JSON.parse(text);
        }
      } catch(_){}
    }
    throw new Error('GitHub API indisponible');
  }

  async function loadGtfsRetards({ forceFresh = false } = {}){
    if (pendingGtfsRtPromise) return pendingGtfsRtPromise;
    pendingGtfsRtPromise = (async()=>{
      const withBuster = (u)=> u + (u.includes('?') ? '&' : '?') + 't=' + (forceFresh ? Date.now() : 'soft');
      let lastErr = null;

      for (const candidate of GTFS_RT_CANDIDATES){
        const url = withBuster(candidate);
        try {
          console.log('[GTFS-RT] tentative:', url);
          const res = await fetchWithTimeoutNoHeaders(url, 8000);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const ct = (res.headers.get('content-type') || '').toLowerCase();
          let data;
          if (ct.includes('application/json')){
            data = await res.json();
          } else {
            data = JSON.parse(await res.text());
          }
          registerGtfsRetards(data, candidate);
          console.log('[GTFS-RT] ‚úÖ via', candidate);
          return;
        } catch(e){
          console.warn('[GTFS-RT] √©chec sur', candidate, e);
          lastErr = e;
        }
      }

      try {
        const data = await fetchFromGitHubAPI();
        registerGtfsRetards(data, 'GitHub API');
        console.log('[GTFS-RT] ‚úÖ via GitHub API');
        return;
      } catch(e){
        lastErr = e;
      }

      console.error('[GTFS-RT] ‚ùå impossible de charger les retards temps r√©el', lastErr);
      setRealtimeSourceError('gtfs', trainDelayLastUpdated ? 'rafra√Æchissement en √©chec' : 'indisponibles');
      throw lastErr || new Error('Chargement GTFS-RT impossible');
    })();

    try {
      await pendingGtfsRtPromise;
    } finally {
      pendingGtfsRtPromise = null;
    }
  }
    
const WEEKDAY_FIELDS = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];

  function todayYMD(){
    const d=new Date();
    const y=d.getFullYear();
    const m=String(d.getMonth()+1).padStart(2,'0');
    const day=String(d.getDate()).padStart(2,'0');
    return { ymd:`${y}${m}${day}`, weekday:WEEKDAY_FIELDS[d.getDay()] };
  }

  function computeActiveServiceSet(calendarRows, calendarDateRows){
    const hasCalendar = Array.isArray(calendarRows) && calendarRows.length;
    const hasDates = Array.isArray(calendarDateRows) && calendarDateRows.length;
    if (!hasCalendar && !hasDates) return null;

    const { ymd, weekday } = todayYMD();
    const active = new Set();

    if (hasCalendar){
      for (const row of calendarRows){
        if (!row) continue;
        const svc = row.service_id;
        if (!svc) continue;
        const start=row.start_date, end=row.end_date;
        if (start && start > ymd) continue;
        if (end && end < ymd) continue;
        const runs = row[weekday];
        if (runs === '1' || runs === 1) active.add(svc);
      }
    }

    if (hasDates){
      for (const row of calendarDateRows){
        if (!row || row.date !== ymd) continue;
        const svc = row.service_id;
        if (!svc) continue;
        const type = String(row.exception_type);
        if (type === '1'){ active.add(svc); }
        else if (type === '2'){ active.delete(svc); }
      }
    }

    return active;
  }
    
function sanitizeCflStationName(name){
    if (!name) return '';
    const trimmed = String(name).trim();
    if (!trimmed) return '';
    const cleaned = trimmed.replace(/,\s*Gare(?:[^,]*)?$/i, '').trim();
    return cleaned || trimmed;
  }

  function isCflStationCandidate(name){
    if (!name) return false;
    const lower = String(name).toLowerCase();
    if (lower.includes('routi√®re') || lower.includes('routiere')) return false;
    if (lower.includes('rocade')) return false;
    if (lower.includes('(tram')) return false;
    if (lower.includes(' tram')) return false;
    if (lower.includes('rue de la gare')) return false;
    if (lower.includes('op der gare')) return false;
    if (lower.includes('bus')) return false;
    if (name === 'Luxembourg, Gare Centrale') return true;
    if (name === 'Howald, Gare') return true;
    return /,\s*Gare\b/i.test(name);
  }
    
  // ---------- Maths g√©o (approx) ----------
  const R = 6371000;
  function toXY(lat, lon, lat0){ const x=(lon*Math.PI/180)*Math.cos(lat0*Math.PI/180), y=(lat*Math.PI/180); return {x,y}; }
  function distLL(a,b){ const lat0=(a.lat+b.lat)/2; const A=toXY(a.lat,a.lon,lat0), B=toXY(b.lat,b.lon,lat0); const dx=B.x-A.x, dy=B.y-A.y; return Math.sqrt(dx*dx+dy*dy)*R; }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // ---------- Temps ----------
  function gtfsTimeToSec(t){ if(!t) return null; const [H,M,S]=t.split(':').map(Number); return H*3600+M*60+(S||0); }
  function nowSecLocal(){ const d=new Date(); return d.getHours()*3600 + d.getMinutes()*60 + d.getSeconds(); }
  function fmtMinSec(s){ const m=Math.floor(s/60), r=s%60; return `${m}m${String(r).padStart(2,'0')}s`; }
  function fmtHHMM(sec){
    if (sec==null || !isFinite(sec)) return '‚Äî';
    const totalMinutes = Math.floor(sec/60);
    const totalHours = Math.floor(totalMinutes/60);
    const minutes = totalMinutes % 60;
    const hoursInDay = ((totalHours % 24) + 24) % 24;
    const dayOffset = Math.floor(totalHours / 24);
    const base = `${String(hoursInDay).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
    if (dayOffset > 0) return `${base} (+${dayOffset}j)`;
    return base;
  }

  function fmtRelative(sec){
    if (sec==null || !isFinite(sec)) return '';
    if (Math.abs(sec) < 30) return 'maintenant';
    const minutes = Math.round(Math.abs(sec) / 60);
    if (minutes <= 1) return sec >= 0 ? 'dans ~1 min' : 'il y a ~1 min';
    return sec >= 0 ? `dans ~${minutes} min` : `il y a ~${minutes} min`;
  }

  function formatDelayDiff(sec){
    if (sec==null || !isFinite(sec)) return '';
    const minutes = Math.round(sec / 60);
    if (!minutes) return '';
    const sign = minutes > 0 ? '+' : '-';
    return `${sign}${Math.abs(minutes)} min`;
  }

  function classifyDelayDiff(sec){
    if (sec==null || !isFinite(sec)) return 'ontime';
    if (Math.abs(sec) < 30) return 'ontime';
    return sec > 0 ? 'delay' : 'advance';
  }

  function renderStationEventTime(label, plannedSec, realtimeSec){
    const plannedText = plannedSec!=null ? fmtHHMM(plannedSec) : null;
    const realtimeText = realtimeSec!=null ? fmtHHMM(realtimeSec) : null;
    if (!plannedText && !realtimeText) return '';
    const diffSec = (plannedSec!=null && realtimeSec!=null) ? (realtimeSec - plannedSec) : null;
    const diffLabel = formatDelayDiff(diffSec);
    const mode = classifyDelayDiff(diffSec);
    const rtClass = mode === 'delay' ? 'station-time-rt--delay' : mode === 'advance' ? 'station-time-rt--advance' : 'station-time-rt--ontime';
    const plannedHtml = plannedText ? `<span class="station-time-plan">${escapeHTML(plannedText)}</span>` : '';
    let realtimeHtml = '';
    if (realtimeText && (diffLabel || !plannedText || realtimeText !== plannedText)){
      realtimeHtml = ` <span class="station-time-rt ${rtClass}">${escapeHTML(realtimeText)}${diffLabel ? ` (${escapeHTML(diffLabel)})` : ''}</span>`;
    }
    if (!plannedHtml && !realtimeHtml && realtimeText){
      realtimeHtml = ` <span class="station-time-rt station-time-rt--ontime">${escapeHTML(realtimeText)}</span>`;
    }
    const body = (plannedHtml || realtimeHtml) ? `${plannedHtml}${realtimeHtml}` : '‚Äî';
    return `<div>${escapeHTML(label)} : ${body || '‚Äî'}</div>`;
  }

      // Date locale (navigateur) au format YYYY-MM-DD
  function formatLuxDateISO(d){
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  function numericMetaPriority(meta){
    if (!meta) return 3;
    const type = Number(meta.location_type ?? meta.locationType ?? 0) || 0;
    if (type === 1) return 0;
    if (type === 0) return 1;
    return 2;
  }

  function indexStopMetaForNumericLookup(meta){
    if (!meta || !meta.stop_id) return;
    const digits = String(meta.stop_id).match(/\d{4,}/g);
    if (!digits || !digits.length) return;
    for (const d of digits){
      const existing = stopMetaByNumericCode.get(d);
      if (!existing || numericMetaPriority(meta) < numericMetaPriority(existing)){
        stopMetaByNumericCode.set(d, meta);
      }
    }
  }

  function bestNameForStopMeta(meta){
    if (!meta) return null;
    if (meta.location_type === 0 && meta.parent_station && stopsById.has(meta.parent_station)){
      const parent = stopsById.get(meta.parent_station);
      if (parent?.name) return parent.name;
    }
    return meta.name || null;
  }

  function resolveRealtimeStationReference(rawName){
    const raw = rawName == null ? '' : String(rawName);
    if (!raw) return { label:'', stopId:null };
    const digits = raw.match(/\d{4,}/g) || [];
    for (const d of digits){
      const meta = stopMetaByNumericCode.get(d);
      if (!meta) continue;
      const label = bestNameForStopMeta(meta) || meta.stop_name || meta.name || raw;
      return { label, stopId: meta.stop_id };
    }
    const stripped = raw.replace(/^Stop(?:Point|Area)[\s:_-]*/i, '').trim();
    if (stripped && stripped !== raw){
      return { label: stripped, stopId:null };
    }
    return { label: raw, stopId:null };
  }  
    
  // ---------- √âtat donn√©es ----------
  const stopsById = new Map();              // stop_id -> {stop_id,name,lat,lon}
  const stopMetaByNumericCode = new Map();  // '87192039' -> stop meta (StopArea prioritaire)
  const stopTimesByTrip = new Map();        // trip_id -> [ {stop_id, arr, dep, seq} ] tri√©
  const tripsById = new Map();              // (optionnel) trip_id -> {route_id, headsign, service_id}
  const routesById = new Map();             // (optionnel) route_id -> {route_short_name, route_long_name}
  let activeServiceIds = null;              // Set<string> services actifs aujourd'hui (calendar/calendar_dates)

  // ---------- Leaflet ----------
  const map = L.map('map').setView([49.2, 6.15], 9);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'¬© OpenStreetMap' }).addTo(map);
  const overlay = { rfn:null, cfl:null, axisStationsMajor:null, axisStationsRegular:null, trains:null };
  const layerVisibility = {
    stationsMajor: true,
    stationsRegular: true,
    trains: true
  };
  const trainFilters = {
    showTer: true,
    showTgv: true,
    showCfl: true,
    showDelays: true
  };
  const trainMarkers = new Map();
  const trainCowById = new Map();
  const trainDataById = new Map();
    // ---------- Remont√©e des trains visibles vers le VPS (carte/seen-tails) ----------

  // Endpoint FastAPI sur ton VPS
  const CARTE_SEEN_TAILS_ENDPOINT = 'https://vps.labetaillere.fr/carte/seen-tails';

  // On limite les envois toutes les 5 minutes
  const CARTE_SEEN_INTERVAL_MS = 5 * 60 * 1000;
  let lastCarteSeenPost = 0;

  /**
   * Construit le tail SNCF pour un train affich√© sur la carte.
   * On ne garde que les trains SNCF / TGV (pas les CFL purs).
   */
  function buildSncfTailForTrain(train) {
    if (!train) return null;

    // Cat√©gorie calcul√©e par computeTrainBranding: 'sncf', 'cfl', 'tgv-roi'
    const category = train.branding?.category || 'sncf';
    if (category !== 'sncf' && category !== 'tgv-roi') {
      // On ignore les trains purement CFL pour ce m√©canisme
      return null;
    }

    // On essaie d‚Äôextraire un num√©ro exploitable
    const rawNumber =
      train.branding?.digits ||
      train.branding?.rawDigits ||
      train.number ||
      train.tripNumber ||
      train.numberKey ||
      null;

    const num = extractTrainNumberCandidate(rawNumber);
    if (!num) return null;

    // Date du jour (navigateur) au format YYYY-MM-DD
    const todayStr = formatLuxDateISO(new Date());

    // Tail complet pour l‚ÄôAPI SNCF
    // Exemple: vehicle_journey:SNCF:2025-11-13:88522:1187:Train
    return `vehicle_journey:SNCF:${todayStr}:${num}:1187:Train`;
  }

  /**
   * √Ä partir d‚Äôune liste de trains, renvoie la liste de tails SNCF uniques.
   */
  function computeVisibleTrainTails(trains) {
    if (!Array.isArray(trains) || !trains.length) return [];
    const set = new Set();
    for (const train of trains) {
      const tail = buildSncfTailForTrain(train);
      if (tail) set.add(tail);
    }
    return Array.from(set);
  }

  /**
   * Retourne une liste des trains ‚Äúvisibles‚Äù pour la carte,
   * filtr√©s pour ne garder que SNCF / TGV c√¥t√© suivi.
   */
  function getVisibleTrainsForCarte() {
    const list = [];
    for (const train of trainDataById.values()) {
      const category = train.branding?.category || 'sncf';
      if (category === 'sncf' || category === 'tgv-roi') {
        list.push(train);
      }
    }
    return list;
  }

  /**
   * Envoie au VPS la liste de tails des trains actuellement visibles sur la carte.
   */
  async function sendVisibleTrainTails(trains) {
    const tails = computeVisibleTrainTails(trains);
    if (!tails.length) return;

    try {
      await fetch(CARTE_SEEN_TAILS_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tails })
      });
      // console.log('[CARTE SNCF] Tails envoy√©s au VPS:', tails);
    } catch (e) {
      console.warn('[CARTE SNCF] Impossible d‚Äôenvoyer les tails visibles', e);
    }
  }

  const COW_EMOJIS = ['üêÑ','üêÆ','üêÉ','üêÇ','üêÑ'];
  const LUX_ANIMAL_EMOJIS = ['üêñ','üê∑','üêΩ','üêì','üêî'];
  const TGV_ROI_EMOJI = 'üëë';  
  const stopChildrenByParent = new Map();
  const axisStationByStopId = new Map();
  const realtimeStopDataByTrip = new Map();
  const tripMergeSignatureCache = new Map();
  const staticRelatedNumbersByTrip = new Map();

  const AXIS_STATIONS = [
    { id:'nancy', label:'Nancy', stopArea:'StopArea:OCE87141002', lat:48.689857, lon:6.174579, type:'major' },
    { id:'champigneulles', label:'Champigneulles', stopArea:'StopArea:OCE87141085', lat:48.735025, lon:6.168952, type:'regular' },
    { id:'frouard', label:'Frouard', stopArea:'StopArea:OCE87141077', lat:48.755428, lon:6.143927, type:'regular' },
    { id:'pompey', label:'Pompey', stopArea:'StopArea:OCE87141788', lat:48.77304, lon:6.13061, type:'regular' },
    { id:'marbache', label:'Marbache', stopArea:'StopArea:OCE87141796', lat:48.801156, lon:6.108779, type:'regular' },
    { id:'belleville', label:'Belleville', stopArea:'StopArea:OCE87141804', lat:48.819245, lon:6.101779, type:'regular' },
    { id:'dieulouard', label:'Dieulouard', stopArea:'StopArea:OCE87141812', lat:48.843826, lon:6.071505, type:'regular' },
    { id:'pont-a-mousson', label:'Pont-√†-Mousson', stopArea:'StopArea:OCE87141820', lat:48.900348, lon:6.051021, type:'regular' },
    { id:'vandieres', label:'Vandi√®res', stopArea:'StopArea:OCE87192476', lat:48.951493, lon:6.039047, type:'regular' },
    { id:'pagny-moselle', label:'Pagny-sur-Moselle', stopArea:'StopArea:OCE87192468', lat:48.9852, lon:6.025035, type:'regular' },
    { id:'noveant', label:'Nov√©ant-sur-Moselle', stopArea:'StopArea:OCE87192427', lat:49.028717, lon:6.052051, type:'regular' },
    { id:'ancy-sur-moselle', label:'Ancy-sur-Moselle', stopArea:'StopArea:OCE87192419', lat:49.057714, lon:6.062342, type:'regular' },
    { id:'ars-sur-moselle', label:'Ars-sur-Moselle', stopArea:'StopArea:OCE87192401', lat:49.074475, lon:6.077646, type:'regular' },
    { id:'metz', label:'Metz', stopArea:'StopArea:OCE87192039', lat:49.109466, lon:6.177052, type:'major', extraStopNames:['Metz-Ville, Gare'] },
    { id:'metz-nord', label:'Metz Nord', stopArea:'StopArea:OCE87192070', lat:49.136865, lon:6.167538, type:'regular' },
    { id:'woippy', label:'Woippy', stopArea:'StopArea:OCE87192088', lat:49.148797, lon:6.155621, type:'regular' },
    { id:'maizieres', label:'Maizi√®res-l√®s-Metz', stopArea:'StopArea:OCE87191106', lat:49.215536, lon:6.158727, type:'regular' },
    { id:'walygator-parc', label:'Walygator parc', stopArea:'StopArea:OCE87191098', lat:49.22492, lon:6.15946, type:'regular' },
    { id:'hagondange', label:'Hagondange', stopArea:'StopArea:OCE87191114', lat:49.25356, lon:6.16448, type:'regular' },
    { id:'uckange', label:'Uckange', stopArea:'StopArea:OCE87191130', lat:49.303459, lon:6.1566, type:'regular' },
    { id:'thionville', label:'Thionville', stopArea:'StopArea:OCE87191007', lat:49.353965, lon:6.168582, type:'major', extraStopNames:['Thionville, Gare'] },
    { id:'hettange-grande', label:'Hettange-Grande', stopArea:'StopArea:OCE87191163', lat:49.407685, lon:6.156759, type:'regular', extraStopNames:['Hettange-Grande, Gare SNCF'] },
    { id:'bettembourg', label:'Bettembourg', stopArea:'StopArea:OCE82006030', stopIds:['CFL:000220102018'], lat:49.516515, lon:6.101676, type:'major', extraStopNames:['Bettembourg, Gare'] },
    { id:'howald', label:'Howald', stopArea:'StopArea:OCE82002501', stopIds:['CFL:000200304014'], lat:49.58032, lon:6.13232, type:'regular', extraStopNames:['Howald, Gare'] },
    { id:'luxembourg', label:'Luxembourg', stopArea:'StopArea:OCE82001000', stopIds:['CFL:000200405060'], lat:49.599969, lon:6.13424, type:'major', extraStopNames:['Luxembourg, Gare Centrale'] },
    { id:'pfaffenthal-kirchberg', label:'Pfaffenthal-Kirchberg', stopIds:['CFL:000200417051'], lat:49.618936, lon:6.132919, type:'regular', extraStopNames:['Pfaffenthal-Kirchberg, Gare'] },
    { id:'dommeldange', label:'Dommeldange', stopIds:['CFL:000200409015'], lat:49.633834, lon:6.136892, type:'regular', extraStopNames:['Dommeldange, Gare'] },
    { id:'walferdange', label:'Walferdange', stopIds:['CFL:000201004001'], lat:49.66203, lon:6.136207, type:'regular', extraStopNames:['Walferdange, Gare'] },
    { id:'heisdorf', label:'Heisdorf', stopIds:['CFL:000200802003'], lat:49.6751, lon:6.139417, type:'regular', extraStopNames:['Heisdorf, Gare'] },
    { id:'lorentzweiler', label:'Lorentzweiler', stopIds:['CFL:000160807006'], lat:49.698461, lon:6.140417, type:'regular', extraStopNames:['Lorentzweiler, Gare'] },
    { id:'lintgen', label:'Lintgen', stopIds:['CFL:000160702002'], lat:49.720684, lon:6.123084, type:'regular', extraStopNames:['Lintgen, Gare'] },
    { id:'mersch', label:'Mersch', stopIds:['CFL:000160904011'], lat:49.751844, lon:6.110298, type:'regular', extraStopNames:['Mersch, Gare'] },
    { id:'cruchten', label:'Cruchten', stopIds:['CFL:000161001008'], lat:49.796287, lon:6.120104, type:'regular', extraStopNames:['Cruchten, Gare'] },
    { id:'colmar-berg', label:'Colmar-Berg', stopIds:['CFL:000141302004'], lat:49.815019, lon:6.101071, type:'regular', extraStopNames:['Colmar-Berg, Gare'] },
    { id:'schieren', label:'Schieren', stopIds:['CFL:000141301003'], lat:49.829798, lon:6.095222, type:'regular', extraStopNames:['Schieren, Gare'] },
    { id:'ettelbruck', label:'Ettelbruck', stopIds:['CFL:000140701022'], lat:49.847968, lon:6.107725, type:'major', extraStopNames:['Ettelbruck, Gare'] },
    { id:'michelau', label:'Michelau', stopIds:['CFL:000140307001'], lat:49.896651, lon:6.092099, type:'regular', extraStopNames:['Michelau, Gare'] },
    { id:'goebelsmuhle', label:'Goebelsm√ºhle', stopIds:['CFL:000140304002'], lat:49.921142, lon:6.053422, type:'regular', extraStopNames:['Goebelsm√ºhle, Gare'] },
    { id:'kautenbach', label:'Kautenbach', stopIds:['CFL:000120603003'], lat:49.948625, lon:6.02209, type:'regular', extraStopNames:['Kautenbach, Gare'] },
    { id:'wiltz', label:'Wiltz', stopIds:['CFL:000120903020'], lat:49.966369, lon:5.927075, type:'regular', extraStopNames:['Wiltz, Gare'] },
    { id:'clervaux', label:'Clervaux', stopIds:['CFL:000110101016'], lat:50.061583, lon:6.024627, type:'regular', extraStopNames:['Clervaux, Gare'] },
    { id:'drauffelt', label:'Drauffelt', stopIds:['CFL:000110109004'], lat:50.016901, lon:6.007188, type:'regular', extraStopNames:['Drauffelt, Gare'] },
    { id:'troisvierges', label:'Troisvierges', stopIds:['CFL:000110606008'], lat:50.119334, lon:5.991007, type:'regular', extraStopNames:['Troisvierges, Gare'] },
    { id:'cents-hamm', label:'Cents-Hamm', stopIds:['CFL:000200406025'], lat:49.615019, lon:6.165978, type:'regular', extraStopNames:['Cents-Hamm, Gare'] },
    { id:'sandweiler-contern', label:'Sandweiler-Contern', stopIds:['CFL:000200601016'], lat:49.599093, lon:6.211775, type:'regular', extraStopNames:['Sandweiler-Contern, Gare'] },
    { id:'oetrange', label:'Oetrange', stopIds:['CFL:000200204007'], lat:49.60259, lon:6.258335, type:'regular', extraStopNames:['Oetrange, Gare'] },
    { id:'munsbach', label:'Munsbach', stopIds:['CFL:000200701001'], lat:49.630556, lon:6.268481, type:'regular', extraStopNames:['Munsbach, Gare'] },
    { id:'roodt', label:'Roodt-sur-Syre', stopIds:['CFL:000180106009'], lat:49.66654, lon:6.302918, type:'regular', extraStopNames:['Roodt-sur-Syre, Gare'] },
    { id:'wecker', label:'Wecker', stopIds:['CFL:000180210005'], lat:49.69989, lon:6.386509, type:'regular', extraStopNames:['Wecker, Gare'] },
    { id:'manternach', label:'Manternach', stopIds:['CFL:000180603002'], lat:49.706507, lon:6.42326, type:'regular', extraStopNames:['Manternach, Gare'] },
    { id:'mertert', label:'Mertert', stopIds:['CFL:000180701004'], lat:49.703198, lon:6.478889, type:'regular', extraStopNames:['Mertert, Gare'] },
    { id:'wasserbillig', label:'Wasserbillig', stopIds:['CFL:000180703009'], lat:49.712952, lon:6.499305, type:'regular', extraStopNames:['Wasserbillig, Gare'] },
    { id:'berchem', label:'Berchem', stopIds:['CFL:000221101001'], lat:49.542667, lon:6.133752, type:'regular', extraStopNames:['Berchem, Gare'] },
    { id:'noertzange', label:'Noertzange', stopIds:['CFL:000220105006'], lat:49.508006, lon:6.050881, type:'regular', extraStopNames:['Noertzange, Gare'] },
    { id:'schifflange', label:'Schifflange', stopIds:['CFL:000221401002'], lat:49.506302, lon:6.009786, type:'regular', extraStopNames:['Schifflange, Gare'] },
    { id:'esch', label:'Esch-sur-Alzette', stopIds:['CFL:000220402046'], lat:49.493911, lon:5.985087, type:'major', extraStopNames:['Esch-sur-Alzette, Gare'] },
    { id:'belval-universite', label:'Belval-Universit√©', stopIds:['CFL:000220401002'], lat:49.49955, lon:5.946283, type:'regular', extraStopNames:['Belval-Universit√©, Gare'] },
    { id:'belval-lycee', label:'Belval-Lyc√©e', stopIds:['CFL:000221301023'], lat:49.501502, lon:5.934709, type:'regular', extraStopNames:['Belval-Lyc√©e, Gare'] },
    { id:'belval-redange', label:'Belval-R√©dange', stopIds:['CFL:000221301002'], lat:49.503162, lon:5.923706, type:'regular', extraStopNames:['Belval-R√©dange, Gare'] },
    { id:'belvaux-soleuvre', label:'Belvaux-Soleuvre', stopIds:['CFL:000221301010'], lat:49.515145, lon:5.926076, type:'regular', extraStopNames:['Belvaux-Soleuvre, Gare'] },
    { id:'differdange', label:'Differdange', stopIds:['CFL:000220201021'], lat:49.522547, lon:5.891656, type:'regular', extraStopNames:['Differdange, Gare'] },
    { id:'oberkorn', label:'Oberkorn', stopIds:['CFL:000220201032'], lat:49.510715, lon:5.890928, type:'regular', extraStopNames:['Oberkorn, Gare'] },
    { id:'niederkorn', label:'Niederkorn', stopIds:['CFL:000220203006'], lat:49.536807, lon:5.893985, type:'regular', extraStopNames:['Niederkorn, Gare'] },
    { id:'petange', label:'P√©tange', stopIds:['CFL:000220902007'], lat:49.554376, lon:5.879221, type:'regular', extraStopNames:['P√©tange, Gare'] },
    { id:'rodange', label:'Rodange', stopIds:['CFL:000220903011'], lat:49.550959, lon:5.843499, type:'regular', extraStopNames:['Rodange, Gare'] },
    { id:'dudelange-usines', label:'Dudelange-Usines', stopIds:['CFL:000220301041'], lat:49.472609, lon:6.079433, type:'regular', extraStopNames:['Dudelange (Usines), Gare'] },
    { id:'dudelange-ville', label:'Dudelange-Ville', stopIds:['CFL:000220301082'], lat:49.483383, lon:6.083183, type:'regular', extraStopNames:['Dudelange (Ville), Gare'] },
    { id:'dudelange-centre', label:'Dudelange-Centre', stopIds:['CFL:000220301015'], lat:49.478696, lon:6.08215, type:'regular', extraStopNames:['Dudelange (Centre), Gare'] },
    { id:'dudelange-burange', label:'Dudelange-Burange', stopIds:['CFL:000220301022'], lat:49.482676, lon:6.083205, type:'regular', extraStopNames:['Dudelange, Gare'] },
    { id:'lamadelaine', label:'Lamadelaine', stopIds:['CFL:000220901011'], lat:49.553384, lon:5.860878, type:'regular', extraStopNames:['Lamadelaine, Gare'] },
    { id:'bascharage-sanem', label:'Bascharage-Sanem', stopIds:['CFL:000190101027'], lat:49.558417, lon:5.924589, type:'regular', extraStopNames:['Bascharage/Sanem, Gare'] },
    { id:'kleinbettingen', label:'Kleinbettingen', stopIds:['CFL:000191103004'], lat:49.643957, lon:5.917135, type:'regular', extraStopNames:['Kleinbettingen, Gare'] },
    { id:'capellen', label:'Capellen', stopIds:['CFL:000190901001'], lat:49.638498, lon:5.982381, type:'regular', extraStopNames:['Capellen, Gare'] },
    { id:'mamer', label:'Mamer', stopIds:['CFL:000190903008'], lat:49.625768, lon:6.020215, type:'regular', extraStopNames:['Mamer, Gare'] },
    { id:'bertrange-strassen', label:'Bertrange-Strassen', stopIds:['CFL:000200101024'], lat:49.613095, lon:6.059369, type:'regular', extraStopNames:['Bertrange, Gare'] }
  ];
  const axisStationsById = new Map(AXIS_STATIONS.map(st=>[st.id, st]));
  const SILLON_BOUNDS = L.latLngBounds(AXIS_STATIONS.map(st=>[st.lat, st.lon]));
  if (SILLON_BOUNDS.isValid()){
    map.fitBounds(SILLON_BOUNDS.pad(0.18), { maxZoom: 11 });
  }

    let activeTripId = null;
  let activeStationId = null;

  const tripPanelEl = document.getElementById('trip-panel');
  const tripPanelCloseBtn = document.getElementById('trip-panel-close');
  const tripPanelIconEl = document.getElementById('trip-panel-icon');
  const tripPanelTrainEl = document.getElementById('trip-panel-train');
  const tripPanelSummaryEl = document.getElementById('trip-panel-summary');
  const tripProgressWrapEl = document.getElementById('trip-progress');
  const tripProgressFillEl = document.getElementById('trip-progress-fill');
  const tripProgressTextEl = document.getElementById('trip-progress-text');
  const tripStopsTitleEl = document.getElementById('trip-stops-title');
  const tripStopsEl = document.getElementById('trip-stops');
  const toggleMajorEl = document.getElementById('toggle-major');
  const toggleRegularEl = document.getElementById('toggle-regular');
  const toggleTrainsEl = document.getElementById('toggle-trains');
  const toggleTerEl = document.getElementById('toggle-ter');
  const toggleTgvEl = document.getElementById('toggle-tgv');
  const toggleCflEl = document.getElementById('toggle-cfl');
  const toggleDelaysEl = document.getElementById('toggle-delays');
  const infoButtonEl = document.getElementById('info-button');
  const infoPanelEl = document.getElementById('info-panel');
  const controlsToggleEl = document.getElementById('controls-toggle');
  const controlsPanelEl = document.getElementById('controls-panel');

  function setControlsOpen(open){
    document.body.classList.toggle('controls-open', !!open);
    if (controlsToggleEl){
      controlsToggleEl.setAttribute('aria-expanded', open ? 'true' : 'false');
    }
  }
  setControlsOpen(false);
  if (controlsToggleEl){
    controlsToggleEl.addEventListener('click', ()=>{
      const next = !document.body.classList.contains('controls-open');
      setControlsOpen(next);
      if (next && controlsPanelEl){
        controlsPanelEl.focus({ preventScroll:true });
      }
    });
  }

  if (toggleMajorEl){
    layerVisibility.stationsMajor = toggleMajorEl.checked;
    toggleMajorEl.addEventListener('change', ()=>{
      layerVisibility.stationsMajor = toggleMajorEl.checked;
      applyLayerVisibility();
    });
  }

  if (toggleRegularEl){
    layerVisibility.stationsRegular = toggleRegularEl.checked;
    toggleRegularEl.addEventListener('change', ()=>{
      layerVisibility.stationsRegular = toggleRegularEl.checked;
      applyLayerVisibility();
    });
  }

  if (toggleTrainsEl){
    layerVisibility.trains = toggleTrainsEl.checked;
    toggleTrainsEl.addEventListener('change', ()=>{
      layerVisibility.trains = toggleTrainsEl.checked;
      applyLayerVisibility();
    });
  }

  function applyTrainFilters(){
    const changed = true;
    if (changed){
      try { tick(); } catch(_){ }
    }
  }

  if (toggleTerEl){
    trainFilters.showTer = toggleTerEl.checked;
    toggleTerEl.addEventListener('change', ()=>{ trainFilters.showTer = toggleTerEl.checked; applyTrainFilters(); });
  }

  if (toggleTgvEl){
    trainFilters.showTgv = toggleTgvEl.checked;
    toggleTgvEl.addEventListener('change', ()=>{ trainFilters.showTgv = toggleTgvEl.checked; applyTrainFilters(); });
  }

  if (toggleCflEl){
    trainFilters.showCfl = toggleCflEl.checked;
    toggleCflEl.addEventListener('change', ()=>{ trainFilters.showCfl = toggleCflEl.checked; applyTrainFilters(); });
  }

  if (toggleDelaysEl){
    trainFilters.showDelays = toggleDelaysEl.checked;
    toggleDelaysEl.addEventListener('change', ()=>{ trainFilters.showDelays = toggleDelaysEl.checked; applyTrainFilters(); });
  }

  function toggleInfoPanel(force){
    const targetState = force != null ? !!force : infoPanelEl.classList.contains('hidden');
    infoPanelEl.classList.toggle('hidden', !targetState);
    if (infoButtonEl){
      infoButtonEl.setAttribute('aria-expanded', targetState ? 'true' : 'false');
    }
  }

  if (infoButtonEl && infoPanelEl){
    infoButtonEl.addEventListener('click', ()=>toggleInfoPanel());
    infoPanelEl.addEventListener('click', (ev)=>{
      if (ev.target === infoPanelEl){
        toggleInfoPanel(false);
      }
    });
    document.addEventListener('keydown', (ev)=>{
      if (ev.key === 'Escape' && !infoPanelEl.classList.contains('hidden')){
        toggleInfoPanel(false);
      }
    });
  }

  renderAxisStations();

  function clearActiveSelection(){
    activeTripId = null;
    activeStationId = null;
  }

  function handleTripPanelClose(ev){
    if (ev){
      ev.preventDefault();
      ev.stopPropagation();
    }
    clearActiveSelection();
    hideTripPanel();
  }

  tripPanelCloseBtn.addEventListener('click', handleTripPanelClose);
  tripPanelCloseBtn.addEventListener('touchstart', handleTripPanelClose, { passive:false });

  map.on('click', ()=>{  
   if (activeTripId || activeStationId){
      clearActiveSelection();
      hideTripPanel();
    }
  });

  function cowForTrain(train){
    const id = train?.id ?? '';
    if (!trainCowById.has(id)){
      const category = train?.branding?.category;
      let glyph;
      if (category === 'tgv-roi') {
        glyph = TGV_ROI_EMOJI;
      } else {
        const pool = category === 'cfl' ? LUX_ANIMAL_EMOJIS : COW_EMOJIS;
        glyph = pool[Math.floor(Math.random()*pool.length)] || 'üêÑ';
      }
      trainCowById.set(id, glyph);
    }
    return trainCowById.get(id) || 'üêÑ';
  }

  function glyphForTrain(train, delayInfoOverride){
    if (!train) return 'üêÑ';
    const info = trainFilters.showDelays ? (delayInfoOverride || train.delayInfo || computeTrainDelayInfo(train)) : null;
    if (trainFilters.showDelays && info?.severity === 'cancelled') return 'üöÜ';
    return cowForTrain(train);
  }

  function iconForTrain(train){
    const delayInfo = trainFilters.showDelays ? (train.delayInfo || computeTrainDelayInfo(train)) : null;
    const glyph = glyphForTrain(train, delayInfo);
    const displayNum = train.number || train.headsign || train.id;
    const num = escapeHTML(displayNum || '‚Äî');
    const safeId = escapeAttr(train.id);
    const ariaLabelText = formatTrainAriaLabel(train, train.id);
    const ariaParts = [`Voir le d√©tail du ${ariaLabelText}`];
    if (trainFilters.showDelays && delayInfo){
      if (delayInfo.minutes == null){
        ariaParts.push('train supprim√©');
      } else {
        ariaParts.push(`retard ${Math.round(delayInfo.minutes)} minute${Math.round(delayInfo.minutes) > 1 ? 's' : ''}`);
      }
    }
    const aria = escapeAttr(ariaParts.join(', '));
    const badge = (trainFilters.showDelays && delayInfo)
      ? `<span class="${delayInfo.badgeClass}"${delayInfo.title ? ` title="${escapeAttr(delayInfo.title)}"` : ''}>${escapeHTML(delayInfo.label)}</span>`
      : '';
    const titleAttr = (trainFilters.showDelays && delayInfo?.title) ? ` title="${escapeAttr(delayInfo.title)}"` : '';
    const classNames = ['cow-marker'];
    if (train.branding?.className) classNames.push(train.branding.className);
    const isCancelled = trainFilters.showDelays && delayInfo?.severity === 'cancelled';
    if (isCancelled) classNames.push('train-cancelled');
    const classAttr = escapeAttr(classNames.join(' '));
    const glyphHtml = `<span class="cow-glyph${isCancelled ? ' cow-glyph--cancelled' : ''}">${escapeHTML(glyph)}</span>`;
    return L.divIcon({
      className:'',
      html:`<button type="button" class="${classAttr}" data-train-id="${safeId}" aria-label="${aria}"${titleAttr}>${glyphHtml}<span class="train-num">${num}</span>${badge}</button>`,
      iconSize:null,
      iconAnchor:[20,20]
    });
  }

  function iconForStation(station){
    const emoji = station.type === 'major' ? 'üè´' : 'üõñ';
    const classes = `station-marker ${station.type === 'major' ? 'station-major' : 'station-regular'}`;
    const safeId = escapeAttr(station.id);
    const aria = escapeAttr(`Ouvrir la fiche de la gare ${station.label}${station.type === 'major' ? ' (principale)' : ''}`);
    return L.divIcon({
      className:'',
      html:`<button type="button" class="${classes}" data-station-id="${safeId}" aria-label="${aria}">${emoji}</button>`,
      iconSize:null,
      iconAnchor:[14,14]
    });
  }
  
const mapContainerEl = map.getContainer();
  function handleTrainActivate(ev){
    const btn = ev.target.closest?.('.cow-marker');
    if (!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    const id = btn.getAttribute('data-train-id');
    if (id) openTripPanel(id);
  }

  function handleStationActivate(ev){
    const btn = ev.target.closest?.('.station-marker');
    if (!btn) return;
    ev.preventDefault();
    ev.stopPropagation();
    const id = btn.getAttribute('data-station-id');
    if (id) openStationPanel(id);
  }
  
  mapContainerEl.addEventListener('pointerdown', handleTrainActivate, { passive:false });
  mapContainerEl.addEventListener('click', handleTrainActivate, { passive:false });
  mapContainerEl.addEventListener('pointerdown', handleStationActivate, { passive:false });
  mapContainerEl.addEventListener('click', handleStationActivate, { passive:false });  
  mapContainerEl.addEventListener('keydown', (ev)=>{
    const btn = ev.target.closest?.('.cow-marker');
    if (btn && (ev.key === 'Enter' || ev.key === ' ')){
      ev.preventDefault();
      ev.stopPropagation();
      const id = btn.getAttribute('data-train-id');
      if (id) openTripPanel(id);
      return;
    }
    const stationBtn = ev.target.closest?.('.station-marker');
    if (!stationBtn) return;
    if (ev.key === 'Enter' || ev.key === ' '){
      ev.preventDefault();
      ev.stopPropagation();
      const id = stationBtn.getAttribute('data-station-id');
      if (id) openStationPanel(id);
    }
  });

  tripStopsEl.addEventListener('click', (ev)=>{
    const btn = ev.target.closest?.('.station-train-link');
    if (!btn) return;
    ev.preventDefault();
    const id = btn.getAttribute('data-train-id');
    if (id) openTripPanel(id);
  });

  tripStopsEl.addEventListener('keydown', (ev)=>{
    const btn = ev.target.closest?.('.station-train-link');
    if (!btn) return;
    if (ev.key === 'Enter' || ev.key === ' '){
      ev.preventDefault();
      const id = btn.getAttribute('data-train-id');
      if (id) openTripPanel(id);
    }
  });
  

  function hideTripPanel(){
    tripPanelEl.classList.add('hidden');
    document.body.classList.remove('trip-panel-open');
    tripPanelEl.classList.remove('cancelled');
    tripPanelIconEl.textContent = 'üêÑ';
    tripPanelTrainEl.textContent = 'S√©lectionnez une b√©taill√®re ou une gare';
    tripPanelSummaryEl.textContent = 'Cliquez sur une ic√¥ne vache ou grange pour afficher le d√©tail.';
    tripProgressWrapEl.classList.add('hidden');
    tripProgressFillEl.style.width = '0%';
    tripProgressTextEl.textContent = '';
    tripStopsTitleEl.classList.add('hidden');
    tripStopsTitleEl.textContent = 'Gares desservies';
    tripStopsEl.innerHTML = '';
    tripStopsEl.classList.remove('station-mode');
  }

  function openTripPanel(trainId){
    activeTripId = trainId;
    activeStationId = null;
    tripPanelEl.classList.remove('hidden');
    document.body.classList.add('trip-panel-open');
    renderPanel();
  }

  function openStationPanel(stationId){
    activeStationId = stationId;
    activeTripId = null;
    tripPanelEl.classList.remove('hidden');
    document.body.classList.add('trip-panel-open');
     renderPanel();
  }

  function renderPanel(){
    if (activeStationId){
      renderStationPanel();
    } else if (activeTripId){
      renderTripPanel();
    } else {
      hideTripPanel();
    }
  }

  function renderTripPanel(){
    if (!activeTripId){ hideTripPanel(); return; }
    const data = trainDataById.get(activeTripId);
    if (!data){
      activeTripId = null;
      if (!activeStationId) hideTripPanel();
      return;
    }

    tripStopsEl.classList.remove('station-mode');
    const delayInfo = data.delayInfo || computeTrainDelayInfo(data);
    if (delayInfo && data.delayInfo !== delayInfo) data.delayInfo = delayInfo;
    
    const seq = stopTimesByTrip.get(activeTripId);
    const realtimeProfile = seq && seq.length ? (realtimeStopDataByTrip.get(activeTripId)
      || computeRealtimeStopData(
        activeTripId,
        seq,
        data.numberKey || extractTrainNumberCandidate(data.number) || extractTrainNumberCandidate(activeTripId),
        realtimeOptionsForTrain(data)
      )) : null;
    const cancellationInfo = realtimeProfile?.cancellation;
    const hasRealtimeStops = Array.isArray(realtimeProfile?.stops);
    const allRealtimeStopsCancelled = hasRealtimeStops && realtimeProfile.stops.length > 0
      ? realtimeProfile.stops.every(st => st?.cancelled)
      : false;
    const isTrainCancelled = cancellationInfo ? cancellationInfo.index === 0 : delayInfo?.severity === 'cancelled';
    const propagateTrainCancellation = isTrainCancelled && (!hasRealtimeStops || allRealtimeStopsCancelled);
    
    tripPanelEl.classList.toggle('cancelled', Boolean(isTrainCancelled));
    tripPanelIconEl.textContent = glyphForTrain(data, delayInfo);

    const labelInfo = trainLabelParts(data, data.id);
    const baseLabel = labelInfo.label || data.headsign || data.id || '';
    const categoryLabel = labelInfo.category === 'cfl' ? 'Prioritaire' : 'B√©taill√®re';
    if (labelInfo.category === 'tgv-roi'){
      tripPanelTrainEl.textContent = baseLabel || 'TGV ROI';
    } else if (data.number && baseLabel){
      tripPanelTrainEl.textContent = `${categoryLabel} ${baseLabel}`;
    } else if (data.headsign){
      tripPanelTrainEl.textContent = data.headsign;
    } else if (baseLabel){
      tripPanelTrainEl.textContent = baseLabel;
    } else {
      tripPanelTrainEl.textContent = data.id || 'S√©lectionnez une b√©taill√®re';
    }

    if (!seq || !seq.length){
      tripPanelSummaryEl.textContent = 'Donn√©es de trajet indisponibles pour ce service.';
      tripProgressWrapEl.classList.add('hidden');
      tripStopsTitleEl.classList.add('hidden');
      tripStopsEl.innerHTML = '';
      return;
    }

    const buildTimePart = (type, plannedSec, realtimeSec)=>{
      if (plannedSec == null && realtimeSec == null) return null;
      const plannedText = plannedSec!=null ? fmtHHMM(plannedSec) : null;
      const realtimeText = realtimeSec!=null ? fmtHHMM(realtimeSec) : null;
      const diffSec = (plannedSec!=null && realtimeSec!=null) ? (realtimeSec - plannedSec) : null;
      const showRealtime = realtimeText != null && (plannedText == null || Math.abs(diffSec || 0) >= 30);
      const fallbackRealtime = plannedText == null && realtimeText != null;
      return {
        type,
        plannedSec: plannedSec ?? null,
        realtimeSec: realtimeSec ?? null,
        plannedText,
        realtimeText,
        diffSec,
        showRealtime: showRealtime || fallbackRealtime
      };
    };
    
    const stops = seq.map((st, idx)=>{
      const stopMeta = stopsById.get(st.stop_id);
      const name = stopMeta?.name || st.stop_id;
      const profileStop = realtimeProfile?.stops?.[idx] || null;
      const arrival = st.arrival ?? null;
      const departure = st.departure ?? null;
      const arrivalRt = profileStop?.arrivalRealtime ?? null;
      const departureRt = profileStop?.departureRealtime ?? null;
      const isFirst = idx === 0;
      const isLast = idx === seq.length - 1;
      const isStopCancelled = Boolean(profileStop?.cancelled);
      const stopCancelled = Boolean(isStopCancelled || propagateTrainCancellation);
      const timeParts = [];
      const pushPart = (type, plannedSec, realtimeSec)=>{
        const part = buildTimePart(type, plannedSec, realtimeSec);
        if (part) timeParts.push(part);
      };
      
      if (isFirst){
        const planned = departure ?? arrival;
        const realtime = departureRt ?? arrivalRt;
        pushPart(departure!=null ? 'dep' : 'arr', planned, realtime);
      } else if (isLast){
        const planned = arrival ?? departure;
        const realtime = arrivalRt ?? departureRt;
        pushPart(arrival!=null ? 'arr' : 'dep', planned, realtime);
      } else {
        pushPart('arr', arrival, arrivalRt);
        if (!(departure === arrival && departureRt === arrivalRt)){
          pushPart('dep', departure, departureRt);
        }
      }

      if (!timeParts.length){
        const fallback = buildTimePart('neutral', arrival ?? departure, arrivalRt ?? departureRt);
        if (fallback){
          timeParts.push(fallback);
        } else {
          timeParts.push({ type:'neutral', plannedText:'‚Äî', realtimeText:null, diffSec:null, showRealtime:false });
        }
      }
      const labelSource = timeParts.find(p=>p.plannedText) || timeParts.find(p=>p.realtimeText);
      const label = labelSource?.plannedText || labelSource?.realtimeText || '‚Äî';

      return {
        name,
        arrival,
        departure,
        arrivalRealtime: arrivalRt,
        departureRealtime: departureRt,
        isFirst,
        isLast,
        cancelled: stopCancelled,
        label,
        timeParts
      };
    });

    const startName = stops[0]?.name || '‚Äî';
    const endName = stops[stops.length - 1]?.name || '‚Äî';
    const plannedStartSec = data.scheduledStartSec ?? realtimeProfile?.startPlanned ?? seq[0]?.departure ?? seq[0]?.arrival ?? null;
    const plannedEndSec = data.scheduledEndSec ?? realtimeProfile?.endPlanned ?? seq[seq.length - 1]?.arrival ?? seq[seq.length - 1]?.departure ?? null;
    const summaryStartTime = plannedStartSec!=null ? fmtHHMM(plannedStartSec) : (stops[0]?.label ?? '‚Äî');
    const summaryEndTime = plannedEndSec!=null ? fmtHHMM(plannedEndSec) : (stops[stops.length - 1]?.label ?? '‚Äî');
    let summaryHtml = `${escapeHTML(startName)} <strong>${escapeHTML(summaryStartTime)}</strong> ‚Üí ${escapeHTML(endName)} <strong>${escapeHTML(summaryEndTime)}</strong>`;
    let renderedDelayInfo = trainFilters.showDelays ? delayInfo : null;
    if (renderedDelayInfo?.severity === 'cancelled' && cancellationInfo && cancellationInfo.index > 0){
      renderedDelayInfo = null;
    }
    if (cancellationInfo && cancellationInfo.index != null && cancellationInfo.index < stops.length){
      if (cancellationInfo.index > 0){
        const stationLabel = cancellationInfo.station || stops[cancellationInfo.index]?.name || 'cet arr√™t';
        summaryHtml += `<div class="trip-panel-delay delay-cancelled">${escapeHTML(`Supprim√© √† partir de ${stationLabel}`)}</div>`;
      }
    }
    if (Array.isArray(data.numberList) && data.numberList.length > 1){
      summaryHtml += `<div class="trip-panel-realtime"><strong>Num√©ros associ√©s :</strong> ${escapeHTML(data.numberList.join(' / '))}</div>`;
    }
    const disruptionText = findSncfDisruptionForTrain(data);
    
    if (trainFilters.showDelays){
      const realtimeStartSec = realtimeProfile?.startRealtime ?? data.startSec ?? plannedStartSec;
      const realtimeEndSec = realtimeProfile?.endRealtime ?? data.endSec ?? plannedEndSec;
      const startDiffText = (plannedStartSec!=null && realtimeStartSec!=null) ? formatDelayDiff(realtimeStartSec - plannedStartSec) : '';
      const endDiffText = (plannedEndSec!=null && realtimeEndSec!=null) ? formatDelayDiff(realtimeEndSec - plannedEndSec) : '';
      if ((startDiffText && realtimeStartSec!=null) || (endDiffText && realtimeEndSec!=null)){
        const startRealtimeText = realtimeStartSec!=null ? fmtHHMM(realtimeStartSec) : '‚Äî';
        const endRealtimeText = realtimeEndSec!=null ? fmtHHMM(realtimeEndSec) : '‚Äî';
        const startDiffHtml = startDiffText ? `<span class="trip-panel-realtime-diff">${escapeHTML(startDiffText)}</span>` : '';
        const endDiffHtml = endDiffText ? `<span class="trip-panel-realtime-diff">${escapeHTML(endDiffText)}</span>` : '';
        summaryHtml += `<div class="trip-panel-realtime">Temps r√©el : <strong>${escapeHTML(startRealtimeText)}</strong>${startDiffHtml} ‚Üí <strong>${escapeHTML(endRealtimeText)}</strong>${endDiffHtml}</div>`;
      }
    }
    if (disruptionText){
      const disruptionClass = cancellationInfo && cancellationInfo.index != null && cancellationInfo.index < stops.length
        ? 'trip-panel-disruption is-cancelled'
        : 'trip-panel-disruption';
      summaryHtml += `<div class="${disruptionClass}"><strong>Cause SNCF :</strong> ${escapeHTML(disruptionText)}</div>`;
    }
    tripPanelSummaryEl.innerHTML = summaryHtml;

    const totalStops = stops.length;
    if (totalStops > 0){
      const plural = totalStops > 1 ? 's' : '';
      const intermediates = Math.max(0, totalStops - 2);
      const interText = intermediates > 0 ? ` ‚Äî ${intermediates} interm√©diaire${intermediates>1?'s':''}` : '';
      tripStopsTitleEl.classList.remove('hidden');
      tripStopsTitleEl.textContent = `Gares desservies (${totalStops} arr√™t${plural})${interText}`;
    } else {
      tripStopsTitleEl.classList.add('hidden');
      tripStopsTitleEl.textContent = 'Gares desservies';
    }

    const segIdx = data.segmentIndex ?? -1;
    const segProg = data.segmentProgress ?? 0;
    const segFraction = Math.max(0, Math.min(1, segProg));
    const nextStopName = (()=>{
      if (segIdx >= 0){
        if (segIdx + 1 < stops.length){
          return stops[segIdx + 1].name;
        }
        if (segIdx >= stops.length - 1){
          return null;
        }
      }
      return data.to || null;
    })();

    if (data.progress!=null && isFinite(data.progress)){
      const pct = Math.max(0, Math.min(1, data.progress));
      tripProgressWrapEl.classList.remove('hidden');
      tripProgressFillEl.style.width = `${(pct*100).toFixed(1)}%`;
      const pctText = Math.round(pct*100);
      const etaText = isFinite(data.etaSec) ? fmtMinSec(data.etaSec) : null;
      let statusText;
      if (nextStopName){
        statusText = `prochain arr√™t : ${nextStopName}`;
        if (etaText) statusText += ` (dans ${etaText})`;
      } else {
        statusText = etaText ? `terminus dans ${etaText}` : 'TERMINUS';
      }
      tripProgressTextEl.textContent = `Progression ${pctText}% ‚Äî ${statusText}`;
    } else {
      tripProgressWrapEl.classList.add('hidden');
      tripProgressFillEl.style.width = '0%';
      tripProgressTextEl.textContent = '';
    }

    const stopsHtml = stops.map((info, idx)=>{
      let status = 'upcoming';
      let connectorProgress = 0;
      const extraClasses = [];
      if (segIdx >= 0){
       if (idx < segIdx){
          status = 'passed';
          connectorProgress = 1;
        } else if (idx === segIdx){
          status = 'current';
         connectorProgress = segFraction;
          if (segFraction > 0.05){
            extraClasses.push('enroute');
          }
        } else if (idx === segIdx + 1){
          status = 'approaching';
        }
      } else if (data.nowSec!=null){
        const ref = info.isFirst
          ? (info.departureRealtime ?? info.arrivalRealtime ?? seq[idx].departure ?? seq[idx].arrival)
          : (info.arrivalRealtime ?? info.departureRealtime ?? seq[idx].arrival ?? seq[idx].departure);
        if (ref!=null){
          status = data.nowSec >= ref ? 'passed' : 'upcoming';
        }
      }

      const noteParts = [];
      if (info.isFirst) noteParts.push('D√©part');
      if (info.isLast) noteParts.push('TERMINUS');
      if (segIdx >= 0){
        if (idx === segIdx) noteParts.push('Arr√™t pr√©c√©dent');
        if (idx === segIdx + 1) noteParts.push('Prochain arr√™t');
      }
      if (info.cancelled) noteParts.push('SUPPRIM√â');
      const note = noteParts.length ? `<div class="stop-note"><strong>${escapeHTML(noteParts.join(' ¬∑ '))}</strong></div>` : '';
      const timesHtml = info.timeParts.map(part=>{
        const cls = part.type === 'arr' ? 'time-arr' : part.type === 'dep' ? 'time-dep' : 'time-neutral';
        const pieces = [];
        if (part.plannedText){
          pieces.push(`<span class="time-entry-plan">${escapeHTML(part.plannedText)}</span>`);
        } else if (!part.showRealtime){
          pieces.push('<span class="time-entry-plan">‚Äî</span>');
        }
        const showRealtime = trainFilters.showDelays && part.showRealtime;
        if (showRealtime){
          const mode = classifyDelayDiff(part.diffSec);
          const rtClass = mode === 'delay' ? 'time-entry-rt--delay' : mode === 'advance' ? 'time-entry-rt--advance' : 'time-entry-rt--ontime';
          const prefix = mode === 'delay' ? 'Retard√©' : mode === 'advance' ? 'Avance' : 'Temps r√©el';
          const diffLabel = formatDelayDiff(part.diffSec);
          const realtimeText = part.realtimeText ?? part.plannedText ?? '‚Äî';
          pieces.push(`<span class="time-entry-rt ${rtClass}">${escapeHTML(prefix)} ${escapeHTML(realtimeText)}${diffLabel ? ` (${escapeHTML(diffLabel)})` : ''}</span>`);
        } else if (!part.plannedText && part.realtimeText){
          pieces.push(`<span class="time-entry-rt time-entry-rt--ontime">${escapeHTML(part.realtimeText)}</span>`);
        }
        if (!pieces.length){
          pieces.push(`<span class="time-entry-plan">${escapeHTML(part.plannedText ?? '‚Äî')}</span>`);
        }
        const entryClasses = ['time-entry', cls];
        if (info.cancelled) entryClasses.push('cancelled');
        return `<div class="${entryClasses.join(' ')}">${pieces.join('')}</div>`
      }).join('');
      const classes = [status, ...extraClasses];
      if (info.cancelled) classes.push('cancelled');
      const className = classes.filter(Boolean).join(' ');
      const styleAttr = connectorProgress > 0 && !info.isLast ? ` style="--connector-progress:${connectorProgress.toFixed(3)}"` : '';
      return `<div class="trip-stop ${className}"${styleAttr}><div class="stop-time">${timesHtml}</div><div class="stop-main"><div class="stop-name">${escapeHTML(info.name)}</div>${note}</div></div>`;
    }).join('');

    tripStopsEl.innerHTML = stopsHtml || '<div class="trip-stop"><div class="stop-main"><div class="stop-name">Aucun arr√™t disponible</div></div></div>';
  }

  function renderStationPanel(){
    if (!activeStationId){ hideTripPanel(); return; }
    const station = axisStationsById.get(activeStationId);
    if (!station){ hideTripPanel(); return; }

    tripPanelEl.classList.remove('cancelled');
    tripStopsEl.classList.add('station-mode');
    const emoji = station.type === 'major' ? 'üè†' : 'üè°';
    tripPanelIconEl.textContent = emoji;
    tripPanelTrainEl.textContent = `Gare de ${station.label}`;

    const classification = station.type === 'major'
      ? 'Gare principale de l‚Äôaxe Nancy ‚Üî Luxembourg'
      : 'Gare interm√©diaire Nancy ‚Üî Luxembourg';
    const summaryParts = [escapeHTML(classification)];
    if (isFinite(station.lat) && isFinite(station.lon)){
      summaryParts.push(`<span class="muted">(${escapeHTML(station.lat.toFixed(3))} ; ${escapeHTML(station.lon.toFixed(3))})</span>`);
    }
    tripPanelSummaryEl.innerHTML = summaryParts.join('<br>');

    tripProgressWrapEl.classList.add('hidden');
    tripProgressFillEl.style.width = '0%';
    tripProgressTextEl.textContent = '';

    const events = computeStationEvents(station);
    if (events.length){
      tripStopsTitleEl.classList.remove('hidden');
      tripStopsTitleEl.textContent = `Trains observ√©s (${events.length})`;
    } else {
      tripStopsTitleEl.classList.remove('hidden');
      tripStopsTitleEl.textContent = 'Trains observ√©s';
    }

    if (!events.length){
      tripStopsEl.innerHTML = '<div class="station-event empty">Aucun train en approche imm√©diate.</div>';
      return;
    }

    const cards = events.map(ev=>{
      const title = ev.titleText || (ev.number ? `Train ${ev.number}` : (ev.headsign || ev.displayName || ev.trainId));
      const subtitle = [];
      if (ev.headsign && (!ev.number || !title.includes(ev.headsign))){
        subtitle.push(ev.headsign);
      } else if (ev.displayName && ev.displayName !== title){
        subtitle.push(ev.displayName); 
      }
      if (ev.delayInfo){
        subtitle.push(ev.delayInfo.panelText);
      }
      if (ev.disruptionText){
        subtitle.push(ev.disruptionText);
      }
      const statusText = ev.state + (ev.diff!=null && isFinite(ev.diff) ? ` ¬∑ ${fmtRelative(ev.diff)}` : '');
      const arrLine = renderStationEventTime('Arriv√©e', ev.arrPlanned, ev.arrSec);
      const depLine = renderStationEventTime('D√©part', ev.depPlanned, ev.depSec);
      const note = subtitle.length ? `<div class="station-event-note">${escapeHTML(subtitle.join(' ‚Äî '))}</div>` : '';
      const times = `<div class="station-event-times">${arrLine}${depLine}</div>`;
      const btnId = escapeAttr(ev.trainId);
      const btnLabel = escapeAttr(`Ouvrir le d√©tail du ${ev.ariaLabel || (ev.number ? `train ${ev.number}` : 'service')}`);
      return `<div class="station-event"><div class="station-event-main"><div class="station-event-title">${escapeHTML(title)}</div><div class="station-event-status">${escapeHTML(statusText)}</div>${times}${note}</div><button type="button" class="station-train-link" data-train-id="${btnId}" aria-label="${btnLabel}">${ev.cow}<span>D√©tails</span></button></div>`;
    }).join('');

    tripStopsEl.innerHTML = cards;
  }

  function computeStationEvents(station){
    const stopIds = station.stopSet || new Set(station.stopIds || []);
    const now = nowSecLocal();
    const events = [];

    for (const [tripId, train] of trainDataById.entries()){
      const seq = stopTimesByTrip.get(tripId);
      if (!seq || !seq.length) continue;
      let target = null;
      let targetIdx = -1;
      for (let i=0;i<seq.length;i++){
        const st = seq[i];
        if (stopIds.has(st.stop_id)) { target = st; targetIdx = i; break; }
        const meta = stopsById.get(st.stop_id);
        if (meta?.parent_station && stopIds.has(meta.parent_station)){ target = st; targetIdx = i; break; }
      }
      if (!target) continue;

      const realtimeProfile = realtimeStopDataByTrip.get(tripId)
        || computeRealtimeStopData(
          tripId,
          seq,
          train.numberKey || extractTrainNumberCandidate(train.number) || extractTrainNumberCandidate(tripId),
          realtimeOptionsForTrain(train)
        );
      const profileStop = targetIdx >= 0 ? realtimeProfile?.stops?.[targetIdx] : null;

      const arrPlanned = target.arrival ?? null;
      const depPlanned = target.departure ?? null;
      const arrSec = profileStop?.arrivalRealtime ?? arrPlanned;
      const depSec = profileStop?.departureRealtime ?? depPlanned;
      let state = null;
      let focusSec = null;

      if (arrSec!=null && depSec!=null && now >= arrSec && now <= depSec){
        state = 'En gare';
        focusSec = depSec;
      } else if (arrSec!=null && arrSec >= now){
        state = 'Arriv√©e';
        focusSec = arrSec;
      } else if (depSec!=null && depSec >= now){
        state = 'D√©part';
        focusSec = depSec;
      } else {
        continue;
      }

      const titleText = formatTrainLabel(train, { includeTrainWord:true, fallbackId:tripId });
      const ariaLabel = formatTrainAriaLabel(train, tripId);
      const labelMeta = trainLabelParts(train, tripId);

      const delayInfo = train.delayInfo || computeTrainDelayInfo(train);

      const disruptionText = findSncfDisruptionForTrain(train);
      
      events.push({
        trainId: tripId,
        number: train.number,
        headsign: train.headsign,
        displayName: train.displayName || train.number || tripId,
        label: labelMeta.label,
        category: labelMeta.category,
        titleText,
        ariaLabel,
        arrSec,
        depSec,
        arrPlanned,
        depPlanned,
        state,
        focusSec,
        diff: focusSec - now,
        cow: glyphForTrain(train, delayInfo),
        delayInfo,
        disruptionText
      });
    }

    events.sort((a,b)=>a.focusSec - b.focusSec);
    return events.slice(0, 8);
  }

  function prepareStationMetadata(){
  axisStationByStopId.clear();
  const nameIndex = new Map();
  for (const [stopId, meta] of stopsById.entries()){
    const candidates = [meta.name, meta.stop_name, meta.stop_desc];
    for (const candidate of candidates){
      const norm = normalizeStationName(candidate);
      if (!norm) continue;
      if (!nameIndex.has(norm)) nameIndex.set(norm, []);
      nameIndex.get(norm).push(stopId);
    }
  } 
  for (const station of AXIS_STATIONS){
    const ids = new Set(station.stopIds || []);

    if (station.stopArea){
      ids.add(station.stopArea);
      if (stopChildrenByParent.has(station.stopArea)){
        for (const child of stopChildrenByParent.get(station.stopArea)){
          ids.add(child.stop_id);
        }
      }
    }

    if (!isFinite(station.lat) || !isFinite(station.lon)){
      if (station.stopArea && stopsById.has(station.stopArea)){
        const meta = stopsById.get(station.stopArea);
        station.lat = meta.lat;
        station.lon = meta.lon;
      } else {
        for (const id of ids){
          const meta = stopsById.get(id);
          if (meta){
            station.lat = meta.lat;
            station.lon = meta.lon;
            break;
          }
        }
      }
    }

    if (Array.isArray(station.extraStopNames)){
      for (const label of station.extraStopNames){
        const norm = normalizeStationName(label);
        if (!norm) continue;
        const matches = nameIndex.get(norm);
        if (matches){
          for (const stopId of matches){
            ids.add(stopId);
          }
        }
      }
    }

    station.stopIds = Array.from(ids);
    station.stopSet = new Set(station.stopIds);

    for (const id of station.stopIds){
      axisStationByStopId.set(id, station);
    }
  }
}
function setLayerGroupVisibility(group, visible){
    if (!group) return;
    const onMap = map.hasLayer(group);
    if (visible && !onMap){
      group.addTo(map);
    } else if (!visible && onMap){
      group.removeFrom(map);
    }
  }

  function applyLayerVisibility(){
    setLayerGroupVisibility(overlay.axisStationsMajor, layerVisibility.stationsMajor);
    setLayerGroupVisibility(overlay.axisStationsRegular, layerVisibility.stationsRegular);
    setLayerGroupVisibility(overlay.trains, layerVisibility.trains);
  }

  function ensureTrainLayer(){
    if (!overlay.trains){
      overlay.trains = L.layerGroup();
      if (layerVisibility.trains){
        overlay.trains.addTo(map);
      }
    }
    return overlay.trains;
  }
    
  function renderAxisStations(){
    if (overlay.axisStationsMajor){
      overlay.axisStationsMajor.remove();
      overlay.axisStationsMajor = null;
    }
    if (overlay.axisStationsRegular){
      overlay.axisStationsRegular.remove();
      overlay.axisStationsRegular = null;
    }
    const majorMarkers = [];
    const regularMarkers = [];
    for (const station of AXIS_STATIONS){
      if (!isFinite(station.lat) || !isFinite(station.lon)) continue;
      const marker = L.marker([station.lat, station.lon], {
        icon: iconForStation(station),
        keyboard:false,
        interactive:true,
        zIndexOffset:600
      });
      marker.bindTooltip(station.label, {permanent:false});
      if (station.type === 'major'){
        majorMarkers.push(marker);
      } else {
        regularMarkers.push(marker);
      }
    }
    if (majorMarkers.length){
      overlay.axisStationsMajor = L.layerGroup(majorMarkers);
    }
    if (regularMarkers.length){
      overlay.axisStationsRegular = L.layerGroup(regularMarkers);
    }
    applyLayerVisibility();
  }
  
   // ---------- Graphe r√©seau (pour suivre les voies) ----------
  const networkGraph = new Map();       // key -> { key, lat, lon, neighbors: Map<key, distance> }
  const networkNodes = [];              // liste des noeuds pour recherche voisinage
  const stopNearestCache = new Map();   // stop_id -> { node, dist }
  const stopPathCache = new Map();      // "stopA|stopB" -> chemin pr√©-calcul√©

  // pond√©rer les segments selon l'√©tat publi√© par SNCF R√©seau afin d'√©viter
  // que les trajets suivent des voies neutralis√©es ou ferm√©es lorsqu'une
  // alternative exploit√©e existe encore dans le graphe.
  const NETWORK_STATUS_WEIGHTS = new Map([
    ['exploit√©e', 1],
    ['transf√©r√©e en voie de service', 1.15],
    ['neutralis√©e', 6],
    ['neutralis√©e et conserv√©e pour les besoins de la d√©fense', 8],
    ['d√©class√©e non vendue', 8],
    ['d√©class√©e vendue', 18],
    ['ferm√©e', 10],
    ['ferm√©e avec maintien en place de la voie', 12],
    ['ferm√©e et d√©pos√©e (plus utilisable)', 16],
    ['ferm√©e et mise √† disposition de tiers', 14],
    ['ferm√©e non d√©pos√©e (plus utilisable)', 12],
    ['retranch√©e (plus utilisable)', 15]
  ]);
  const NETWORK_STATUS_DEFAULT_WEIGHT = 5;

  function statusWeightFactor(status){
    if (!status) return 1;
    const key = status.trim().toLowerCase();
    if (!key) return 1;
    return NETWORK_STATUS_WEIGHTS.get(key) ?? NETWORK_STATUS_DEFAULT_WEIGHT;
  }

  function coordKey(lat, lon){ return `${Math.round(lat*1e6)},${Math.round(lon*1e6)}`; }

  function ensureNetworkNode(lat, lon){
    const key = coordKey(lat, lon);
    if (!networkGraph.has(key)){
      networkGraph.set(key, { key, lat, lon, neighbors: new Map() });
      networkNodes.push(networkGraph.get(key));
    }
    return networkGraph.get(key);
  }

  function addNetworkEdge(latA, lonA, latB, lonB, weightFactor = 1){
    const nodeA = ensureNetworkNode(latA, lonA);
    const nodeB = ensureNetworkNode(latB, lonB);
    const base = distLL({lat:latA, lon:lonA}, {lat:latB, lon:lonB});
    if (!isFinite(base) || base <= 0) return;
    const factor = Number.isFinite(weightFactor) && weightFactor > 0 ? weightFactor : 1;
    const d = base * factor;
    if (!isFinite(d) || d <= 0) return;
    if (!nodeA.neighbors.has(nodeB.key) || nodeA.neighbors.get(nodeB.key) > d){
      nodeA.neighbors.set(nodeB.key, d);
    }
    if (!nodeB.neighbors.has(nodeA.key) || nodeB.neighbors.get(nodeA.key) > d){
      nodeB.neighbors.set(nodeA.key, d);
    }
  }

  function ingestGeoJSONNetwork(data){
    if (!data) return;
    const features = data.type === 'FeatureCollection' ? data.features : [data];
    for (const feat of features){
      if (!feat || !feat.geometry) continue;
      const geom = feat.geometry;
      const type = geom.type;
      const weightFactor = statusWeightFactor(feat?.properties?.libelle);
      if (type === 'LineString'){
        processLineStringCoords(geom.coordinates, weightFactor);
      } else if (type === 'MultiLineString'){
        for (const coords of geom.coordinates){ processLineStringCoords(coords, weightFactor); }
      }
    }
  }

  function processLineStringCoords(coords, weightFactor = 1){
    if (!Array.isArray(coords)) return;
    for (let i=1;i<coords.length;i++){
      const [lonA, latA] = coords[i-1];
      const [lonB, latB] = coords[i];
      if (!isFinite(latA) || !isFinite(lonA) || !isFinite(latB) || !isFinite(lonB)) continue;
      addNetworkEdge(latA, lonA, latB, lonB, weightFactor);
    }
  }

  const MANUAL_CONNECTOR_SEGMENTS = [
    [
      [49.46658076914014, 6.109331392744701],
      [49.46755304211354, 6.109018226768153],
      [49.470987657519295, 6.108052087802873],
      [49.47186965380722, 6.107870598848106],
      [49.47174049199803, 6.107837229130531],
      [49.471561250728215, 6.10785928146085],
      [49.471114767474596, 6.107939072253058]
    ],
    [
      [49.51742762768063, 6.101569489369114],
      [49.51740417509697, 6.101688948209521]
    ],
    [
      [49.59684626924659, 6.132947671869363],
      [49.596927050485505, 6.1327399450261035]
    ],
    [
      [49.45545408844863, 6.129087542059966],
      [49.45545408934669, 6.129087542114585]
    ]
  ];

  function applyManualConnectors(){
    for (const segment of MANUAL_CONNECTOR_SEGMENTS){
      if (!Array.isArray(segment) || segment.length < 2) continue;
      for (let i=1;i<segment.length;i++){
        const prev = segment[i-1];
        const curr = segment[i];
        if (!prev || !curr) continue;
        const [latA, lonA] = prev;
        const [latB, lonB] = curr;
        if (!isFinite(latA) || !isFinite(lonA) || !isFinite(latB) || !isFinite(lonB)) continue;
        addNetworkEdge(latA, lonA, latB, lonB, 1);
      }
    }
  }
 
  function nearestNetworkNode(stop){
    if (!stop) return null;
    if (stopNearestCache.has(stop.stop_id)) return stopNearestCache.get(stop.stop_id);
    let best = null, bestDist = Infinity;
    for (const node of networkNodes){
      const d = distLL({lat:stop.lat, lon:stop.lon}, {lat:node.lat, lon:node.lon});
      if (d < bestDist){ bestDist = d; best = node; }
    }
    const res = best ? { node: best, dist: bestDist } : null;
    stopNearestCache.set(stop.stop_id, res);
    return res;
  }

  function shortestPathNodes(startKey, endKey){
    if (!networkGraph.has(startKey) || !networkGraph.has(endKey)) return null;
    if (startKey === endKey) return [networkGraph.get(startKey)];

    const distMap = new Map([[startKey, 0]]);
    const prevMap = new Map();
    const visited = new Set();
    const queue = [{ key: startKey, dist: 0 }];

    while (queue.length){
      queue.sort((a,b)=>a.dist-b.dist);
      const { key, dist } = queue.shift();
      if (visited.has(key)) continue;
      visited.add(key);
      if (key === endKey) break;
      const node = networkGraph.get(key);
      if (!node) continue;
      for (const [nextKey, weight] of node.neighbors){
        if (visited.has(nextKey)) continue;
        const newDist = dist + weight;
        if (newDist < (distMap.get(nextKey) ?? Infinity)){
          distMap.set(nextKey, newDist);
          prevMap.set(nextKey, key);
          queue.push({ key: nextKey, dist: newDist });
        }
      }
    }

    if (!distMap.has(endKey)) return null;
    const keys = [];
    let cur = endKey;
    while (cur){
      keys.push(cur);
      if (cur === startKey) break;
      cur = prevMap.get(cur);
      if (cur === undefined) return null;
    }
    keys.reverse();
    return keys.map(k=>networkGraph.get(k)).filter(Boolean);
  }

  function makePath(rawCoords, isFallback){
    const coords = [];
    const cum = [];
    let total = 0;
    for (let i=0;i<rawCoords.length;i++){
      const c = rawCoords[i];
      if (!Array.isArray(c) || c.length<2) continue;
      if (!coords.length){
        coords.push(c);
        cum.push(0);
        continue;
      }
      const prev = coords[coords.length-1];
      const d = distLL({lat:prev[0], lon:prev[1]}, {lat:c[0], lon:c[1]});
      if (!isFinite(d)) continue;
      if (d < 0.5){
        if (i === rawCoords.length-1 && (prev[0] !== c[0] || prev[1] !== c[1])){
          coords.push(c);
          cum.push(total);
        }
        continue;
      }
      total += d;
      coords.push(c);
      cum.push(total);
    }
    if (coords.length < 2 && rawCoords.length){
      const last = rawCoords[rawCoords.length-1];
      if (last && (coords.length === 0 || coords[coords.length-1][0] !== last[0] || coords[coords.length-1][1] !== last[1])){
        coords.push(last);
        cum.push(total);
      }
    }
    if (!coords.length){
      coords.push([0,0]);
      cum.push(0);
    } else if (coords.length === 1){
      coords.push(coords[0]);
      cum.push(total);
    }
    return { coords, cumDistances: cum, totalDist: total, isFallback: !!isFallback };
  }

  function directPathBetweenStops(stopA, stopB){
    return makePath([[stopA.lat, stopA.lon],[stopB.lat, stopB.lon]], true);
  }

  function computeStopPath(stopA, stopB){
    const direct = directPathBetweenStops(stopA, stopB);
    if (!networkNodes.length) return direct;
    const anchorA = nearestNetworkNode(stopA);
    const anchorB = nearestNetworkNode(stopB);
    if (!anchorA || !anchorB) return direct;
    const pathNodes = shortestPathNodes(anchorA.node.key, anchorB.node.key);
    if (!pathNodes || !pathNodes.length) return direct;

    const coords = [[stopA.lat, stopA.lon]];
    const firstNode = pathNodes[0];
    if (firstNode) coords.push([firstNode.lat, firstNode.lon]);
    for (let i=1;i<pathNodes.length-1;i++){
      const node = pathNodes[i];
      coords.push([node.lat, node.lon]);
    }
    const lastNode = pathNodes[pathNodes.length-1];
    if (lastNode) coords.push([lastNode.lat, lastNode.lon]);
    coords.push([stopB.lat, stopB.lon]);

    const path = makePath(coords, false);
    if (!path.totalDist) return direct;
    return path;
  }

  function pathBetweenStops(stopA, stopB){
    if (!stopA || !stopB) return null;
    const key = `${stopA.stop_id}|${stopB.stop_id}`;
    if (stopPathCache.has(key)) return stopPathCache.get(key);
    const path = computeStopPath(stopA, stopB);
    stopPathCache.set(key, path);
    const revKey = `${stopB.stop_id}|${stopA.stop_id}`;
    if (!stopPathCache.has(revKey) && path){
      const revCoords = [...path.coords].map(c=>[c[0], c[1]]).reverse();
      stopPathCache.set(revKey, makePath(revCoords, path.isFallback));
    }
    return path;
  }

  function positionAlongPath(path, ratio){
    if (!path) return null;
    const target = Math.max(0, Math.min(1, ratio)) * (path.totalDist || 0);
    const cum = path.cumDistances;
    const coords = path.coords;
    if (!coords || coords.length === 0) return null;
    if (coords.length === 1) return { lat: coords[0][0], lon: coords[0][1] };
    for (let i=1;i<cum.length;i++){
      if (target <= cum[i]){
        const segLen = cum[i] - cum[i-1];
        const t = segLen > 0 ? (target - cum[i-1]) / segLen : 0;
        const [latA, lonA] = coords[i-1];
        const [latB, lonB] = coords[i];
        return { lat: lerp(latA, latB, t), lon: lerp(lonA, lonB, t) };
      }
    }
    const last = coords[coords.length-1];
    return { lat: last[0], lon: last[1] };
  } 

  // zones d'int√©r√™t (filtre "sillon" simple)
  const AXIS_STOP_KEYWORDS = [
    'nancy',
    'pont a mousson',
    'metz',
    'hagondange',
    'thionville',
    'bettembourg',
    'luxembourg'
  ].map(normalizeStationName);
  const EXCLUDED_TRAIN_NUMBERS = new Set(['44700']);
  const EXCLUDED_TRAIN_NUMBER_PREFIXES = ['447'];
  const CORE_TGV_STOP_KEYWORDS = ['metz','nancy','thionville','luxembourg'].map(normalizeStationName);
  const CORE_TGV_STOP_CODES = new Set([
    '87141002', // Nancy
    '87192039', // Metz-Ville
    '87191007', // Thionville
    '82001000'  // Luxembourg
  ]);

  // ---------- Chargement r√©seaux ----------
  async function loadNetworks(){
    try {
      const rfn = await fetchJSONAny(FILES.rfn);
      ingestGeoJSONNetwork(rfn);
      overlay.rfn = L.geoJSON(rfn, { style:{ color:'#00f0ff', weight:3, opacity:0.6 } }).addTo(map);
      let bounds = overlay.rfn.getBounds();

      try {
        const cfl = await fetchJSONAny(FILES.cfl);
        ingestGeoJSONNetwork(cfl);
        overlay.cfl = L.geoJSON(cfl, { style:{ color:'#ff00e0', weight:3, opacity:0.6 } }).addTo(map);
        bounds.extend(overlay.cfl.getBounds());
      } catch(e){
        setStatus('RFN charg√© ‚Äî CFL introuvable (ok si en cours de conversion)', true);
      }

      applyManualConnectors();

      stopNearestCache.clear();
      stopPathCache.clear();

      if (SILLON_BOUNDS && SILLON_BOUNDS.isValid()){
        map.fitBounds(SILLON_BOUNDS.pad(0.18), { maxZoom: 11 });
      } else {
        map.fitBounds(bounds);
      }
    } catch(e){
      setStatus('Erreur chargement r√©seaux: '+e.message, true);
    }
  }

  // ---------- Chargement GTFS (sans shapes) ----------
  async function loadGTFS(){
    try {
      stopNearestCache.clear();
      stopPathCache.clear();
      stopTimesByTrip.clear();
      tripsById.clear();
      routesById.clear();
      stopsById.clear();
      stopMetaByNumericCode.clear();
      stopChildrenByParent.clear();
      stopNameCandidatesCache.clear();
      realtimeStopDataByTrip.clear();
      tripMergeSignatureCache.clear();
      staticRelatedNumbersByTrip.clear();

      const axisStopIds = new Set();
      const axisTripIds = new Set();
      const axisRouteIds = new Set();
      let filteredTgvCount = 0;
      let combinedActiveServiceIds = null;
      const mergeActiveServices = (set)=>{
        if (!set || !set.size) return;
        if (!combinedActiveServiceIds) combinedActiveServiceIds = new Set();
        for (const id of set) combinedActiveServiceIds.add(id);
      };

      const rawStopsById = new Map();
      const rawStopChildrenByParent = new Map();
      
      const [stops, stopTimesRows] = await Promise.all([
        parseCSVAny(FILES.stops),
        parseCSVAny(FILES.stop_times)
      ]);
      for (const s of stops){
        const lat=parseFloat(s.stop_lat), lon=parseFloat(s.stop_lon);
        if (!isFinite(lat)||!isFinite(lon)) continue;
        const parent = s.parent_station || null;
        const locationType = Number(s.location_type ?? 0) || 0;
        const entry = { stop_id:s.stop_id, name:s.stop_name, lat, lon, parent_station:parent, location_type:locationType };
        rawStopsById.set(s.stop_id, entry);
        if (parent){
          if (!rawStopChildrenByParent.has(parent)) rawStopChildrenByParent.set(parent, []);
          rawStopChildrenByParent.get(parent).push(entry);
        }
      }

      // stop_times -> group√©s par trip
      for (const st of stopTimesRows){
        const tid = st.trip_id; if(!tid) continue;
        if (!stopTimesByTrip.has(tid)) stopTimesByTrip.set(tid, []);
        stopTimesByTrip.get(tid).push({
          stop_id: st.stop_id,
          arrival: gtfsTimeToSec(st.arrival_time),
          departure: gtfsTimeToSec(st.departure_time),
          seq: Number(st.stop_sequence)
        });
      }
      for (const [k,v] of stopTimesByTrip) v.sort((a,b)=>a.seq-b.seq);

      for (const [tripId, seq] of Array.from(stopTimesByTrip.entries())){
        if (!tripPassesAxis(seq, rawStopsById)){
          stopTimesByTrip.delete(tripId);
          continue;
        }
        axisTripIds.add(tripId);
        for (const st of seq){
          const meta = rawStopsById.get(st.stop_id);
          if (!meta) continue;
          axisStopIds.add(meta.stop_id);
          if (meta.parent_station){
            axisStopIds.add(meta.parent_station);
            if (rawStopChildrenByParent.has(meta.parent_station)){
              for (const child of rawStopChildrenByParent.get(meta.parent_station)){
                axisStopIds.add(child.stop_id);
              }
            }
          }
          if (rawStopChildrenByParent.has(meta.stop_id)){
            for (const child of rawStopChildrenByParent.get(meta.stop_id)){
              axisStopIds.add(child.stop_id);
            }
          }
        }
      }

      for (const id of axisStopIds){
        const meta = rawStopsById.get(id);
        if (!meta) continue;
        stopsById.set(id, meta);
        indexStopMetaForNumericLookup(meta);
      }
      for (const [parent, children] of rawStopChildrenByParent.entries()){
        if (!axisStopIds.has(parent)) continue;
        const filtered = children.filter(child=>axisStopIds.has(child.stop_id));
        if (filtered.length){
          stopChildrenByParent.set(parent, filtered);
        }
      }

      rawStopsById.clear();
      rawStopChildrenByParent.clear();

      const tripsPromise = parseCSVAny(FILES.trips).catch(()=>null);
      const routesPromise = parseCSVAny(FILES.routes).catch(()=>null);
      const calendarPromise = parseCSVAny(FILES.calendar).catch(()=>null);
      const calendarDatesPromise = parseCSVAny(FILES.calendar_dates).catch(()=>null);

      // trips (optionnel)
      const trips = await tripsPromise;
      if (Array.isArray(trips)){
        for (const t of trips){
         if (axisTripIds.size && !axisTripIds.has(t.trip_id)) continue;
          tripsById.set(t.trip_id, { route_id:t.route_id, headsign:t.trip_headsign, service_id:t.service_id, trip_short_name:t.trip_short_name });
          if (t.route_id) axisRouteIds.add(t.route_id);
        }
      }

      filteredTgvCount = pruneTgvTripsWithoutCoreStops(axisTripIds);

      // routes (optionnel)
      const routes = await routesPromise;
      if (Array.isArray(routes)){
        for (const r of routes){
          if (axisRouteIds.size && !axisRouteIds.has(r.route_id)) continue;
          routesById.set(r.route_id, { short:r.route_short_name, long:r.route_long_name });
        }
      }

      // calendar + calendar_dates (optionnels)
      const calendarRows = await calendarPromise;
      const calendarDateRows = await calendarDatesPromise;

      mergeActiveServices(computeActiveServiceSet(calendarRows, calendarDateRows));

      const stopsBeforeCfl = stopsById.size;
      const tripsBeforeCfl = stopTimesByTrip.size;
      await integrateCflGtfs({ axisStopIds, axisTripIds, axisRouteIds, mergeActiveServices });
      const cflStopsAdded = Math.max(0, stopsById.size - stopsBeforeCfl);
      const cflTripsAdded = Math.max(0, stopTimesByTrip.size - tripsBeforeCfl);

      activeServiceIds = combinedActiveServiceIds && combinedActiveServiceIds.size ? combinedActiveServiceIds : null;
      if (activeServiceIds && !tripsById.size) activeServiceIds = null;

      rebuildStaticMergeData();
      prepareStationMetadata();
      renderAxisStations();

      let statusMsg = 'GTFS charg√© ‚Äî ' + stopsById.size + ' gares, ' + stopTimesByTrip.size + ' trips';
      if (filteredTgvCount) statusMsg += `, ${filteredTgvCount} TGV hors sillon exclus`;
      if (cflStopsAdded || cflTripsAdded){
        statusMsg += ` (CFL +${cflStopsAdded} gares, +${cflTripsAdded} trips)`;
      }
      if (activeServiceIds) statusMsg += ', ' + activeServiceIds.size + ' services actifs aujourd\'hui';
      setStatus(statusMsg + '.');
    } catch(e){
      setStatus('Erreur chargement GTFS: '+e.message, true);
    }
  }

async function integrateCflGtfs({ axisStopIds, axisTripIds, axisRouteIds, mergeActiveServices } = {}){
    try {
      const routeRows = await parseCSVAny(CFL_FILES.routes, CFL_BASES);
      const cflRoutes = new Map(); // original -> { key, short, long, agency_id, original }
      for (const row of routeRows){
        const routeId = (row.route_id || '').trim();
        const agencyId = (row.agency_id || '').trim();
        if (!routeId || !CFL_ROUTE_IDS_ALLOWED.has(routeId)) continue;
        if (agencyId !== '11') continue;
        const key = `CFL:${routeId}`;
        cflRoutes.set(routeId, {
          key,
          short: (row.route_short_name || '').trim(),
          long: (row.route_long_name || '').trim(),
          agency_id: agencyId,
          original: routeId
        });
      }

      if (!cflRoutes.size) return null;

      const stopRows = await parseCSVAny(CFL_FILES.stops, CFL_BASES);
      const cflStopsById = new Map();
      const stopIdMap = new Map(); // original -> prefixed
      for (const row of stopRows){
        const rawId = (row.stop_id || '').trim();
        const rawName = (row.stop_name || '').trim();
        if (!rawId || !rawName) continue;
        if (!isCflStationCandidate(rawName)) continue;
        const lat = parseFloat(row.stop_lat);
        const lon = parseFloat(row.stop_lon);
        if (!isFinite(lat) || !isFinite(lon)) continue;
        const stopKey = `CFL:${rawId}`;
        stopIdMap.set(rawId, stopKey);
        const entry = {
          stop_id: stopKey,
          stop_id_original: rawId,
          name: sanitizeCflStationName(rawName),
          stop_name: rawName,
          stop_desc: (row.stop_desc || '').trim() || undefined,
          lat,
          lon,
          parent_station: null,
          location_type: Number(row.location_type ?? 0) || 0,
          source: 'CFL'
        };
        cflStopsById.set(stopKey, entry);
      }

      if (!cflStopsById.size) return null;

      const tripRows = await parseCSVAny(CFL_FILES.trips, CFL_BASES);
      const cflTripsMeta = new Map(); // original trip id -> meta
      for (const row of tripRows){
        const rawTripId = (row.trip_id || '').trim();
        const rawRouteId = (row.route_id || '').trim();
        const rawServiceId = (row.service_id || '').trim();
        if (!rawTripId || !rawRouteId || !rawServiceId) continue;
        if (!cflRoutes.has(rawRouteId)) continue;
        const tripKey = `CFL:${rawTripId}`;
        const serviceKey = `CFL:${rawServiceId}`;
        const routeInfo = cflRoutes.get(rawRouteId);
        cflTripsMeta.set(rawTripId, {
          tripKey,
          originalTripId: rawTripId,
          routeKey: routeInfo.key,
          serviceKey,
          headsign: (row.trip_headsign || '').trim(),
          shortName: (row.trip_short_name || '').trim()
        });
      }

      if (!cflTripsMeta.size) return null;

      const stopTimeRows = await parseCSVAny(CFL_FILES.stop_times, CFL_BASES);
      const cflStopTimesByTrip = new Map();
      for (const row of stopTimeRows){
        const rawTripId = (row.trip_id || '').trim();
        const meta = cflTripsMeta.get(rawTripId);
        if (!meta) continue;
        const rawStopId = (row.stop_id || '').trim();
        const stopKey = stopIdMap.get(rawStopId);
        if (!stopKey) continue;
        if (!cflStopTimesByTrip.has(rawTripId)) cflStopTimesByTrip.set(rawTripId, []);
        cflStopTimesByTrip.get(rawTripId).push({
          stop_id: stopKey,
          arrival: gtfsTimeToSec(row.arrival_time),
          departure: gtfsTimeToSec(row.departure_time),
          seq: Number(row.stop_sequence)
        });
      }

      const usedRouteKeys = new Set();
      const keptServiceIds = new Set();
      let addedStops = 0;
      let addedTrips = 0;

      for (const [rawTripId, seq] of cflStopTimesByTrip.entries()){
        seq.sort((a,b)=>a.seq-b.seq);
        if (seq.length < 2) continue;
        const meta = cflTripsMeta.get(rawTripId);
        if (!meta) continue;
        if (!tripPassesAxis(seq, cflStopsById)) continue;

        const { tripKey, routeKey, serviceKey, headsign, shortName, originalTripId } = meta;
        if (stopTimesByTrip.has(tripKey)) continue;
        stopTimesByTrip.set(tripKey, seq);
        addedTrips++;
        usedRouteKeys.add(routeKey);
        keptServiceIds.add(serviceKey);
        if (axisTripIds) axisTripIds.add(tripKey);
        if (axisRouteIds) axisRouteIds.add(routeKey);
        tripsById.set(tripKey, {
          route_id: routeKey,
          headsign,
          service_id: serviceKey,
          trip_short_name: shortName,
          source: 'CFL',
          original_trip_id: originalTripId
        });
        for (const st of seq){
          if (axisStopIds) axisStopIds.add(st.stop_id);
          const stopMeta = cflStopsById.get(st.stop_id);
          if (!stopMeta) continue;
          if (!stopsById.has(st.stop_id)){
            stopsById.set(st.stop_id, stopMeta);
            indexStopMetaForNumericLookup(stopMeta);
            addedStops++;
          }
        }
      }

      for (const routeInfo of cflRoutes.values()){
        if (!usedRouteKeys.has(routeInfo.key)) continue;
        if (!routesById.has(routeInfo.key)){
          routesById.set(routeInfo.key, {
            short: routeInfo.short,
            long: routeInfo.long,
            agency_id: routeInfo.agency_id,
            source: 'CFL',
            original_route_id: routeInfo.original
          });
        }
      }

      if (keptServiceIds.size){
        let calendarRows = null;
        try {
          const rows = await parseCSVAny(CFL_FILES.calendar, CFL_BASES);
          calendarRows = rows.map(row => {
            const svcRaw = (row.service_id || '').trim();
            if (!svcRaw) return null;
            const serviceKey = `CFL:${svcRaw}`;
            if (!keptServiceIds.has(serviceKey)) return null;
            return { ...row, service_id: serviceKey };
          }).filter(Boolean);
        } catch(_){ /* ok si absent */ }

        let calendarDateRows = null;
        try {
          const rows = await parseCSVAny(CFL_FILES.calendar_dates, CFL_BASES);
          calendarDateRows = rows.map(row => {
            const svcRaw = (row.service_id || '').trim();
            if (!svcRaw) return null;
            const serviceKey = `CFL:${svcRaw}`;
            if (!keptServiceIds.has(serviceKey)) return null;
            return { ...row, service_id: serviceKey };
          }).filter(Boolean);
        } catch(_){ /* ok si absent */ }

        if ((calendarRows && calendarRows.length) || (calendarDateRows && calendarDateRows.length)){
          mergeActiveServices?.(computeActiveServiceSet(calendarRows, calendarDateRows));
        }
      }

      return { addedStops, addedTrips };
    } catch(e){
      console.warn('[CFL] Chargement GTFS CFL impossible', e);
      return null;
    }
  }

function stationNameMatchesKeywords(name, keywords){
    if (!name || !Array.isArray(keywords) || !keywords.length) return false;
    const normalized = normalizeStationName(name);
    if (!normalized) return false;
    const collapsed = normalized.replace(/[-'_]+/g, ' ').replace(/\s+/g, ' ').trim();
    for (const keyword of keywords){
      if (!keyword) continue;
      if (normalized.includes(keyword)) return true;
      if (collapsed.includes(keyword)) return true;
    }
    return false;
  }

  function sequenceMatchesKeywords(seq, keywords, lookup = stopsById){
    if (!Array.isArray(seq) || !seq.length || !keywords?.length) return false;
    for (const stop of seq){
      const meta = lookup.get(stop.stop_id);
      if (!meta || !meta.name) continue;
      if (stationNameMatchesKeywords(meta.name, keywords)) return true;
    }
    return false;
  }

   function stopMetaMatchesStationCodes(meta, codes, lookup = stopsById){
    if (!meta || !codes?.size) return false;
    const digits = new Set();
    const pushDigitsFrom = (raw)=>{
      if (!raw) return;
      const matches = String(raw).match(/\d{4,}/g);
      if (!matches) return;
      for (const match of matches){
        digits.add(match);
      }
    };
    pushDigitsFrom(meta.stop_id);
    pushDigitsFrom(meta.parent_station);
    const parentId = meta.parent_station;
    if (parentId && lookup.has(parentId)){
      const parentMeta = lookup.get(parentId);
      if (parentMeta){
        pushDigitsFrom(parentMeta.stop_id ?? parentMeta.stopId ?? null);
      }
    }
    if (!digits.size) return false;
    for (const digit of digits){
      if (codes.has(digit)) return true;
    }
    return false;
  }

  function sequenceMatchesStationCodes(seq, codes, lookup = stopsById){
    if (!Array.isArray(seq) || !seq.length || !codes?.size) return false;
    for (const stop of seq){
      const meta = lookup.get(stop.stop_id);
      if (!meta) continue;
      if (stopMetaMatchesStationCodes(meta, codes, lookup)) return true;
    }
    return false;
  }  

  function isTripLikelyTgv(tripId){
    const trip = tripsById.get(tripId);
    if (!trip) return false;
    const route = trip.route_id ? routesById.get(trip.route_id) : null;
    const probes = [trip.trip_short_name, trip.headsign, route?.short, route?.long];
    return probes.some(value => value && /\bTGV\b/i.test(value));
  }

  function pruneTgvTripsWithoutCoreStops(axisTripIds){
    if (!stopTimesByTrip.size) return 0;
    let removed = 0;
    for (const [tripId, seq] of Array.from(stopTimesByTrip.entries())){
      if (!isTripLikelyTgv(tripId)) continue;
      if (sequenceMatchesStationCodes(seq, CORE_TGV_STOP_CODES) || sequenceMatchesKeywords(seq, CORE_TGV_STOP_KEYWORDS)) continue;
      stopTimesByTrip.delete(tripId);
      tripsById.delete(tripId);
      realtimeStopDataByTrip.delete(tripId);
      staticRelatedNumbersByTrip.delete(tripId);
      if (axisTripIds) axisTripIds.delete(tripId);
      removed++;
    }
    return removed;
  }

  // ---------- Filtre sillon & service du jour ----------
  function tripPassesAxis(seq, lookup = stopsById){
    if (!Array.isArray(seq) || seq.length < 2) return false;
    let hits = 0;
    for (const stop of seq){
      const meta = lookup.get(stop.stop_id);
      if (!meta || !meta.name) continue;
      if (stationNameMatchesKeywords(meta.name, AXIS_STOP_KEYWORDS)){
        hits++;
        if (hits >= 2) return true;
      }
    }
    return false;
  }

  function serviceAllowed(trip_id){
    if (!activeServiceIds) return true;
    const trip = tripsById.get(trip_id);
    if (!trip || !trip.service_id) return false;
    return activeServiceIds.has(trip.service_id);
  }

  // ---------- Calcul positions (interpolation arr√™t‚Üíarr√™t) ----------
  function trainsAt(nowSec){
    const items=[];
    for (const [trip_id, seq] of stopTimesByTrip.entries()){
      if (seq.length<2) continue;
      if (!tripPassesAxis(seq)) continue;
      if (!serviceAllowed(trip_id)) continue;

      const trip = tripsById.get(trip_id) || {};
      const route = routesById.get(trip.route_id) || {};
      const rawNumber = trainNumberForTrip(trip, route, trip_id);
      const numberCandidate = extractTrainNumberCandidate(rawNumber);
      const fallbackNumberCandidate = numberCandidate || extractTrainNumberCandidate(trip_id) || null;
      const numberKeyRaw = fallbackNumberCandidate != null ? String(fallbackNumberCandidate) : null;
      const numberKey = numberKeyRaw ? normalizeTrainNumberKey(numberKeyRaw) : null;
      const branding = computeTrainBranding(trip_id, trip, route, rawNumber, numberCandidate || fallbackNumberCandidate);
      const category = branding.category || 'sncf';
      if ((category === 'sncf' && !trainFilters.showTer)
        || (category === 'tgv-roi' && !trainFilters.showTgv)
        || (category === 'cfl' && !trainFilters.showCfl)){
        continue;
      }
      const numberDisplay = branding.displayNumber || rawNumber || (numberKey != null ? String(numberKey) : (numberKeyRaw != null ? String(numberKeyRaw) : null));
      const tripSource = trip?.source === 'CFL' ? 'CFL' : 'SNCF';
      const realtimeProfile = computeRealtimeStopData(
        trip_id,
        seq,
        numberKey,
        realtimeOptionsForTrain({ source: tripSource })
      );

      const startPlanned = seq[0].departure ?? seq[0].arrival;
      const lastStop = seq[seq.length - 1];
      const endPlanned = lastStop?.arrival ?? lastStop?.departure;
      const startEffective = realtimeProfile?.startRealtime ?? startPlanned;
      const endEffective = realtimeProfile?.endRealtime ?? endPlanned;
      if (startEffective==null || endEffective==null || nowSec<startEffective || nowSec>endEffective) continue;
      const totalSpan = endEffective - startEffective;
      const tripProgress = totalSpan > 0 ? (nowSec - startEffective) / totalSpan : null;
      const headsign = (()=>{
        if (trip.headsign && trip.headsign !== numberDisplay) return trip.headsign;
        if (route.long && route.long !== numberDisplay) return route.long;
        if (route.short && route.short !== numberDisplay) return route.short;
        return '';
      })();

      let positioned = false;

      for (let i=0;i<seq.length;i++){
        const stop = seq[i];
        const profileStop = realtimeProfile?.stops?.[i];
        const arr = profileStop?.arrivalRealtime ?? stop.arrival;
        const dep = profileStop?.departureRealtime ?? stop.departure;
        if (arr==null || dep==null || dep<=arr) continue;
        if (nowSec < arr || nowSec > dep) continue;

        const stopMeta = stopsById.get(stop.stop_id);
        if (!stopMeta) continue;

        const nextStopMeta = seq[i+1] ? stopsById.get(seq[i+1].stop_id) : null;
        const etaSec = Math.max(0, Math.round(dep - nowSec));

        const displayForList = branding.displayNumber || numberDisplay || rawNumber || null;
        const numberList = displayForList ? [displayForList] : [];
        const delayNumberKeys = [];
        if (numberKey != null) delayNumberKeys.push(String(numberKey));
        const staticHint = staticRelatedNumbersByTrip.get(trip_id);
        if (staticHint && Array.isArray(staticHint.related)){
          for (const rel of staticHint.related){
            const candidateDisplay = rel.displayNumber || rel.rawNumber || null;
            if (!candidateDisplay) continue;
            const str = String(candidateDisplay).trim();
            if (!str) continue;
            if (!numberList.includes(str)) numberList.push(str);
            const normalized = rel.normalizedKey != null ? String(rel.normalizedKey) : null;
            if (normalized && !delayNumberKeys.includes(normalized)){
              delayNumberKeys.push(normalized);
              continue;
            }
            const relCandidate = rel.numberCandidate != null ? normalizeTrainNumberKey(rel.numberCandidate) : null;
            if (relCandidate != null){
              const keyStr = String(relCandidate);
              if (keyStr && !delayNumberKeys.includes(keyStr)) delayNumberKeys.push(keyStr);
              continue;
            }
            const fallbackCandidate = extractTrainNumberCandidate(str);
            const fallbackKey = fallbackCandidate != null ? normalizeTrainNumberKey(fallbackCandidate) : null;
            if (fallbackKey != null){
              const keyStr = String(fallbackKey);
              if (keyStr && !delayNumberKeys.includes(keyStr)) delayNumberKeys.push(keyStr);
            }
          }
        }
        const source = tripSource;

        items.push({
          id: trip_id,
          headsign,
          from: stopMeta.name || stop.stop_id,
          to: nextStopMeta?.name || stopMeta.name || stop.stop_id,
          etaSec,
          lat: stopMeta.lat,
          lon: stopMeta.lon,
          route_id: trip.route_id,
          number: numberDisplay,
          numberRaw: rawNumber || null,
          numberDigits: branding.digits || null,
          numberKey,
          branding,
          startSec: startEffective,
          endSec: endEffective,
          scheduledStartSec: startPlanned,
          scheduledEndSec: endPlanned,
          progress: tripProgress,
          segmentIndex: i,
          segmentProgress: 0,
          nowSec,
          stopsCount: seq.length,
          currentDelaySec: profileStop?.delaySec ?? 0,
          source,
          numberList,
          delayNumberKeys
        });
        positioned = true;
        break;
      }

      if (positioned) continue;

      for (let i=0;i<seq.length-1;i++){
        const A=seq[i], B=seq[i+1];
        const profileA = realtimeProfile?.stops?.[i];
        const profileB = realtimeProfile?.stops?.[i+1];
        const tA = profileA?.departureRealtime ?? profileA?.arrivalRealtime ?? A.departure ?? A.arrival;
        const tB = profileB?.arrivalRealtime ?? profileB?.departureRealtime ?? B.arrival ?? B.departure;

        const sA = stopsById.get(A.stop_id), sB = stopsById.get(B.stop_id);
        if (!sA || !sB) continue;

        if (tA==null || tB==null || tB<=tA) continue;
        if (nowSec < tA || nowSec > tB) continue;

        const r=(nowSec - tA)/(tB - tA);
        const path = pathBetweenStops(sA, sB);
        const pos = positionAlongPath(path, r) || { lat: lerp(sA.lat, sB.lat, r), lon: lerp(sA.lon, sB.lon, r) };
        const { lat, lon } = pos;
        const etaSec = Math.max(0, Math.round(tB - nowSec));

        const displayForList = branding.displayNumber || numberDisplay || rawNumber || null;
        const numberList = displayForList ? [displayForList] : [];
        const delayNumberKeys = [];
        if (numberKey != null) delayNumberKeys.push(String(numberKey));
        const staticHint = staticRelatedNumbersByTrip.get(trip_id);
        if (staticHint && Array.isArray(staticHint.related)){
          for (const rel of staticHint.related){
            const candidateDisplay = rel.displayNumber || rel.rawNumber || null;
            if (!candidateDisplay) continue;
            const str = String(candidateDisplay).trim();
            if (!str) continue;
            if (!numberList.includes(str)) numberList.push(str);
            const normalized = rel.normalizedKey != null ? String(rel.normalizedKey) : null;
            if (normalized && !delayNumberKeys.includes(normalized)){
              delayNumberKeys.push(normalized);
              continue;
            }
            const relCandidate = rel.numberCandidate != null ? normalizeTrainNumberKey(rel.numberCandidate) : null;
            if (relCandidate != null){
              const keyStr = String(relCandidate);
              if (keyStr && !delayNumberKeys.includes(keyStr)) delayNumberKeys.push(keyStr);
              continue;
            }
            const fallbackCandidate = extractTrainNumberCandidate(str);
            const fallbackKey = fallbackCandidate != null ? normalizeTrainNumberKey(fallbackCandidate) : null;
            if (fallbackKey != null){
              const keyStr = String(fallbackKey);
              if (keyStr && !delayNumberKeys.includes(keyStr)) delayNumberKeys.push(keyStr);
            }
          }
        }
        const source = tripSource;

        items.push({
          id: trip_id,
          headsign,
          from: sA.name || A.stop_id,
          to: sB.name || B.stop_id,
          etaSec,
          lat,
          lon,
          route_id: trip.route_id,
          number: numberDisplay,
          numberRaw: rawNumber || null,
          numberDigits: branding.digits || null,
          numberKey,
          branding,
          startSec: startEffective,
          endSec: endEffective,
          scheduledStartSec: startPlanned,
          scheduledEndSec: endPlanned,
          progress: tripProgress,
          segmentIndex: i,
          segmentProgress: r,
          nowSec,
          stopsCount: seq.length,
          currentDelaySec: profileA?.delaySec ?? 0,
          source,
          numberList,
          delayNumberKeys
        });
        break;
      }
    }
    return mergeTrainsByNumber(mergeCrossBorderTrains(items));
  }

  function approxDistanceKm(lat1, lon1, lat2, lon2){
    if (!Number.isFinite(lat1) || !Number.isFinite(lon1) || !Number.isFinite(lat2) || !Number.isFinite(lon2)) return Infinity;
    const toRad = (deg)=>deg * (Math.PI/180);
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2) * Math.sin(dLat/2)
      + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return 6371 * c;
  }

  function determineTripSource(tripId){
    if (!tripId) return 'SNCF';
    const trip = tripsById.get(tripId) || null;
    if (trip?.source) return String(trip.source).toUpperCase();
    const route = trip?.route_id ? routesById.get(trip.route_id) : null;
    if (route?.source) return String(route.source).toUpperCase();
    if (tripId.startsWith('CFL:')) return 'CFL';
    return 'SNCF';
  }

  function buildTripMergeSignature(tripId, seq){
    if (!tripId || !Array.isArray(seq) || seq.length < 2) return null;
    const normalizedStops = [];
    const offsets = [];
    let startTime = null;
    for (const st of seq){
      const stopMeta = stopsById.get(st.stop_id);
      const rawName = stopMeta?.name || stopMeta?.stop_name || stopMeta?.stop_desc || st.stop_id;
      const norm = normalizeStationName(rawName);
      if (!norm) continue;
      normalizedStops.push(norm);
      const primaryTime = st.departure ?? st.arrival ?? null;
      const fallbackTime = st.arrival ?? st.departure ?? null;
      const time = primaryTime != null ? primaryTime : fallbackTime;
      if (time != null){
        if (startTime == null) startTime = time;
        const offsetMin = Math.round(((time - startTime) / 60) || 0);
        offsets.push(Number.isFinite(offsetMin) ? offsetMin : 0);
      } else {
        offsets.push(null);
      }
    }
    if (normalizedStops.length < 2) return null;
    const keyStops = normalizedStops.slice(0, 3);
    while (keyStops.length < 3) keyStops.push('');
    const bucket = startTime != null ? Math.round(startTime / 300) : null;
    const signatureCore = normalizedStops.join('|');
    const offsetSignature = offsets.map(off => (off == null ? '?' : off)).join(',');
    const signature = `${signatureCore}#${offsetSignature}#${bucket ?? '?'}`;
    return {
      signature,
      keyStops,
      normalizedStops,
      offsets,
      bucket,
      startTime
    };
  }

  function deriveDirectionKeyFromMeta(meta){
    if (!meta || !Array.isArray(meta.normalizedStops) || meta.normalizedStops.length < 2) return null;
    const first = meta.normalizedStops[0];
    const last = meta.normalizedStops[meta.normalizedStops.length - 1];
    if (!first || !last) return null;
    return `${first}->${last}`;
  }

  function appendStaticRelatedNumbers(tripId, signature, relatedEntries){
    if (!tripId || !Array.isArray(relatedEntries) || !relatedEntries.length) return;
    const existing = staticRelatedNumbersByTrip.get(tripId);
    const merged = new Map();
    const seed = existing?.related;
    if (Array.isArray(seed)){
      for (const rel of seed){
        if (!rel) continue;
        const key = rel.tripId ? `trip:${rel.tripId}` : `${rel.source || ''}:${rel.displayNumber || rel.normalizedKey || rel.rawNumber || ''}`;
        if (!key) continue;
        merged.set(key, rel);
      }
    }
    for (const rel of relatedEntries){
      if (!rel) continue;
      const key = rel.tripId ? `trip:${rel.tripId}` : `${rel.source || ''}:${rel.displayNumber || rel.normalizedKey || rel.rawNumber || ''}`;
      if (!key) continue;
      merged.set(key, rel);
    }
    const finalRelated = Array.from(merged.values()).filter(Boolean);
    if (!finalRelated.length) return;
    staticRelatedNumbersByTrip.set(tripId, { signature: existing?.signature || signature, related: finalRelated });
  }

  function registerRelatedNumbersForEntries(entries, signature){
    if (!Array.isArray(entries) || entries.length < 2) return;
    for (const entry of entries){
      if (!entry?.tripId) continue;
      const related = entries
        .filter(e => e !== entry)
        .map(e => ({
          tripId: e.tripId,
          source: e.source,
          displayNumber: e.displayNumber,
          numberCandidate: e.numberCandidate,
          normalizedKey: e.normalizedKey,
          rawNumber: e.rawNumber,
          digits: e.digits
        }));
      appendStaticRelatedNumbers(entry.tripId, signature, related);
    }
  }

  function detectSncfDoubleNumberGroups(entries){
    if (!Array.isArray(entries) || entries.length < 2) return [];
    const buckets = new Map();
    for (const entry of entries){
      if (!entry || entry.source !== 'SNCF') continue;
      if (entry.category !== 'sncf' && entry.category !== 'tgv-roi') continue;
      const key = entry.normalizedKey != null ? String(entry.normalizedKey) : '';
      if (!key) continue;
      const directionKey = entry.directionKey || deriveDirectionKeyFromMeta(entry.meta);
      if (!directionKey) continue;
      const bucketKey = entry.meta?.bucket != null ? String(entry.meta.bucket) : '?';
      const composite = `${entry.category}|${directionKey}|${bucketKey}`;
      if (!buckets.has(composite)) buckets.set(composite, []);
      buckets.get(composite).push(entry);
    }

    const result = [];
    for (const group of buckets.values()){
      if (!Array.isArray(group) || group.length < 2) continue;
      const numbers = Array.from(new Set(group
        .map(e => (e.normalizedKey != null ? String(e.normalizedKey) : ''))
        .filter(Boolean)));
      if (numbers.length < 2) continue;
      const startTimes = group
        .map(e => (typeof e.meta?.startTime === 'number' ? e.meta.startTime : null))
        .filter(v => v != null);
      let aligned = true;
      if (startTimes.length >= 2){
        const min = Math.min(...startTimes);
        const max = Math.max(...startTimes);
        aligned = Number.isFinite(min) && Number.isFinite(max) ? (max - min) <= 240 : true;
      }
      if (!aligned) continue;
      registerTrainNumberEquivalenceGroup(dynamicTrainNumberEquivalents, numbers);
      result.push(group);
    }
    return result;
  }

  function rebuildStaticMergeData(){
    tripMergeSignatureCache.clear();
    staticRelatedNumbersByTrip.clear();
    dynamicTrainNumberEquivalents.clear();
    const groups = new Map();
    for (const [tripId, seq] of stopTimesByTrip.entries()){
      const meta = buildTripMergeSignature(tripId, seq);
      if (!meta) continue;
      tripMergeSignatureCache.set(tripId, meta);
      if (!groups.has(meta.signature)) groups.set(meta.signature, []);
      groups.get(meta.signature).push({ tripId, meta });
    }

    for (const [signature, entries] of groups.entries()){
      if (!entries || entries.length < 2) continue;
      const enriched = entries.map(({ tripId, meta }) => {
        const trip = tripsById.get(tripId) || {};
        const route = trip?.route_id ? routesById.get(trip.route_id) : null;
        const rawNumber = trainNumberForTrip(trip, route, tripId);
        const numberCandidate = extractTrainNumberCandidate(rawNumber) || extractTrainNumberCandidate(tripId) || null;
        const branding = computeTrainBranding(tripId, trip, route, rawNumber, numberCandidate || null);
        const displayNumber = branding.displayNumber || rawNumber || (numberCandidate != null ? String(numberCandidate) : null);
        const normalizedKey = numberCandidate != null ? normalizeTrainNumberKey(numberCandidate) : null;
        return {
          tripId,
          meta,
          source: determineTripSource(tripId),
          displayNumber,
          numberCandidate,
          normalizedKey,
          rawNumber,
          digits: branding.digits || null,
          category: branding.category || 'sncf',
          directionKey: deriveDirectionKeyFromMeta(meta)
        };
      });
      const linkGroups = [];
      const sourcesPresent = new Set(enriched.map(e => e.source));
      if (sourcesPresent.size >= 2){
        linkGroups.push(enriched);
      }
      const doubleGroups = detectSncfDoubleNumberGroups(enriched);
      if (doubleGroups.length){
        for (const group of doubleGroups){
          linkGroups.push(group);
        }
      }
      for (const group of linkGroups){
        registerRelatedNumbersForEntries(group, signature);
      }
    }
  }

  function computeTrainMergeMeta(train){
    if (!train) return null;
    if (tripMergeSignatureCache.has(train.id)) return tripMergeSignatureCache.get(train.id);
    const seq = stopTimesByTrip.get(train.id);
    if (!seq || seq.length < 2) return null;
    const meta = buildTripMergeSignature(train.id, seq);
    if (meta) tripMergeSignatureCache.set(train.id, meta);
    return meta;
  }
  function normalizedTrainSource(train){
    return (train?.source || 'SNCF').toUpperCase();
  }
  function selectPrimaryTrainForMerge(group){
    let best = group[0];
    let bestScore = Infinity;
    for (const train of group){
      let score = 0;
      const source = normalizedTrainSource(train);
      if (source === 'CFL') score += 2;
      if (source === 'SNCF') score -= 2;
      if (train?.stopsCount != null) score -= Math.min(Number(train.stopsCount) || 0, 12) * 0.1;
      if (train?.branding?.category === 'tgv-roi') score -= 0.2;
      if (score < bestScore){
        bestScore = score;
        best = train;
      }
    }
    return best;
  }

  function buildMergedTrain(group){
    if (!group || !group.length) return null;
    const ordered = group.slice();
    const primary = ordered[0];
    const merged = { ...primary };
    merged.branding = { ...(primary.branding || {}) };
    merged.mergedTripIds = ordered.map(t => t.id);
    merged.mergedSources = Array.from(new Set(ordered.map(t => (t.source || 'SNCF'))));
    if (merged.mergedSources.includes('SNCF')){
      merged.source = 'SNCF';
    } else if (merged.mergedSources.length){
      merged.source = merged.mergedSources[0];
    }

    const displayNumbers = [];
    const displayNumberSet = new Set();
    const pushDisplay = (value)=>{
      if (!value) return;
      const str = String(value).trim();
      if (!str || displayNumberSet.has(str)) return;
      displayNumberSet.add(str);
      displayNumbers.push(str);
    };

    const numbersBySource = new Map();
    const addNumberForSource = (source, value)=>{
      if (!value) return;
      const str = String(value).trim();
      if (!str) return;
      const key = (source || 'SNCF').toUpperCase();
      if (!numbersBySource.has(key)) numbersBySource.set(key, []);
      const list = numbersBySource.get(key);
      if (!list.includes(str)) list.push(str);
    };

    const delayKeySet = new Set();
    const delayKeyOrder = [];
    const pushDelayKey = (value)=>{
      if (value == null) return;
      if (Array.isArray(value)){
        for (const v of value) pushDelayKey(v);
        return;
      }
      const candidate = extractTrainNumberCandidate(value) ?? value;
      const normalized = normalizeTrainNumberKey(candidate);
      if (!normalized && normalized !== 0) return;
      const keyStr = String(normalized);
      if (!keyStr || delayKeySet.has(keyStr)) return;
      delayKeySet.add(keyStr);
      delayKeyOrder.push(keyStr);
    };

    for (const train of ordered){
      const entries = Array.isArray(train.numberList) && train.numberList.length
        ? train.numberList
        : [train.branding?.displayNumber || train.number || train.numberRaw];
      const mainEntry = entries.find(v => v && String(v).trim());
      if (mainEntry){
        addNumberForSource(train.source || 'SNCF', mainEntry);
      }
      for (const entry of entries){
        pushDisplay(entry);
      }
      pushDelayKey(train.delayNumberKeys);
      pushDelayKey(train.numberKey);
      pushDelayKey(train.numberDigits);
      pushDelayKey(train.number);
      pushDelayKey(train.numberRaw);
      pushDelayKey(train.branding?.digits);
    }

    const sncfNumbers = numbersBySource.get('SNCF') || [];
    const cflNumbers = numbersBySource.get('CFL') || [];
    const otherSourceNumbers = [];
    for (const [src, values] of numbersBySource.entries()){
      if (src === 'SNCF' || src === 'CFL') continue;
      for (const val of values){
        if (!otherSourceNumbers.includes(val)) otherSourceNumbers.push(val);
      }
    }

    const finalNumberList = [];
    const pushFinalNumber = (value)=>{
      if (!value) return;
      const str = String(value).trim();
      if (!str || finalNumberList.includes(str)) return;
      finalNumberList.push(str);
    };
    for (const val of sncfNumbers) pushFinalNumber(val);
    for (const val of cflNumbers) pushFinalNumber(val);
    for (const val of displayNumbers) pushFinalNumber(val);

    let combinedDisplay = '';
    if (sncfNumbers.length && cflNumbers.length){
      const used = new Set();
      const primarySncf = sncfNumbers[0];
      if (primarySncf){
        combinedDisplay = primarySncf;
        used.add(primarySncf);
      }
      const cflPart = [];
      for (const val of cflNumbers){
        const str = String(val).trim();
        if (!str || used.has(str)) continue;
        cflPart.push(str);
        used.add(str);
      }
      if (cflPart.length){
        combinedDisplay += ` (${cflPart.join(' / ')})`;
      }
      const trailingParts = [];
      for (const val of sncfNumbers.slice(1)){
        const str = String(val).trim();
        if (!str || used.has(str)) continue;
        trailingParts.push(str);
        used.add(str);
      }
      for (const val of otherSourceNumbers){
        const str = String(val).trim();
        if (!str || used.has(str)) continue;
        trailingParts.push(str);
        used.add(str);
      }
      for (const val of displayNumbers){
        const str = String(val).trim();
        if (!str || used.has(str)) continue;
        trailingParts.push(str);
        used.add(str);
      }
      if (trailingParts.length){
        combinedDisplay += ' / ' + trailingParts.join(' / ');
      }
    } else {
      combinedDisplay = displayNumbers.join(' / ');
    }

    if (!combinedDisplay && finalNumberList.length){
      combinedDisplay = finalNumberList.join(' / ');
    }

    merged.numberList = finalNumberList;
    if (combinedDisplay){
      merged.number = combinedDisplay;
      merged.numberRaw = combinedDisplay;
      merged.branding.displayNumber = combinedDisplay;
      merged.branding.panelTitle = combinedDisplay;
    }

    if (delayKeyOrder.length === 1){
      merged.numberDigits = delayKeyOrder[0];
      merged.branding.digits = delayKeyOrder[0];
    } else {
      if ('numberDigits' in merged) delete merged.numberDigits;
      if ('digits' in merged.branding) delete merged.branding.digits;
    }

    merged.delayNumberKeys = delayKeyOrder;
    if (delayKeyOrder.length){
      merged.numberKey = delayKeyOrder[0];
    }

    const priorityForDelay = (train)=>{
      const source = (train?.source || '').toUpperCase();
      if (source === 'SNCF') return 0;
      if (source === 'CFL') return 2;
      return 1;
    };

    const delaySource = ordered
      .slice()
      .sort((a,b)=> priorityForDelay(a) - priorityForDelay(b))
      .find(t => t.currentDelaySec != null);
    if (delaySource && delaySource.currentDelaySec != null){
      merged.currentDelaySec = delaySource.currentDelaySec;
    }

    merged.relatedTrainIds = merged.mergedTripIds.slice();
    return merged;
  }

  function mergeCrossBorderTrains(list){
    if (!Array.isArray(list) || list.length < 2) return list;
    const metaById = new Map();
    const groups = new Map();
    for (const train of list){
      const meta = computeTrainMergeMeta(train);
      if (!meta) continue;
      metaById.set(train.id, meta);
      if (!groups.has(meta.signature)) groups.set(meta.signature, []);
      groups.get(meta.signature).push(train);
    }

    if (!groups.size) return list;

    const consumed = new Set();
    const result = [];

    for (const train of list){
      if (consumed.has(train.id)){ continue; }
      const meta = metaById.get(train.id);
      const group = meta ? groups.get(meta.signature) : null;
      if (group && group.length > 1){
        const available = group.filter(t => !consumed.has(t.id));
        if (available.length > 1){
          const sources = new Set(available.map(t => (t.source || 'SNCF').toUpperCase()));
          if (sources.size > 1){
            let maxDistance = 0;
            for (let i=0;i<available.length;i++){
              for (let j=i+1;j<available.length;j++){
                const a = available[i];
                const b = available[j];
                const dist = approxDistanceKm(a.lat, a.lon, b.lat, b.lon);
                if (Number.isFinite(dist)){
                  if (dist > maxDistance) maxDistance = dist;
                }
              }
            }
            const distanceOk = maxDistance <= 15;
            let progressMismatch = false;
            const ref = available.find(t => t.progress != null && Number.isFinite(t.progress));
            if (ref){
              for (const other of available){
                if (other === ref || other.progress == null || !Number.isFinite(other.progress)) continue;
                if (Math.abs(other.progress - ref.progress) > 0.5){
                  progressMismatch = true;
                  break;
                }
              }
            }

            const staticKey = meta?.signature || null;
            const staticAlignment = staticKey && available.every(t => {
              const otherMeta = metaById.get(t.id);
              return otherMeta && otherMeta.signature === staticKey;
            });

            if ((distanceOk && !progressMismatch) || staticAlignment){
              const primary = selectPrimaryTrainForMerge(available);
              const orderedGroup = [primary, ...available.filter(t => t !== primary)];
              const merged = buildMergedTrain(orderedGroup);
              if (merged){
                result.push(merged);
                for (const member of orderedGroup){
                  consumed.add(member.id);
                }
                continue;
              }
            }
          }
        }
      }
      result.push(train);
      consumed.add(train.id);
    }

    return result;
  }

  function collectTrainNumberKeyEntries(train){
    if (!train) return [];
    const entries = [];
    const seen = new Set();
    const pushKey = (value, viaEquivalence = false)=>{
      if (value == null) return;
      if (Array.isArray(value)){
        for (const v of value) pushKey(v, viaEquivalence);
        return;
      }
      const candidate = extractTrainNumberCandidate(value) ?? value;
      const normalized = normalizeTrainNumberKey(candidate);
      if (normalized == null && normalized !== 0) return;
      const keyStr = String(normalized);
      if (!keyStr) return;
      const cacheKey = `${keyStr}:${viaEquivalence ? 'eq' : 'direct'}`;
      if (seen.has(cacheKey)) return;
      seen.add(cacheKey);
      entries.push({ key:keyStr, viaEquivalence });
      if (!viaEquivalence){
        for (const alt of equivalentTrainNumbers(keyStr)){
          const altStr = String(alt);
          if (!altStr) continue;
          const altCache = `${altStr}:eq`;
          if (seen.has(altCache)) continue;
          seen.add(altCache);
          entries.push({ key:altStr, viaEquivalence:true });
        }
      }
    };
    pushKey(train.numberKey);
    pushKey(train.delayNumberKeys);
    pushKey(train.numberDigits);
    pushKey(train.number);
    pushKey(train.numberRaw);
    pushKey(train.branding?.digits);
    pushKey(train.id);
    if (Array.isArray(train.numberList)){
      for (const val of train.numberList) pushKey(val);
    }
    return entries;
  }

  function scheduledStartReference(train){
    if (!train) return null;
    const candidates = [train.scheduledStartSec, train.startSec];
    for (const value of candidates){
      if (typeof value === 'number' && Number.isFinite(value)) return value;
    }
    return null;
  }

  function canOverrideProgressMismatchWithSncfSchedule(group){
    if (!Array.isArray(group) || group.length < 2) return false;
    const sncfEntries = group
      .map(train => ({ train, source: normalizedTrainSource(train), start: scheduledStartReference(train) }))
      .filter(entry => entry.source === 'SNCF' && entry.start != null);
    if (!sncfEntries.length) return false;
    const reference = sncfEntries.reduce((best, entry) => {
      if (!best) return entry;
      return entry.start < best.start ? entry : best;
    }, null);
    if (!reference) return false;
    const tolerance = 15 * 60; // 15 minutes pour les d√©parts align√©s
    for (const train of group){
      if (train === reference.train) continue;
      const candidate = scheduledStartReference(train);
      if (candidate == null) continue;
      if (Math.abs(candidate - reference.start) > tolerance) return false;
    }
    return true;
  }

  function shouldMergeNumberGroup(group, allowSameSource){
    if (!Array.isArray(group) || group.length < 2) return false;
    const sources = new Set(group.map(t => normalizedTrainSource(t)));
    const hasMixedSources = sources.size > 1;
    if (!hasMixedSources && !allowSameSource) return false;
    let progressMismatch = false;
    for (let i=0;i<group.length;i++){
      for (let j=i+1;j<group.length;j++){
        const a = group[i];
        const b = group[j];
        const dist = approxDistanceKm(a.lat, a.lon, b.lat, b.lon);
        if (!Number.isFinite(dist) || dist > 20) return false;
        if (a.progress != null && b.progress != null && Math.abs(a.progress - b.progress) > 0.5){
          progressMismatch = true;
        }
      }
    }
    if (progressMismatch){
      const canIgnoreMismatch = hasMixedSources && canOverrideProgressMismatchWithSncfSchedule(group);
      if (!canIgnoreMismatch) return false;
    }
    return true;
  }

  function mergeTrainsByNumber(list){
    if (!Array.isArray(list) || list.length < 2) return list;
    const buckets = new Map();
    const entriesById = new Map();
    const getEntries = (train)=>{
      if (entriesById.has(train.id)) return entriesById.get(train.id);
      const entries = collectTrainNumberKeyEntries(train);
      entriesById.set(train.id, entries);
      return entries;
    };

    for (const train of list){
      const entries = getEntries(train);
      for (const entry of entries){
        if (!entry?.key) continue;
        if (!buckets.has(entry.key)) buckets.set(entry.key, { trains:new Set(), viaEquivalence:false });
        const bucket = buckets.get(entry.key);
        bucket.trains.add(train);
        if (entry.viaEquivalence) bucket.viaEquivalence = true;
      }
    }

    if (!buckets.size) return list;
    const consumed = new Set();
    const result = [];

    for (const train of list){
      if (consumed.has(train.id)) continue;
      let mergedTrain = null;
      const entries = getEntries(train);
      for (const entry of entries){
        const bucket = buckets.get(entry.key);
        if (!bucket || !(bucket.trains instanceof Set) || bucket.trains.size < 2) continue;
        const group = Array.from(bucket.trains).filter(t => !consumed.has(t.id));
        if (group.length < 2) continue;
        if (!shouldMergeNumberGroup(group, bucket.viaEquivalence)) continue;
        const primary = selectPrimaryTrainForMerge(group);
        const ordered = [primary, ...group.filter(t => t !== primary)];
        const merged = buildMergedTrain(ordered);
        if (merged){
          mergedTrain = merged;
          for (const member of group){
            consumed.add(member.id);
          }
          bucket.trains = new Set();
          break;
        }
      }
      if (mergedTrain){
        result.push(mergedTrain);
      } else {
        consumed.add(train.id);
        result.push(train);
      }
    }

    return result;
  }

  function renderTrains(list){
  const layer = ensureTrainLayer();
    const seen = new Set();

    for (const t of list){
      seen.add(t.id);
      const delayInfo = computeTrainDelayInfo(t);
      t.delayInfo = delayInfo;
      const labelWithTrain = formatTrainLabel(t, { includeTrainWord:true, fallbackId:t.id });
      const displayName = t.headsign ? `${t.headsign} ‚Äî ${labelWithTrain}` : labelWithTrain;
      t.displayName = displayName;
      trainDataById.set(t.id, t);

      if (trainMarkers.has(t.id)){
        const marker = trainMarkers.get(t.id);
        marker.setLatLng([t.lat, t.lon]);
        marker.setIcon(iconForTrain(t));
        marker.setZIndexOffset(1000); // passer devant les couches vectorielles
        if (marker.getPopup()) marker.unbindPopup();
      } else {
        const m = L.marker([t.lat, t.lon], {
          icon: iconForTrain(t),
          zIndexOffset: 1000,       // au-dessus des lignes RFN/CFL
          riseOnHover: true,        // confort visuel
          keyboard: false
        });
        layer.addLayer(m);
        trainMarkers.set(t.id, m);
      }
    }

   // nettoyage des marqueurs disparus
    for (const [id,mk] of trainMarkers.entries()){
      if(!seen.has(id)){
        if (overlay.trains){
          overlay.trains.removeLayer(mk);
        }
        mk.remove();
        trainMarkers.delete(id);
        trainCowById.delete(id);
        trainDataById.delete(id);
        if (activeTripId === id){
          activeTripId = null;
          if (activeStationId){
            renderPanel();
          } else {
            hideTripPanel();
          }
        }
      }
    }

  if (activeStationId || (activeTripId && trainDataById.has(activeTripId))){
      renderPanel();
    }
    document.getElementById('counts').textContent = `${list.length} train(s) actifs`;
    document.getElementById('clock').textContent = 'Heure locale : ' + new Date().toLocaleTimeString();

    // --- Remont√©e vers le VPS toutes les 5 minutes ---
    const nowMs = Date.now();
    if (nowMs - lastCarteSeenPost >= CARTE_SEEN_INTERVAL_MS) {
      lastCarteSeenPost = nowMs;
      const visibleTrains = getVisibleTrainsForCarte();
      sendVisibleTrainTails(visibleTrains);
    }
  }

  // ---------- Boucle ----------
  let periodMs = 10000, nextTick = performance.now();
  const periodEl = document.getElementById('period'), hzEl=document.getElementById('hz'), smoothEl=document.getElementById('smooth');
  periodEl.addEventListener('input', ()=>{ hzEl.textContent=periodEl.value; periodMs=Number(periodEl.value)*1000; nextTick=performance.now(); });

  function tick(){ renderTrains(trainsAt(nowSecLocal())); }
  function loop(ts){
    if (ts >= nextTick){ tick(); nextTick = ts + periodMs; }
    if (smoothEl.checked) tick();
    requestAnimationFrame(loop);
  }

  runRealtimePrioritySelfTest();

  // ---------- Boot ----------
  (async function boot(){
    setRealtimeStatus('Retards temps r√©el : chargement‚Ä¶');
    const sncfPromise = loadSncfRealtime({ forceFresh: true }).catch(err => {
      console.error('[SNCF] √©chec initial', err);
      setRealtimeSourceError('sncf', 'indisponibles');
    });
    const sncfStatusPromise = loadSncfStatus().catch(err => console.warn('[SNCF] statut initial indisponible', err));
    const gtfsPromise = loadGtfsRetards({ forceFresh: true }).catch(err => {
      console.error('[GTFS-RT] √©chec initial', err);
      setRealtimeSourceError('gtfs', 'indisponibles');
    });
    const hafasPromise = loadHafasDelays().catch(err => {
      console.error('[HAFAS] √©chec initial', err);
      setRealtimeSourceError('hafas', 'indisponibles');
    });

    await Promise.all([
      loadNetworks(),
      loadGTFS()
    ]);
    tick();
    requestAnimationFrame(loop);

    gtfsPromise.finally(()=>{
      if (gtfsRtRefreshTimer == null){
        gtfsRtRefreshTimer = setInterval(()=>{
          loadGtfsRetards({ forceFresh: true }).catch(err => {
            console.warn('[GTFS-RT] rafra√Æchissement en √©chec', err);
            setRealtimeSourceError('gtfs', trainDelayLastUpdated ? 'rafra√Æchissement en √©chec' : 'indisponibles');
          });
        }, GTFS_RT_REFRESH_INTERVAL_MS);
      }
    });
    hafasPromise.finally(()=>{
      if (hafasRefreshTimer == null){
        hafasRefreshTimer = setInterval(()=>{
          loadHafasDelays().catch(err => {
            console.warn('[HAFAS] rafra√Æchissement en √©chec', err);
            setRealtimeSourceError('hafas', 'rafra√Æchissement en √©chec');
          });
        }, HAFAS_REFRESH_INTERVAL_MS);
      }
    });
    sncfPromise.finally(()=>{
      if (sncfRefreshTimer == null){
        sncfRefreshTimer = setInterval(()=>{
          loadSncfRealtime({ forceFresh: true }).catch(err => {
            console.warn('[SNCF] rafra√Æchissement en √©chec', err);
            const hadData = realtimeSources.sncf.lastUpdated != null;
            setRealtimeSourceError('sncf', hadData ? 'rafra√Æchissement en √©chec' : 'indisponibles');
          });
        }, SNCF_RT_REFRESH_INTERVAL_MS);
      }
    });
    sncfStatusPromise.finally(()=>{
      if (sncfStatusRefreshTimer == null){
        sncfStatusRefreshTimer = setInterval(()=>{
          loadSncfStatus().catch(err => console.warn('[SNCF] statut indisponible', err));
        }, SNCF_RT_STATUS_REFRESH_INTERVAL_MS);
      }
    });
  })().catch(e=> setStatus('Erreur initialisation: '+e.message, true));
  </script>
</body>
</html>
