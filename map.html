<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <title>Carte Nancy ↔ Luxembourg — Trains sur le tracé (sans shapes GTFS)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root{ color-scheme: dark; }
    body{ margin:0; background:#0b0f1a; color:#e0f0ff; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    header{ padding:10px 14px; background:#0e1726; border-bottom:1px solid #20324b; }
    #map{ height: calc(100vh - 110px); }
    .panel{ display:flex; gap:12px; align-items:center; padding:8px 14px; background:#0e1726; border-top:1px solid #20324b; flex-wrap:wrap;}
    .badge{ padding:2px 6px; border:1px solid #2a3b55; border-radius:6px; font-size:12px; }
    .muted{ opacity:.8; font-size:12px; }
    .ctrl{ display:flex; align-items:center; gap:8px; }
    .ctrl input[type="range"]{ width:160px; }
    .legend-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
    .dot-train{ background:#00f0ff; }
    .dot-gare{ background:#a0ff00; }
    .dot-rfn{ background:#00f0ff; }
    .dot-cfl{ background:#ff00e0; }
    .err{ color:#ffb4b4 }
  </style>
</head>
<body>
  <header>
    <div style="font-weight:700">Nancy ↔ Luxembourg — Trains sur le tracé RFN+CFL (GTFS statique, sans shapes)</div>
    <div class="muted">Les trains suivent le <b>corridor</b> construit depuis les GeoJSON RFN+CFL. Interpolation temporelle entre arrêts, position curviligne réelle sur la ligne.</div>
  </header>

  <div id="map"></div>

  <div class="panel">
    <span class="badge"><span class="legend-dot dot-rfn"></span>RFN</span>
    <span class="badge"><span class="legend-dot dot-cfl"></span>CFL</span>
    <span class="badge"><span class="legend-dot dot-gare"></span>Gares</span>
    <span class="badge"><span class="legend-dot dot-train"></span>Trains</span>
    <div class="ctrl">
      <label class="muted">Rafraîchissement: <span id="hz">10</span>s</label>
      <input id="period" type="range" min="1" max="30" step="1" value="10">
      <label class="muted"><input id="smooth" type="checkbox" checked> animation fluide</label>
    </div>
    <span id="clock" class="muted">—</span>
    <span id="counts" class="muted">—</span>
    <span id="status" class="muted"></span>
  </div>

  <!-- libs -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
  // ---------- Bases: 1) local /data/ , 2) GitHub RAW ----------
  const BASES = [
    location.origin + '/data/',
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/data/'
  ];

  // ---------- Fichiers attendus ----------
  const FILES = {
    // réseaux (noms selon ton repo)
    rfn:    'lignes-du-rfn.geojson',
    cfl:    'lignes_cfl.geojson',

    // GTFS requis / optionnels
    stops:        'stops.txt',
    stop_times:   'stop_times.txt',
    trips:        'trips.txt',          // optionnel
    routes:       'routes.txt',         // optionnel (pour labels)
    calendar_dates: 'calendar_dates.txt'// optionnel (filtrage jour)
  };

  // ---------- Helpers fetch multi-bases ----------
  function urlFor(name, baseIndex=0){ return BASES[baseIndex] + name; }

  async function fetchJSONAny(name){
    for (let i=0;i<BASES.length;i++){
      try { const r = await fetch(urlFor(name,i), {mode:'cors'}); if (r.ok) return await r.json(); } catch(_) {}
    }
    throw new Error('Introuvable: '+name);
  }

  async function fetchTextAny(name){
    for (let i=0;i<BASES.length;i++){
      try { const r = await fetch(urlFor(name,i), {mode:'cors'}); if (r.ok) return await r.text(); } catch(_) {}
    }
    throw new Error('Introuvable: '+name);
  }

  function parseCSVAny(name){
    return new Promise(async (resolve, reject) => {
      try {
        const csv = await fetchTextAny(name);
        Papa.parse(csv, { header:true, dynamicTyping:false, skipEmptyLines:true,
          complete: (res)=>resolve(res.data), error: reject
        });
      } catch(e){ reject(e); }
    });
  }

  function setStatus(msg, isErr=false){
    const el=document.getElementById('status');
    el.innerHTML = (isErr?'<span class="err">':'' ) + msg + (isErr?'</span>':'');
  }

  // ---------- Maths géo / utilitaires ----------
  const R = 6371000;
  function toXY(lat, lon, lat0){ const x=(lon*Math.PI/180)*Math.cos(lat0*Math.PI/180), y=(lat*Math.PI/180); return {x,y}; }
  function distLL(a,b){ const lat0=(a.lat+b.lat)/2; const A=toXY(a.lat,a.lon,lat0), B=toXY(b.lat,b.lon,lat0); const dx=B.x-A.x, dy=B.y-A.y; return Math.sqrt(dx*dx+dy*dy)*R; }
  function gtfsTimeToSec(t){ if(!t) return null; const [H,M,S]=t.split(':').map(Number); return H*3600+M*60+(S||0); }
  function nowSecLocal(){ const d=new Date(); return d.getHours()*3600 + d.getMinutes()*60 + d.getSeconds(); }
  function fmtMinSec(s){ const m=Math.floor(s/60), r=s%60; return `${m}m${String(r).padStart(2,'0')}s`; }

  // projection point -> segment de la polyline + curviligne
  function projectPointOnSeg(p,a,b){
    const lat0=(a.lat+b.lat)/2, P=toXY(p.lat,p.lon,lat0), A=toXY(a.lat,a.lon,lat0), B=toXY(b.lat,b.lon,lat0);
    const ABx=B.x-A.x, ABy=B.y-A.y, APx=P.x-A.x, APy=P.y-A.y, ab2=ABx*ABx+ABy*ABy;
    let t=ab2? (APx*ABx+APy*ABy)/ab2 : 0; t=Math.max(0,Math.min(1,t));
    const X=A.x+t*ABx, Y=A.y+t*ABy; const lon=X/Math.cos(lat0*Math.PI/180)*180/Math.PI, lat=Y*180/Math.PI;
    const dseg=distLL(a,{lat,lon}); return { t, d:dseg, point:{lat,lon} };
  }
  function pointAlong(shapePts, d){
    if(shapePts.length===0) return null;
    if(d<=0) return {lat:shapePts[0].lat, lon:shapePts[0].lon};
    if(d>=shapePts.at(-1).cum) return {lat:shapePts.at(-1).lat, lon:shapePts.at(-1).lon};
    let i=1; while(i<shapePts.length && shapePts[i].cum<d) i++;
    const B=shapePts[i], A=shapePts[i-1]; const r=(d-A.cum)/(B.cum-A.cum);
    return {lat:A.lat+r*(B.lat-A.lat), lon:A.lon+r*(B.lon-A.lon)};
  }

  // ---------- État données ----------
  const stopsById = new Map();              // stop_id -> {stop_id,name,lat,lon}
  const stopTimesByTrip = new Map();        // trip_id -> [ {stop_id, arr, dep, seq} ]
  const tripsById = new Map();              // (optionnel) trip_id -> {route_id, headsign, service_id}
  const routesById = new Map();             // (optionnel)
  let activeServiceIds = null;

  // Corridor + mapping arrêt -> distance curviligne
  let CORRIDOR = null;                 // [{lat,lon,cum}]
  const stopCurvDist = new Map();      // stop_id -> d (m)

  // ---------- Leaflet ----------
  const map = L.map('map').setView([49.2, 6.15], 9);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'© OpenStreetMap' }).addTo(map);
  const overlay = { rfn:null, cfl:null, garesGTFS:null, corridor:null };
  const trainMarkers = new Map();

  // zones d'intérêt (filtre "sillon" simple)
  const AXIS_STOP_KEYWORDS = ['nancy','pont-','metz','hagondange','thionville','bettembourg','luxembourg'];

  function tripPassesAxis(seq){
    const names = seq.map(s=> (stopsById.get(s.stop_id)?.name || '').toLowerCase());
    const hits = names.filter(n=> AXIS_STOP_KEYWORDS.some(k=> n.includes(k))).length;
    return hits >= 2;
  }
  function serviceAllowed(trip_id){
    if (!activeServiceIds || !tripsById.has(trip_id)) return true;
    const svc = tripsById.get(trip_id).service_id;
    if (!svc) return true;
    return activeServiceIds.has(svc);
  }

  // ---------- Charger GTFS (on a besoin des stops avant de bâtir le corridor) ----------
  async function loadGTFS(){
    try {
      // stops
      const stops = await parseCSVAny(FILES.stops);
      for (const s of stops){
        const lat=parseFloat(s.stop_lat), lon=parseFloat(s.stop_lon);
        if (!isFinite(lat)||!isFinite(lon)) continue;
        stopsById.set(s.stop_id, { stop_id:s.stop_id, name:s.stop_name, lat, lon });
      }

      // stop_times -> groupés par trip
      const stop_times = await parseCSVAny(FILES.stop_times);
      for (const st of stop_times){
        const tid = st.trip_id; if(!tid) continue;
        if (!stopTimesByTrip.has(tid)) stopTimesByTrip.set(tid, []);
        stopTimesByTrip.get(tid).push({
          stop_id: st.stop_id,
          arrival: gtfsTimeToSec(st.arrival_time),
          departure: gtfsTimeToSec(st.departure_time),
          seq: Number(st.stop_sequence)
        });
      }
      for (const [k,v] of stopTimesByTrip) v.sort((a,b)=>a.seq-b.seq);

      try {
        const trips = await parseCSVAny(FILES.trips);
        for (const t of trips){ tripsById.set(t.trip_id, { route_id:t.route_id, headsign:t.trip_headsign, service_id:t.service_id }); }
      } catch(_){ /* ok si absent */ }

      try {
        const routes = await parseCSVAny(FILES.routes);
        for (const r of routes){ routesById.set(r.route_id, { short:r.route_short_name, long:r.route_long_name }); }
      } catch(_){ /* ok si absent */ }

      try {
        const cdates = await parseCSVAny(FILES.calendar_dates);
        const today = new Date();
        const y = today.getFullYear();
        const m = String(today.getMonth()+1).padStart(2,'0');
        const d = String(today.getDate()).padStart(2,'0');
        const ymd = `${y}${m}${d}`;
        const add = new Set(), remove = new Set();
        for (const row of cdates){
          if (row.date !== ymd) continue;
          if (String(row.exception_type)==='1') add.add(row.service_id);
          if (String(row.exception_type)==='2') remove.add(row.service_id);
        }
        activeServiceIds = add.size? add : null;
      } catch(_){ /* ok */ }

      // Dessine les gares (GTFS)
      const gares = [];
      for (const s of stopsById.values()){ gares.push([s.lat, s.lon, s.name]); }
      overlay.garesGTFS = L.layerGroup(
        gares.map(([lat,lon,name])=>{
          const m=L.circleMarker([lat,lon],{radius:3, color:'#a0ff00', weight:1});
          m.bindTooltip(name, {permanent:false}); return m;
        })
      ).addTo(map);

      setStatus('GTFS chargé — ' + stopsById.size + ' gares, ' + stopTimesByTrip.size + ' trips.');
    } catch(e){
      setStatus('Erreur chargement GTFS: '+e.message, true);
    }
  }

  // ---------- Charger réseaux + construire le CORRIDOR continu ----------
  async function loadNetworksAndCorridor(){
    try {
      const [rfn, cfl] = await Promise.all([
        fetchJSONAny(FILES.rfn),
        fetchJSONAny(FILES.cfl).catch(()=>({type:'FeatureCollection',features:[]})) // CFL peut être absent
      ]);

      overlay.rfn = L.geoJSON(rfn, { style:{ color:'#00f0ff', weight:3, opacity:0.35 } }).addTo(map);
      let bounds = overlay.rfn.getBounds();
      if (cfl.features && cfl.features.length){
        overlay.cfl = L.geoJSON(cfl, { style:{ color:'#ff00e0', weight:3, opacity:0.35 } }).addTo(map);
        bounds.extend(overlay.cfl.getBounds());
      }
      map.fitBounds(bounds);

      // Construire le corridor: aplatir RFN+CFL -> points, ordonner le long de l'axe Nancy↔Lux, dédoublonner, cumuler
      function extractPoints(geo){
        const out = [];
        const pushLine = (coords)=>{
          for (let i=0;i<coords.length;i++){
            const [lon,lat] = coords[i];
            out.push({lat,lon});
            // densification légère si segments > 1500 m
            if (i>0){
              const prev = out[out.length-2];
              if (distLL(prev, {lat,lon}) > 1500) {
                out.splice(out.length-1, 0, { lat:(prev.lat+lat)/2, lon:(prev.lon+lon)/2 });
              }
            }
          }
        };
        for (const f of geo.features || []){
          const g = f.geometry; if (!g) continue;
          if (g.type==='LineString') pushLine(g.coordinates);
          else if (g.type==='MultiLineString'){ for (const ls of g.coordinates) pushLine(ls); }
        }
        return out;
      }

      const pts = [...extractPoints(rfn), ...extractPoints(cfl)];
      if (pts.length < 2) { setStatus('Corridor: aucun point (vérifie les GeoJSON)', true); return; }

      // Axe principal approximatif: utiliser deux stops emblématiques si dispo, sinon Nancy/Lux
      const axisStops = ['Nancy','Metz','Thionville','Bettembourg','Luxembourg'];
      const sample=[]; for (const s of stopsById.values()){ if (axisStops.some(k=> (s.name||'').toLowerCase().includes(k.toLowerCase()))) sample.push(s); }
      const Aref = sample[0] || {lat:48.6921, lon:6.1844};
      const Bref = sample.at(-1) || {lat:49.5998, lon:6.1333};
      const lat0 = (Aref.lat + Bref.lat)/2;
      const Axy = toXY(Aref.lat, Aref.lon, lat0), Bxy = toXY(Bref.lat, Bref.lon, lat0);
      const vABx = Bxy.x - Axy.x, vABy = Bxy.y - Axy.y, ab2 = vABx*vABx + vABy*vABy;

      function scoreOnAxis(p){
        const P = toXY(p.lat, p.lon, lat0);
        const APx = P.x - Axy.x, APy = P.y - Axy.y;
        return ab2 ? (APx*vABx + APy*vABy)/Math.sqrt(ab2) : 0;
      }

      pts.sort((p,q)=> scoreOnAxis(p) - scoreOnAxis(q));  // ordonner
      // dédoublonner (epsilon)
      const EPS = 60;
      const corridorPts = [];
      for (const p of pts){
        if (corridorPts.length===0) { corridorPts.push(p); continue; }
        const last = corridorPts[corridorPts.length-1];
        if (distLL(last, p) >= EPS) corridorPts.push(p);
      }
      // cumul
      let cum=0; CORRIDOR=[];
      for (let i=0;i<corridorPts.length;i++){
        if (i>0) cum += distLL(corridorPts[i-1], corridorPts[i]);
        CORRIDOR.push({ lat:corridorPts[i].lat, lon:corridorPts[i].lon, cum });
      }

      // afficher le corridor mis en avant
      overlay.corridor = L.polyline(CORRIDOR.map(p=>[p.lat,p.lon]), {color:'#00e3a1', weight:4, opacity:0.8}).addTo(map);

      // projeter chaque arrêt GTFS sur le corridor pour obtenir son abscisse curviligne "d"
      for (const s of stopsById.values()){
        let best={cum:0,dist:Infinity};
        for (let i=0;i<CORRIDOR.length-1;i++){
          const a=CORRIDOR[i], b=CORRIDOR[i+1];
          const proj=projectPointOnSeg({lat:s.lat,lon:s.lon}, a,b);
          if (proj.d < best.dist){
            best={ cum: a.cum + proj.t*(b.cum - a.cum), dist: proj.d };
          }
        }
        stopCurvDist.set(s.stop_id, best.cum);
      }

      setStatus('Corridor construit — points: '+CORRIDOR.length);
    } catch(e){
      setStatus('Erreur réseaux/corridor: '+e.message, true);
    }
  }

  // ---------- Calcul positions (curviligne sur corridor) ----------
  function trainsAt(nowSec){
    const items=[];
    for (const [trip_id, seq] of stopTimesByTrip.entries()){
      if (seq.length<2) continue;
      if (!tripPassesAxis(seq)) continue;
      if (!serviceAllowed(trip_id)) continue;

      const start = seq[0].departure ?? seq[0].arrival;
      const end   = seq.at(-1).arrival ?? seq.at(-1).departure;
      if (start==null || end==null || nowSec<start || nowSec>end) continue;

      for (let i=0;i<seq.length-1;i++){
        const A=seq[i], B=seq[i+1];
        const tA = A.departure ?? A.arrival;
        const tB = B.arrival   ?? B.departure;
        if (tA==null || tB==null || tB<=tA) continue;
        if (nowSec < tA || nowSec > tB) continue;

        const dA = stopCurvDist.get(A.stop_id);
        const dB = stopCurvDist.get(B.stop_id);
        if (dA==null || dB==null) continue;

        const r=(nowSec - tA)/(tB - tA); // 0..1
        const d = dA + r*(dB - dA);
        const pt = pointAlong(CORRIDOR, d);
        if (!pt) continue;

        const sA = stopsById.get(A.stop_id), sB = stopsById.get(B.stop_id);
        const trip = tripsById.get(trip_id) || {};
        const route = routesById.get(trip.route_id) || {};

        items.push({
          id: trip_id,
          headsign: trip.headsign || route.long || route.short || '',
          from: sA?.name || '—',
          to:   sB?.name || '—',
          etaSec: Math.max(0, Math.round(tB - nowSec)),
          lat: pt.lat, lon: pt.lon,
          route_id: trip.route_id
        });
        break;
      }
    }
    return items;
  }

  function renderTrains(list){
    const seen = new Set();
    for (const t of list){
      seen.add(t.id);
      const html = `<b>${t.headsign || t.id}</b><br/>${t.from} → ${t.to}<br/>ETA ~ ${fmtMinSec(t.etaSec)}${t.route_id?'<br/><span class="muted">route '+t.route_id+'</span>':''}`;
      if (trainMarkers.has(t.id)){
        trainMarkers.get(t.id).setLatLng([t.lat,t.lon]).setPopupContent(html);
      } else {
        const m = L.circleMarker([t.lat,t.lon], {radius:6, weight:1, color:'#00f0ff'}).addTo(map);
        m.bindPopup(html);
        trainMarkers.set(t.id, m);
      }
    }
    for (const [id,mk] of trainMarkers.entries()){ if(!seen.has(id)){ map.removeLayer(mk); trainMarkers.delete(id); } }
    document.getElementById('counts').textContent = `${list.length} train(s) actifs`;
    document.getElementById('clock').textContent = 'Heure locale : ' + new Date().toLocaleTimeString();
  }

  // ---------- Boucle ----------
  let periodMs = 10000, nextTick = performance.now();
  const periodEl = document.getElementById('period'), hzEl=document.getElementById('hz'), smoothEl=document.getElementById('smooth');
  periodEl.addEventListener('input', ()=>{ hzEl.textContent=periodEl.value; periodMs=Number(periodEl.value)*1000; nextTick=performance.now(); });

  function tick(){ renderTrains(trainsAt(nowSecLocal())); }
  function loop(ts){
    if (ts >= nextTick){ tick(); nextTick = ts + periodMs; }
    if (smoothEl.checked) tick();
    requestAnimationFrame(loop);
  }

  // ---------- Boot ----------
  (async function boot(){
    await loadGTFS();                // besoin des stops pour projeter ensuite
    await loadNetworksAndCorridor();// construit le corridor RFN+CFL + abscisses des arrêts
    if (!CORRIDOR){ setStatus('Impossible de construire le corridor.', true); return; }
    tick();
    requestAnimationFrame(loop);
  })().catch(e=> setStatus('Erreur initialisation: '+e.message, true));
  </script>
</body>
</html>
