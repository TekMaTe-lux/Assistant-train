<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trafic en temps réel - Nancy ⇄ Luxembourg</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha384-tAGcCf6YJ6ewH2s5t1lTdr3+/QAS+9eJPBq6tgzsPA1MbNEJTtQXk3DqyY+Ri0Gw" crossorigin="anonymous">
  <style>
    :root {
      color-scheme: dark light;
      --bg: #05060c;
      --panel: rgba(12, 17, 35, 0.92);
      --panel-border: rgba(0, 240, 255, 0.3);
      --accent: #00f0ff;
      --accent-strong: #ffb400;
      --text-primary: #eef6ff;
      --text-muted: #9fb5cc;
      --danger: #ff4d6d;
      --success: #3ddc97;
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
    }

    body {
      margin: 0;
      background: radial-gradient(circle at top, rgba(0, 240, 255, 0.2), transparent 45%),
                  radial-gradient(circle at bottom, rgba(255, 180, 0, 0.18), transparent 55%),
                  var(--bg);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1.5rem clamp(1.2rem, 3vw, 3rem);
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      position: relative;
      overflow: hidden;
    }

    header::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(0, 240, 255, 0.12), transparent 45%),
                  linear-gradient(300deg, rgba(255, 180, 0, 0.1), transparent 60%);
      pointer-events: none;
      z-index: 0;
    }

    header > * {
      position: relative;
      z-index: 1;
    }

    header h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-size: clamp(1.6rem, 3vw, 2.2rem);
    }

    header p {
      margin: 0;
      max-width: 60ch;
      color: var(--text-muted);
      line-height: 1.5;
      font-size: 0.95rem;
    }

    main {
      display: grid;
      grid-template-columns: minmax(0, 2fr) minmax(300px, 1fr);
      gap: clamp(1rem, 3vw, 2rem);
      padding: clamp(1rem, 2.5vw, 2.5rem);
      flex: 1;
      box-sizing: border-box;
    }

    .map-wrapper {
      position: relative;
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      overflow: hidden;
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.25);
      min-height: 480px;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .map-legend {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      background: rgba(4, 7, 18, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      border: 1px solid rgba(0, 240, 255, 0.25);
      padding: 0.85rem 1rem;
      font-size: 0.85rem;
      line-height: 1.4;
      color: var(--text-muted);
    }

    .map-legend ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.35rem;
    }

    .map-legend li span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .color-chip {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.45);
    }

    aside {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .panel {
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      padding: 1.2rem;
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.22);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      min-height: 120px;
    }

    .panel h2 {
      margin: 0;
      font-size: 1.15rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
    }

    .last-update {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .train-list {
      display: grid;
      gap: 0.75rem;
    }

    .train-card {
      background: rgba(3, 6, 18, 0.7);
      border-radius: 14px;
      border: 1px solid rgba(0, 240, 255, 0.2);
      padding: 0.95rem 1rem;
      display: grid;
      gap: 0.45rem;
    }

    .train-card.active {
      border-color: rgba(0, 240, 255, 0.5);
      box-shadow: 0 0 16px rgba(0, 240, 255, 0.25);
    }

    .train-header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.85rem;
      flex-wrap: wrap;
    }

    .train-route {
      font-weight: 600;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .train-progress {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      overflow: hidden;
    }

    .train-progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent-strong), var(--accent));
      transition: width 0.4s ease;
    }

    .train-times {
      display: flex;
      justify-content: space-between;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .empty-message {
      color: var(--text-muted);
      text-align: center;
      padding: 1.5rem 0.5rem;
      border: 1px dashed rgba(0, 240, 255, 0.25);
      border-radius: 14px;
    }

    .upcoming-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .error-banner {
      background: rgba(255, 77, 109, 0.15);
      border: 1px solid rgba(255, 77, 109, 0.4);
      border-radius: 12px;
      padding: 0.85rem 1rem;
      color: var(--danger);
      font-size: 0.9rem;
    }

    @media (max-width: 960px) {
      main {
        grid-template-columns: 1fr;
      }

      .map-wrapper {
        min-height: 380px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Corridor ferroviaire Nancy ⇄ Luxembourg</h1>
    <p>
      Visualisation en temps quasi-réel de la desserte TER entre Nancy et Luxembourg.
      Les tracés SNCF et CFL sont fusionnés sur la carte afin de représenter précisément
      l'itinéraire. Les positions des trains sont estimées par interpolation à partir des
      horaires GTFS publiés dans ce dépôt.
    </p>
  </header>
  <main>
    <section class="map-wrapper">
      <div id="map" role="presentation" aria-label="Carte du corridor ferroviaire Nancy - Luxembourg"></div>
      <div class="map-legend">
        <ul>
          <li><span><span class="color-chip" style="background:#00f0ff"></span> Lignes SNCF (GeoJSON RFN)</span></li>
          <li><span><span class="color-chip" style="background:#ff4d6d"></span> Lignes CFL (Shapefile)</span></li>
          <li><span><span class="color-chip" style="background:#ffb400"></span> Itinéraire Nancy ⇄ Luxembourg</span></li>
          <li><span><span class="color-chip" style="background:#3ddc97"></span> Trains estimés en circulation</span></li>
        </ul>
      </div>
    </section>
    <aside>
      <section class="panel">
        <h2>Suivi temps réel <span class="last-update" id="last-update">Chargement…</span></h2>
        <div id="loading-message" class="empty-message">Chargement des données d'horaires…</div>
        <div id="error-message" class="error-banner" style="display:none"></div>
        <div id="active-trains" class="train-list" aria-live="polite"></div>
        <div id="upcoming-trains" class="train-list"></div>
      </section>
    </aside>
  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha384-KZ8ailqXF/w3vGN9ofuUBev5nYeD1yfknhk+aoCA8Dm+5asJ5AZt0pOEtp5uWgLa" crossorigin="anonymous"></script>
  <script>
    const DAY_SECONDS = 86400;
    const BBOX = {
      minLat: 48.3,
      maxLat: 49.95,
      minLng: 5.5,
      maxLng: 6.6
    };

    function splitCsvLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
          if (char === '"') {
            if (i + 1 < line.length && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            current += char;
          }
        } else {
          if (char === '"') {
            inQuotes = true;
          } else if (char === ',') {
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
      }
      result.push(current);
      return result;
    }

    function parseCsv(text) {
      const trimmed = text.trim();
      if (!trimmed) return [];
      const lines = trimmed.split(/\r?\n/);
      const headers = splitCsvLine(lines[0]);
      const records = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const values = splitCsvLine(line);
        const entry = {};
        for (let j = 0; j < headers.length; j++) {
          entry[headers[j]] = values[j] ?? '';
        }
        records.push(entry);
      }
      return records;
    }

    function isPointInBbox(lat, lng) {
      return lat >= BBOX.minLat && lat <= BBOX.maxLat && lng >= BBOX.minLng && lng <= BBOX.maxLng;
    }

    function geometryToSegments(geometry) {
      if (!geometry) return [];
      const { type, coordinates } = geometry;
      if (type === 'LineString') {
        return [coordinates.map(([lng, lat]) => ({ lat, lng }))];
      }
      if (type === 'MultiLineString') {
        return coordinates.map(line => line.map(([lng, lat]) => ({ lat, lng })));
      }
      return [];
    }

    function featureIntersectsBbox(coords) {
      return coords.some(point => {
        if (Array.isArray(point)) {
          return featureIntersectsBbox(point);
        }
        return isPointInBbox(point.lat, point.lng);
      });
    }

    function haversineDistance(a, b) {
      const toRad = Math.PI / 180;
      const R = 6371000;
      const dLat = (b.lat - a.lat) * toRad;
      const dLng = (b.lng - a.lng) * toRad;
      const lat1 = a.lat * toRad;
      const lat2 = b.lat * toRad;
      const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.sqrt(h));
    }

    function buildContinuousPath(segments, startLatLng, endLatLng) {
      if (!segments.length) return [];
      const unused = segments.map(segment => segment.slice());
      const used = new Array(unused.length).fill(false);

      let bestIndex = -1;
      let bestDistance = Infinity;
      for (let i = 0; i < unused.length; i++) {
        const segment = unused[i];
        if (!segment.length) continue;
        const distStart = haversineDistance(startLatLng, segment[0]);
        const distEnd = haversineDistance(startLatLng, segment[segment.length - 1]);
        const candidate = Math.min(distStart, distEnd);
        if (candidate < bestDistance) {
          bestDistance = candidate;
          bestIndex = i;
        }
      }

      if (bestIndex === -1) {
        return [];
      }

      const path = [];
      let currentSegment = unused[bestIndex];
      if (haversineDistance(startLatLng, currentSegment[currentSegment.length - 1]) < haversineDistance(startLatLng, currentSegment[0])) {
        currentSegment = currentSegment.slice().reverse();
      }
      path.push(...currentSegment);
      used[bestIndex] = true;

      let extended = true;
      const tolerance = 1500; // mètres
      while (extended) {
        extended = false;
        const tail = path[path.length - 1];
        for (let i = 0; i < unused.length; i++) {
          if (used[i]) continue;
          const candidate = unused[i];
          if (!candidate.length) continue;
          const distStart = haversineDistance(tail, candidate[0]);
          const distEnd = haversineDistance(tail, candidate[candidate.length - 1]);
          if (distStart < tolerance || distEnd < tolerance) {
            let oriented = candidate;
            if (distEnd < distStart) {
              oriented = candidate.slice().reverse();
            }
            const nextPoints = oriented.slice(1);
            path.push(...nextPoints);
            used[i] = true;
            extended = true;
            break;
          }
        }
      }

      if (endLatLng) {
        const tail = path[path.length - 1];
        if (haversineDistance(tail, endLatLng) > tolerance) {
          for (let i = 0; i < unused.length; i++) {
            if (used[i]) continue;
            const candidate = unused[i];
            if (!candidate.length) continue;
            const distStart = haversineDistance(endLatLng, candidate[0]);
            const distEnd = haversineDistance(endLatLng, candidate[candidate.length - 1]);
            if (Math.min(distStart, distEnd) < tolerance) {
              let oriented = candidate;
              if (distStart > distEnd) {
                oriented = candidate.slice().reverse();
              }
              const nextPoints = oriented.slice(1);
              path.push(...nextPoints);
              used[i] = true;
            }
          }
        }
      }

      return path;
    }

    function createPolylineTools(latlngs) {
      if (latlngs.length < 2) {
        return null;
      }
      const rad = Math.PI / 180;
      const earthR = 6371000;
      const centerLat = latlngs.reduce((sum, p) => sum + p.lat, 0) / latlngs.length;
      const centerLatRad = centerLat * rad;
      const originLat = latlngs[0].lat * rad;
      const originLng = latlngs[0].lng * rad;

      function latLngToXY(point) {
        const latRad = point.lat * rad;
        const lngRad = point.lng * rad;
        return {
          x: earthR * (lngRad - originLng) * Math.cos(centerLatRad),
          y: earthR * (latRad - originLat)
        };
      }

      const xyPoints = latlngs.map(latLngToXY);
      const segments = [];
      let totalLength = 0;
      for (let i = 0; i < xyPoints.length - 1; i++) {
        const a = xyPoints[i];
        const b = xyPoints[i + 1];
        const length = Math.hypot(b.x - a.x, b.y - a.y);
        segments.push(length);
        totalLength += length;
      }

      function project(point) {
        const xyPoint = latLngToXY(point);
        let best = {
          distanceSquared: Infinity,
          distanceAlong: 0,
          latLng: latlngs[0],
          segmentIndex: 0,
          t: 0
        };
        let cumulative = 0;
        for (let i = 0; i < xyPoints.length - 1; i++) {
          const a = xyPoints[i];
          const b = xyPoints[i + 1];
          const segmentLength = segments[i];
          if (segmentLength === 0) {
            continue;
          }
          const vx = b.x - a.x;
          const vy = b.y - a.y;
          const wx = xyPoint.x - a.x;
          const wy = xyPoint.y - a.y;
          let t = (wx * vx + wy * vy) / (segmentLength * segmentLength);
          t = Math.max(0, Math.min(1, t));
          const projX = a.x + t * vx;
          const projY = a.y + t * vy;
          const dx = projX - xyPoint.x;
          const dy = projY - xyPoint.y;
          const distanceSquared = dx * dx + dy * dy;
          if (distanceSquared < best.distanceSquared) {
            best = {
              distanceSquared,
              distanceAlong: cumulative + t * segmentLength,
              latLng: {
                lat: latlngs[i].lat + t * (latlngs[i + 1].lat - latlngs[i].lat),
                lng: latlngs[i].lng + t * (latlngs[i + 1].lng - latlngs[i].lng)
              },
              segmentIndex: i,
              t
            };
          }
          cumulative += segmentLength;
        }
        return best;
      }

      function interpolate(distance) {
        if (distance <= 0) return latlngs[0];
        if (distance >= totalLength) return latlngs[latlngs.length - 1];
        let cumulative = 0;
        for (let i = 0; i < segments.length; i++) {
          const segLen = segments[i];
          if (cumulative + segLen >= distance) {
            const ratio = segLen === 0 ? 0 : (distance - cumulative) / segLen;
            return {
              lat: latlngs[i].lat + ratio * (latlngs[i + 1].lat - latlngs[i].lat),
              lng: latlngs[i].lng + ratio * (latlngs[i + 1].lng - latlngs[i].lng)
            };
          }
          cumulative += segLen;
        }
        return latlngs[latlngs.length - 1];
      }

      return {
        project,
        interpolate,
        totalLength
      };
    }

    function parseTimeToSeconds(value) {
      if (!value) return null;
      const parts = value.split(':').map(Number);
      if (parts.some(Number.isNaN)) return null;
      const [h, m = 0, s = 0] = parts;
      return h * 3600 + m * 60 + s;
    }

    function normalizeTripTimes(stopTimes) {
      let offset = 0;
      let lastTime = -Infinity;
      return stopTimes.map(stop => {
        const arrival = parseTimeToSeconds(stop.arrival_time);
        let arrivalSeconds = null;
        if (arrival !== null) {
          let candidate = arrival + offset;
          if (candidate < lastTime) {
            offset += DAY_SECONDS;
            candidate = arrival + offset;
          }
          arrivalSeconds = candidate;
          lastTime = candidate;
        }
        const departure = parseTimeToSeconds(stop.departure_time);
        let departureSeconds = null;
        if (departure !== null) {
          let candidate = departure + offset;
          if (candidate < lastTime) {
            offset += DAY_SECONDS;
            candidate = departure + offset;
          }
          departureSeconds = candidate;
          lastTime = candidate;
        }
        return {
          ...stop,
          arrival_seconds: arrivalSeconds,
          departure_seconds: departureSeconds
        };
      });
    }

    function formatTimeLabel(seconds) {
      if (seconds === null || seconds === undefined) {
        return '–';
      }
      const dayOffset = Math.floor(seconds / DAY_SECONDS);
      const withinDay = seconds - dayOffset * DAY_SECONDS;
      const hours = Math.floor(withinDay / 3600) % 24;
      const minutes = Math.floor((withinDay % 3600) / 60);
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}` + (dayOffset > 0 ? ` (+${dayOffset}j)` : '');
    }

    function minutesDiff(seconds) {
      return Math.round(seconds / 60);
    }

    function alignArrival(departure, arrival) {
      if (arrival === null) return null;
      let aligned = arrival;
      while (aligned < departure) {
        aligned += DAY_SECONDS;
      }
      return aligned;
    }

    function buildTrainCards(container, trains, options = {}) {
      container.innerHTML = '';
      if (!trains.length) {
        const empty = document.createElement('div');
        empty.className = 'empty-message';
        empty.textContent = options.emptyMessage || 'Aucun train en circulation sur ce créneau.';
        container.appendChild(empty);
        return;
      }
      for (const train of trains) {
        const card = document.createElement('article');
        card.className = 'train-card' + (options.highlight ? ' active' : '');
        const header = document.createElement('div');
        header.className = 'train-header';
        const route = document.createElement('span');
        route.className = 'train-route';
        route.textContent = train.label;
        const status = document.createElement('span');
        status.className = 'train-status';
        status.textContent = train.status;
        header.append(route, status);
        card.appendChild(header);
        if (train.description) {
          const descr = document.createElement('div');
          descr.textContent = train.description;
          descr.style.fontSize = '0.85rem';
          descr.style.color = 'var(--text-muted)';
          card.appendChild(descr);
        }
        const times = document.createElement('div');
        times.className = 'train-times';
        times.innerHTML = `<span>Départ Nancy : <strong>${train.departure}</strong></span><span>Arrivée Luxembourg : <strong>${train.arrival}</strong></span>`;
        card.appendChild(times);
        if (options.highlight) {
          const progress = document.createElement('div');
          progress.className = 'train-progress';
          const bar = document.createElement('span');
          bar.style.width = `${train.progress}%`;
          progress.appendChild(bar);
          card.appendChild(progress);
          const segment = document.createElement('div');
          segment.style.fontSize = '0.85rem';
          segment.style.color = 'var(--text-muted)';
          segment.textContent = train.segmentLabel;
          card.appendChild(segment);
        }
        container.appendChild(card);
      }
    }

    async function fetchJson(path) {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Impossible de charger ${path}: ${response.status}`);
      }
      return response.json();
    }

    async function loadSncfSegments() {
      const geojson = await fetchJson('data/lignes-du-rfn.geojson');
      const segments = [];
      for (const feature of geojson.features ?? []) {
        const geoSegments = geometryToSegments(feature.geometry);
        for (const segment of geoSegments) {
          if (featureIntersectsBbox(segment)) {
            segments.push(segment);
          }
        }
      }
      return { geojson, segments };
    }

    async function loadCflSegments() {
      const geojson = await fetchJson('data/lignes_cfl.geojson');
      const segments = [];
      for (const feature of geojson.features ?? []) {
        const geoSegments = geometryToSegments(feature.geometry);
        for (const segment of geoSegments) {
          if (featureIntersectsBbox(segment)) {
            segments.push(segment);
          }
        }
      }
      return { geojson, segments };
    }
    function prepareTrips({ trips, stopTimesMap, stopsById, routesById, metrics }) {
      const nancyStopIds = new Set();
      const luxStopIds = new Set();
      for (const stop of stopsById.values()) {
        const name = (stop.stop_name || '').toLowerCase();
        if (name === 'nancy') {
          nancyStopIds.add(stop.stop_id);
        }
        if (name === 'luxembourg') {
          luxStopIds.add(stop.stop_id);
        }
      }
      const relevantTrips = [];
      for (const trip of trips) {
        const sequence = stopTimesMap.get(trip.trip_id);
        if (!sequence || !sequence.length) continue;
        const ordered = normalizeTripTimes(sequence).sort((a, b) => Number(a.stop_sequence) - Number(b.stop_sequence));
        const nancyIndex = ordered.findIndex(stop => nancyStopIds.has(stop.stop_id));
        if (nancyIndex === -1) continue;
        let luxIndex = -1;
        for (let i = nancyIndex + 1; i < ordered.length; i++) {
          if (luxStopIds.has(ordered[i].stop_id)) {
            luxIndex = i;
            break;
          }
        }
        if (luxIndex === -1) continue;
        const subset = ordered.slice(nancyIndex, luxIndex + 1);
        const enhancedStops = [];
        let valid = true;
        for (const stop of subset) {
          const stopInfo = stopsById.get(stop.stop_id);
          if (!stopInfo) {
            valid = false;
            break;
          }
          const lat = Number(stopInfo.stop_lat);
          const lng = Number(stopInfo.stop_lon);
          if (Number.isNaN(lat) || Number.isNaN(lng)) {
            valid = false;
            break;
          }
          const projection = metrics.project({ lat, lng });
          enhancedStops.push({
            ...stop,
            stop_name: stopInfo.stop_name,
            stop_lat: lat,
            stop_lon: lng,
            distance_along: projection.distanceAlong,
            projected_latlng: projection.latLng
          });
        }
        if (!valid || enhancedStops.length < 2) continue;
        const route = routesById.get(trip.route_id) || {};
        const departureStop = enhancedStops[0];
        const arrivalStop = enhancedStops[enhancedStops.length - 1];
        const departureTime = departureStop.departure_seconds ?? departureStop.arrival_seconds;
        const arrivalTimeRaw = arrivalStop.arrival_seconds ?? arrivalStop.departure_seconds;
        const arrivalTime = alignArrival(departureTime ?? 0, arrivalTimeRaw ?? 0);
        relevantTrips.push({
          trip_id: trip.trip_id,
          route_id: trip.route_id,
          service_id: trip.service_id,
          headsign: trip.trip_headsign,
          route_short_name: route.route_short_name,
          route_long_name: route.route_long_name,
          color: route.route_color,
          stops: enhancedStops,
          departure_time: departureTime,
          arrival_time: arrivalTime,
          block_id: trip.block_id
        });
      }
      return relevantTrips;
    }

    function computeTrainStates(relevantTrips, nowSeconds) {
      const active = [];
      const upcoming = [];
      const horizon = 6 * 3600;
      for (const trip of relevantTrips) {
        if (trip.departure_time == null || trip.arrival_time == null) continue;
        let departure = trip.departure_time;
        let arrival = trip.arrival_time;
        if (arrival < departure) arrival += DAY_SECONDS;
        let departureAligned = departure;
        while (departureAligned - nowSeconds > DAY_SECONDS / 2) departureAligned -= DAY_SECONDS;
        while (nowSeconds - departureAligned > DAY_SECONDS / 2) departureAligned += DAY_SECONDS;
        let arrivalAligned = arrival;
        while (arrivalAligned < departureAligned) arrivalAligned += DAY_SECONDS;
        while (arrivalAligned - departureAligned > DAY_SECONDS * 1.5) arrivalAligned -= DAY_SECONDS;

        if (nowSeconds >= departureAligned && nowSeconds <= arrivalAligned) {
          const stops = trip.stops;
          let position = null;
          for (let i = 0; i < stops.length - 1; i++) {
            const current = stops[i];
            const next = stops[i + 1];
            const startTime = current.departure_seconds ?? current.arrival_seconds;
            let endTime = next.arrival_seconds ?? next.departure_seconds;
            if (startTime == null || endTime == null) continue;
            if (endTime < startTime) endTime += DAY_SECONDS;
            let startAligned = startTime;
            while (startAligned < departureAligned) startAligned += DAY_SECONDS;
            if (startAligned > nowSeconds) {
              startAligned -= DAY_SECONDS;
            }
            let endAligned = endTime;
            while (endAligned < startAligned) endAligned += DAY_SECONDS;
            if (nowSeconds <= endAligned) {
              const segmentDuration = endAligned - startAligned;
              const elapsed = Math.max(0, Math.min(segmentDuration, nowSeconds - startAligned));
              const ratio = segmentDuration > 0 ? elapsed / segmentDuration : 0;
              const startDistance = current.distance_along;
              const endDistance = next.distance_along;
              const distance = startDistance + ratio * (endDistance - startDistance);
              position = {
                latLng: null,
                ratio: Math.min(1, Math.max(0, ratio)),
                startStop: current,
                endStop: next,
                progress: ((nowSeconds - departureAligned) / (arrivalAligned - departureAligned)) * 100,
                distance
              };
              break;
            }
          }
          if (position) {
            active.push({ trip, position, departure: departureAligned, arrival: arrivalAligned });
          }
        } else {
          let nextDeparture = departureAligned;
          if (nextDeparture < nowSeconds) nextDeparture += DAY_SECONDS;
          const wait = nextDeparture - nowSeconds;
          if (wait >= 0 && wait <= horizon) {
            upcoming.push({ trip, wait, departure: nextDeparture, arrival: arrivalAligned + (nextDeparture - departureAligned) });
          }
        }
      }
      active.sort((a, b) => a.departure - b.departure);
      upcoming.sort((a, b) => a.wait - b.wait);
      return { active, upcoming };
    }

    function describeTrain(trip) {
      if (trip.route_short_name) {
        return `${trip.route_short_name} · ${trip.headsign || ''}`.trim();
      }
      if (trip.headsign) return trip.headsign;
      return `Course ${trip.trip_id}`;
    }

    function formatMinutes(minutes) {
      if (minutes <= 1) return 'Imminent';
      return `${minutes} min`;
    }

    function renderTrainPanels(state) {
      const activeContainer = document.getElementById('active-trains');
      const upcomingContainer = document.getElementById('upcoming-trains');
      const activeCards = state.active.map(entry => {
        const description = `${entry.position.startStop.stop_name} → ${entry.position.endStop.stop_name}`;
        return {
          label: describeTrain(entry.trip),
          status: 'En circulation',
          description,
          departure: formatTimeLabel(entry.trip.departure_time),
          arrival: formatTimeLabel(entry.trip.arrival_time),
          progress: Math.round(Math.min(100, Math.max(0, entry.position.progress))),
          segmentLabel: `Segment en cours : ${description}`
        };
      });
      buildTrainCards(activeContainer, activeCards, { highlight: true, emptyMessage: "Aucun train n'est en circulation pour le moment." });

      const upcomingCards = state.upcoming.slice(0, 6).map(entry => {
        const minutes = minutesDiff(entry.wait);
        return {
          label: describeTrain(entry.trip),
          status: `Départ dans ${formatMinutes(minutes)}`,
          departure: formatTimeLabel(entry.trip.departure_time),
          arrival: formatTimeLabel(entry.trip.arrival_time)
        };
      });
      if (upcomingCards.length) {
        const title = document.createElement('div');
        title.className = 'upcoming-title';
        title.textContent = 'Prochains départs';
        upcomingContainer.innerHTML = '';
        upcomingContainer.appendChild(title);
        const list = document.createElement('div');
        list.className = 'train-list';
        for (const card of upcomingCards) {
          const wrapper = document.createElement('div');
          wrapper.className = 'train-card';
          const header = document.createElement('div');
          header.className = 'train-header';
          const route = document.createElement('span');
          route.className = 'train-route';
          route.textContent = card.label;
          const status = document.createElement('span');
          status.textContent = card.status;
          status.style.color = 'var(--success)';
          header.append(route, status);
          wrapper.appendChild(header);
          const times = document.createElement('div');
          times.className = 'train-times';
          times.innerHTML = `<span>Départ Nancy : <strong>${card.departure}</strong></span><span>Arrivée Luxembourg : <strong>${card.arrival}</strong></span>`;
          wrapper.appendChild(times);
          list.appendChild(wrapper);
        }
        upcomingContainer.appendChild(list);
      } else {
        upcomingContainer.innerHTML = '';
      }
    }

    function updateMarkers(map, markers, state, metrics) {
      const activeIds = new Set(state.active.map(entry => entry.trip.trip_id));
      for (const [tripId, marker] of markers.entries()) {
        if (!activeIds.has(tripId)) {
          marker.remove();
          markers.delete(tripId);
        }
      }
      for (const entry of state.active) {
        const tripId = entry.trip.trip_id;
        const distance = entry.position.distance;
        const latLng = metrics.interpolate(distance);
        entry.position.latLng = latLng;
        if (markers.has(tripId)) {
          markers.get(tripId).setLatLng(latLng);
        } else {
          const marker = L.circleMarker(latLng, {
            radius: 7,
            weight: 2,
            color: '#3ddc97',
            fillColor: '#3ddc97',
            fillOpacity: 0.85
          }).addTo(map);
          marker.bindPopup(() => {
            const progress = Math.round(Math.min(100, Math.max(0, entry.position.progress)));
            return `<strong>${describeTrain(entry.trip)}</strong><br>` +
                   `Départ Nancy : ${formatTimeLabel(entry.trip.departure_time)}<br>` +
                   `Arrivée Luxembourg : ${formatTimeLabel(entry.trip.arrival_time)}<br>` +
                   `Progression estimée : ${progress}%`;
          });
          markers.set(tripId, marker);
        }
      }
    }

    async function loadStopTimes(path, activeTripIds) {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`Impossible de charger ${path}: ${response.status}`);
      }
      const text = await response.text();
      const lines = text.split(/\r?\n/);
      const headers = splitCsvLine(lines[0] || '');
      const stopTimesMap = new Map();
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line) continue;
        const values = splitCsvLine(line);
        const record = {};
        for (let j = 0; j < headers.length; j++) {
          record[headers[j]] = values[j] ?? '';
        }
        if (!activeTripIds.has(record.trip_id)) continue;
        const list = stopTimesMap.get(record.trip_id) ?? [];
        list.push(record);
        stopTimesMap.set(record.trip_id, list);
      }
      return stopTimesMap;
    }

    async function bootstrap() {
      const map = L.map('map', {
        zoomControl: true,
        preferCanvas: true
      }).setView([49.2, 6.1], 8);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const errorMessage = document.getElementById('error-message');
      const loadingMessage = document.getElementById('loading-message');
      const lastUpdate = document.getElementById('last-update');

      try {
        const stopsData = parseCsv(await (await fetch('data/stops.txt')).text());
        const stopsById = new Map(stopsData.map(stop => [stop.stop_id, stop]));
        const nancy = stopsData.find(stop => stop.stop_name === 'Nancy' && stop.location_type === '0');
        const luxembourg = stopsData.find(stop => stop.stop_name === 'Luxembourg' && stop.location_type === '0');
        if (!nancy || !luxembourg) {
          throw new Error("Impossible d'identifier les gares de Nancy et de Luxembourg dans stops.txt");
        }

        const [sncfData, cflData] = await Promise.allSettled([
          loadSncfSegments(),
          loadCflSegments()
        ]);

        const sncfSegments = sncfData.status === 'fulfilled' ? sncfData.value.segments : [];
        const cflSegments = cflData.status === 'fulfilled' ? cflData.value.segments : [];
        const allSegments = [...sncfSegments, ...cflSegments];
        const pathPoints = buildContinuousPath(allSegments, { lat: Number(nancy.stop_lat), lng: Number(nancy.stop_lon) }, { lat: Number(luxembourg.stop_lat), lng: Number(luxembourg.stop_lon) });
        if (!pathPoints.length) {
          throw new Error("Le tracé Nancy ⇄ Luxembourg n'a pas pu être reconstruit à partir des données GeoJSON.");
        }

        const baseLines = sncfData.status === 'fulfilled' ? L.geoJSON(sncfData.value.geojson, {
          filter: feature => geometryToSegments(feature.geometry).some(segment => featureIntersectsBbox(segment)),
          style: {
            color: '#00f0ff',
            weight: 2,
            opacity: 0.35
          }
        }).addTo(map) : null;

        if (cflData.status === 'fulfilled') {
          L.geoJSON(cflData.value.geojson, {
            filter: feature => geometryToSegments(feature.geometry).some(segment => featureIntersectsBbox(segment)),
            style: {
              color: '#ff4d6d',
              weight: 2,
              opacity: 0.45
            }
          }).addTo(map);
        }

        const itinerary = L.polyline(pathPoints, {
          color: '#ffb400',
          weight: 5,
          opacity: 0.9
        }).addTo(map);
        map.fitBounds(itinerary.getBounds(), { padding: [40, 40] });

        const metrics = createPolylineTools(pathPoints);
        if (!metrics) {
          throw new Error('Impossible de calculer les métriques du tracé Nancy ⇄ Luxembourg.');
        }

        const routes = parseCsv(await (await fetch('data/routes.txt')).text());
        const trips = parseCsv(await (await fetch('data/trips.txt')).text());
        const calendarDates = parseCsv(await (await fetch('data/calendar_dates.txt')).text());

        const routesById = new Map(routes.map(route => [route.route_id, route]));

        const activeServiceIds = new Set(trips.map(trip => trip.service_id));
        const today = new Date();
        const dateString = `${today.getFullYear()}${String(today.getMonth() + 1).padStart(2, '0')}${String(today.getDate()).padStart(2, '0')}`;
        for (const entry of calendarDates) {
          if (entry.date !== dateString) continue;
          if (entry.exception_type === '2') {
            activeServiceIds.delete(entry.service_id);
          }
          if (entry.exception_type === '1') {
            activeServiceIds.add(entry.service_id);
          }
        }

        const activeTrips = trips.filter(trip => activeServiceIds.has(trip.service_id));
        const stopTimesMap = await loadStopTimes('data/stop_times.txt', new Set(activeTrips.map(trip => trip.trip_id)));

        const relevantTrips = prepareTrips({
          trips: activeTrips,
          stopTimesMap,
          stopsById,
          routesById,
          metrics
        });

        if (!relevantTrips.length) {
          throw new Error("Aucun trajet Nancy ⇄ Luxembourg actif n'a été trouvé pour la date du jour.");
        }

        let lastState = null;
        const markers = new Map();

        function refresh() {
          const now = new Date();
          const base = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const nowSeconds = (now.getTime() - base.getTime()) / 1000;
          const state = computeTrainStates(relevantTrips, nowSeconds);
          renderTrainPanels(state);
          updateMarkers(map, markers, state, metrics);
          lastUpdate.textContent = `mise à jour ${now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' })}`;
          lastState = state;
          if (loadingMessage) {
            loadingMessage.style.display = 'none';
          }
        }

        refresh();
        setInterval(refresh, 60000);
        loadingMessage.style.display = 'none';
      } catch (error) {
        console.error(error);
        if (loadingMessage) {
          loadingMessage.style.display = 'none';
        }
        errorMessage.textContent = error.message;
        errorMessage.style.display = 'block';
      }
    }

    document.addEventListener('DOMContentLoaded', bootstrap);
  </script>
</body>
</html>
