<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Compteur des requêtes SNCF</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      color-scheme: dark;
      --bg: #050912;
      --panel: rgba(12, 22, 44, 0.85);
      --border: #00f0ff55;
      --accent: #00f0ff;
      --danger: #ff6b6b;
      --safe: #66ff99;
      --text: #e8f6ff;
      --muted: #9fb3c8;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Orbitron', system-ui, sans-serif;
      background: radial-gradient(circle at top, rgba(0, 240, 255, 0.08), transparent 60%), var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 32px 16px 48px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    header {
      width: min(960px, 100%);
      text-align: center;
      padding: 24px 18px;
      border-radius: 18px;
      border: 2px solid var(--border);
      background: var(--panel);
      box-shadow: 0 0 18px rgba(0, 240, 255, 0.22);
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(1.4rem, 3vw, 2.1rem);
      letter-spacing: 0.04em;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .grid {
      width: min(960px, 100%);
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .card {
      position: relative;
      padding: 22px 20px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(160deg, rgba(0, 240, 255, 0.08), transparent 70%), var(--panel);
      min-height: 180px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: inset 0 0 12px rgba(0, 240, 255, 0.25);
    }

    .card h2 {
      margin: 0;
      font-size: 1.05rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .metric {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin: 0;
    }

    .metric .value {
      font-size: inherit;
      color: inherit;
    }

    .metric .suffix {
      font-size: 0.6em;
      color: var(--muted);
      margin-left: 8px;
      letter-spacing: 0.08em;
    }

    .progress {
      position: relative;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(0, 240, 255, 0.12);
      overflow: hidden;
    }

    .progress-bar {
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      width: 0;
      transition: width 0.4s ease;
      background: linear-gradient(90deg, var(--accent), rgba(0, 240, 255, 0.2));
    }

    .progress-bar.danger {
      background: linear-gradient(90deg, var(--danger), rgba(255, 107, 107, 0.28));
    }

    .label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .details {
      width: min(960px, 100%);
      padding: 20px 20px 24px;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: var(--panel);
      display: grid;
      gap: 12px;
    }

    .details h3 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .details dl {
      margin: 0;
      display: grid;
      gap: 6px 16px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }

    .details dt {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .details dd {
      margin: 0;
      font-weight: 600;
    }

    .status {
      width: min(960px, 100%);
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status strong {
      color: var(--text);
      font-weight: 600;
    }

    .cta {
      width: min(960px, 100%);
      display: flex;
      justify-content: flex-end;
    }

    .cta a {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
    }

    .error {
      color: var(--danger);
    }
  </style>
</head>
<body>
  <header>
    <h1>Compteur des requêtes API SNCF</h1>
    <p>Suivi en temps réel du nombre d'appels effectués par le proxy partagé afin de respecter la limite quotidienne de 5000 requêtes et le quota long terme.</p>
  </header>

  <section class="grid">
    <article class="card">
      <h2>Utilisation du jour</h2>
      <p class="metric" id="dailyUsage">—</p>
      <div class="progress" aria-hidden="true">
        <div class="progress-bar" id="dailyProgress"></div>
      </div>
      <div class="label">
        <span>Utilisées</span>
        <span id="dailyRemaining">Limite 5000</span>
      </div>
    </article>

    <article class="card">
      <h2>Prévisions (J+8 → J+29)</h2>
      <p class="metric" id="longTermUsage">—</p>
      <div class="progress" aria-hidden="true">
        <div class="progress-bar" id="longTermProgress"></div>
      </div>
      <div class="label">
        <span>Utilisées</span>
        <span id="longTermRemaining">Limite 40</span>
      </div>
    </article>

    <article class="card">
      <h2>Cache actif</h2>
      <p class="metric"><span class="value" id="cacheCount">—</span><span class="suffix">entrées</span></p>
      <p class="label" id="lastRefresh">Dernière mise à jour —</p>
    </article>
  </section>

  <section class="details">
    <h3>Détails de suivi</h3>
    <dl>
      <dt>Jour courant (TZ Paris)</dt>
      <dd id="dayKey">—</dd>
      <dt>Prochaine remise à zéro</dt>
      <dd id="resetTime">—</dd>
      <dt>Horodatage de l'instantané</dt>
      <dd id="generatedAt">—</dd>
      <dt>Statut de la requête</dt>
      <dd id="statusText">—</dd>
    </dl>
  </section>

  <div class="status">
    <span id="errorMessage" class="error"></span>
    <strong id="autoRefresh">Actualisation automatique : 30&nbsp;s</strong>
  </div>

  <div class="cta">
    <a href="index.html">← Retour au comparatif</a>
  </div>

  <script>
    const dailyUsageEl = document.getElementById('dailyUsage');
    const dailyProgress = document.getElementById('dailyProgress');
    const dailyRemainingEl = document.getElementById('dailyRemaining');
    const longTermUsageEl = document.getElementById('longTermUsage');
    const longTermProgress = document.getElementById('longTermProgress');
    const longTermRemainingEl = document.getElementById('longTermRemaining');
    const cacheCountEl = document.getElementById('cacheCount');
    const dayKeyEl = document.getElementById('dayKey');
    const resetTimeEl = document.getElementById('resetTime');
    const generatedAtEl = document.getElementById('generatedAt');
    const statusTextEl = document.getElementById('statusText');
    const lastRefreshEl = document.getElementById('lastRefresh');
    const errorMessageEl = document.getElementById('errorMessage');
    const autoRefreshEl = document.getElementById('autoRefresh');

    const REFRESH_INTERVAL = 30000;
    const FALLBACK_RETRY_INTERVAL = 120000;
    const PLATFORM_LIMIT_MESSAGE = "Quota plateforme atteint, temporisation en cours…";
    let refreshTimer = null;

    function formatNumber(value) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return '—';
      }
      return new Intl.NumberFormat('fr-FR').format(value);
    }

    function formatDateTime(value, options = {}) {
      if (!value) return '—';
      try {
        const date = new Date(value);
        return new Intl.DateTimeFormat('fr-FR', {
          hour12: false,
          ...options,
        }).format(date);
      } catch (err) {
        return value;
      }
    }

    function computeResetTime(dayKey, timezone) {
      try {
        const [year, month, day] = dayKey.split('-').map(Number);
        if ([year, month, day].some(n => Number.isNaN(n))) return '—';
        const locale = new Intl.DateTimeFormat('fr-FR', {
          timeZone: timezone,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          day: '2-digit',
          month: '2-digit'
        });
        const date = new Date(Date.UTC(year, month - 1, day + 1));
        return locale.format(date);
      } catch (err) {
        return '—';
      }
    }

    function updateProgressBar(element, ratio) {
      const clamped = Math.min(Math.max(ratio, 0), 1);
      element.style.width = `${clamped * 100}%`;
      if (clamped >= 0.9) {
        element.classList.add('danger');
      } else {
        element.classList.remove('danger');
      }
    }

    function formatDelay(ms) {
      const totalSeconds = Math.max(1, Math.round(ms / 1000));
      if (totalSeconds < 60) {
        return `${totalSeconds} s`;
      }
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      if (minutes >= 60) {
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        if (remainingMinutes === 0) {
          return `${hours} h`;
        }
        return `${hours} h ${remainingMinutes} min`;
      }
      if (seconds === 0) {
        return `${minutes} min`;
      }
      return `${minutes} min ${seconds} s`;
    }

    function scheduleNextRefresh(delay) {
      if (refreshTimer) {
        clearTimeout(refreshTimer);
      }
      refreshTimer = setTimeout(loadStats, delay);
    }

    function updateUI(stats, meta = {}) {
      const { endpoint } = meta;
      const { dailyLimit, total, remaining, longTermLimit, longTerm, longTermRemaining, cacheSize, dayKey: key, generatedAt: instant, timezone } = stats;

      dailyUsageEl.textContent = `${formatNumber(total)} / ${formatNumber(dailyLimit)}`;
      dailyRemainingEl.textContent = `${formatNumber(remaining)} restantes`;
      updateProgressBar(dailyProgress, dailyLimit > 0 ? total / dailyLimit : 0);

      longTermUsageEl.textContent = `${formatNumber(longTerm)} / ${formatNumber(longTermLimit)}`;
      longTermRemainingEl.textContent = `${formatNumber(longTermRemaining)} restantes`;
      updateProgressBar(longTermProgress, longTermLimit > 0 ? longTerm / longTermLimit : 0);

      cacheCountEl.textContent = formatNumber(cacheSize);
      dayKeyEl.textContent = key || '—';
      generatedAtEl.textContent = formatDateTime(instant, {
        timeZone: timezone,
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });
      resetTimeEl.textContent = computeResetTime(key, timezone);
      const endpointHost = (() => {
        if (!endpoint) return null;
        try {
          const parsed = new URL(endpoint, window.location.href);
          return parsed.host === window.location.host ? 'origine locale' : parsed.host;
        } catch (err) {
          return null;
        }
      })();

      const timeLabel = formatDateTime(Date.now(), {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });

      lastRefreshEl.textContent = endpointHost
        ? `Dernière mise à jour — ${timeLabel} (${endpointHost})`
        : `Dernière mise à jour — ${timeLabel}`;
      document.title = `SNCF ${formatNumber(total)} / ${formatNumber(dailyLimit)}`;
    }
const SNCF_STATS_HOST = (() => {
      const params = new URLSearchParams(window.location.search);
      const forcedHost = params.get('host');
      if (forcedHost) {
        try {
          const coerced = new URL(forcedHost, window.location.origin);
          return coerced.origin;
        } catch (err) {
          console.warn('Paramètre "host" invalide, ignoré.', err);
        }
      }

      const { hostname, origin, protocol } = window.location;
      const normaliseOrigin = candidate => {
        if (!candidate) return '';
        try {
          const url = new URL(candidate, `${protocol}//${hostname}`);
          return url.origin;
        } catch (err) {
          console.warn('Origine invalide pour les stats SNCF', candidate, err);
          return '';
        }
      };
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return origin;
      }

      if (hostname.endsWith('labetaillere.fr')) {
        return origin;
      }

      if (hostname.endsWith('.github.io')) {
        return 'https://labetaillere.fr';
      }
      if (hostname.endsWith('.vercel.app')) {
        return origin;
      }
      return normaliseOrigin('https://labetaillere.fr');
    })();

    function getStatsEndpoints() {
      const primary = SNCF_STATS_HOST
        ? `${SNCF_STATS_HOST.replace(/\/$/, '')}/api/sncf-stats`
        : '/api/sncf-stats';
      const fallbacks = [
        'https://labetaillere.fr/api/sncf-stats',
        'https://assistant-train-cx5u.vercel.app/api/sncf-stats'
      ];
      const unique = new Set([primary, ...fallbacks]);
      return Array.from(unique).filter(Boolean);
    }

    function parseRetryAfter(headerValue) {
      if (!headerValue) return null;
      const numeric = Number.parseFloat(headerValue);
      if (Number.isFinite(numeric) && numeric >= 0) {
        return numeric;
      }
      const date = Date.parse(headerValue);
      if (!Number.isNaN(date)) {
        const diff = Math.round((date - Date.now()) / 1000);
        return diff > 0 ? diff : null;
      }
      return null;
    }

    async function buildHttpError(response, url) {
      const error = new Error(`Statut ${response.status}`);
      error.status = response.status;
      error.url = url;
      const retryAfterHeader = response.headers.get('retry-after');
      const retryAfterSeconds = parseRetryAfter(retryAfterHeader);
      if (retryAfterSeconds != null) {
        error.retryAfterSeconds = retryAfterSeconds;
      }
      const contentType = response.headers.get('content-type') || '';
      if (contentType.includes('application/json')) {
        try {
          error.payload = await response.json();
        } catch (parseErr) {
          console.warn('Impossible d\'analyser la réponse JSON', parseErr);
        }
      } else {
        try {
          error.body = await response.text();
        } catch (textErr) {
          console.warn('Impossible de lire la réponse texte', textErr);
        }
      }
      return error;
    }

    async function fetchStatsWithFallback() {
      const endpoints = getStatsEndpoints();
      let lastError = null;
      for (const url of endpoints) {
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) {
            lastError = await buildHttpError(response, url);
            continue;
          }
          return { payload: await response.json(), url };
        } catch (err) {
          lastError = err;
        }
      }
      throw lastError || new Error('Aucun point de terminaison API disponible');
    }

    function describeHostFromUrl(url) {
      if (!url) return null;
      try {
        const parsed = new URL(url, window.location.href);
        return parsed.host;
      } catch (err) {
        return null;
      }
    }

    function buildErrorMessage(err) {
      if (!err) return 'Dernière tentative échouée, nouvel essai automatique…';
      const parts = [];
      if (err.status) {
        parts.push(`Réponse HTTP ${err.status}`);
      }
      if (err.payload && typeof err.payload.error === 'string') {
        parts.push(err.payload.error);
      } else if (err.body) {
        parts.push(err.body.slice(0, 160));
      }
      const host = describeHostFromUrl(err.url);
      if (host) {
        parts.push(`(${host})`);
      }
      if (err.status === 429 && (!err.payload || !err.payload.policy)) {
        parts.push('Limite Vercel atteinte (100 requêtes / jour).');
      }
      const message = parts.filter(Boolean).join(' — ');
      return message || 'Dernière tentative échouée, nouvel essai automatique…';
    }

    function computeRetryDelay(err) {
      if (!err) return REFRESH_INTERVAL;
      if (err.retryAfterSeconds != null) {
        return Math.max(err.retryAfterSeconds * 1000, REFRESH_INTERVAL);
      }
      if (err.status === 429) {
        return FALLBACK_RETRY_INTERVAL;
      }
      return REFRESH_INTERVAL;
    }
    
    async function loadStats() {
      try {
        statusTextEl.textContent = 'Mise à jour…';
        const { payload, url } = await fetchStatsWithFallback();
        updateUI(payload, { endpoint: url });
        statusTextEl.textContent = 'En ligne';
        errorMessageEl.textContent = '';
        autoRefreshEl.textContent = `Actualisation automatique : ${formatDelay(REFRESH_INTERVAL)}`;
        scheduleNextRefresh(REFRESH_INTERVAL);
      } catch (err) {
        console.error('Impossible de charger les stats SNCF', err);
        statusTextEl.textContent = 'Erreur';
        const retryDelay = computeRetryDelay(err);
        errorMessageEl.textContent = buildErrorMessage(err);
        if (retryDelay !== REFRESH_INTERVAL) {
          autoRefreshEl.textContent = `Nouvel essai dans ${formatDelay(retryDelay)}`;
        } else {
          autoRefreshEl.textContent = `Actualisation automatique : ${formatDelay(REFRESH_INTERVAL)}`;
        }
        if (err && err.status === 429 && (!err.payload || !err.payload.policy)) {
          errorMessageEl.textContent += ` ${PLATFORM_LIMIT_MESSAGE}`;
        }
        scheduleNextRefresh(retryDelay);
      }
    }

    loadStats();
  </script>
</body>
</html>
