<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Labétaillère — Simulation fréquentation TER (avec biais de quai)</title>

  <style>
    :root{
      --bg:#0b1220;
      --card:#121b2f;
      --panel:#0e1730;
      --txt:#e9eefc;
      --muted:#a8b3d6;
      --line:#263455;
      --shadow: 0 10px 25px rgba(0,0,0,.25);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 600px at 20% 0%, rgba(79,70,229,.15), transparent 50%),
                  radial-gradient(900px 500px at 80% 10%, rgba(34,197,94,.10), transparent 55%),
                  var(--bg);
      color:var(--txt);
    }
    header{
      padding:18px 16px;
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(6px);
      background: rgba(11,18,32,.75);
      position: sticky;
      top:0;
      z-index:10;
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(14,23,48,.6);
      padding:4px 10px;
      border-radius:999px;
    }
    header p{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:16px;
      display:grid;
      grid-template-columns: 430px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns:1fr; }
      header{ position:relative; }
    }

    .card{
      background: linear-gradient(180deg, rgba(18,27,47,.95), rgba(18,27,47,.85));
      border:1px solid rgba(38,52,85,.9);
      border-radius:16px;
      padding:14px;
      box-shadow: var(--shadow);
    }
    .card h2{
      margin:0 0 10px;
      font-size:13px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.25px;
      text-transform: uppercase;
    }

    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:10px 0 6px;
    }
    input, select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(38,52,85,.9);
      background: rgba(14,23,48,.85);
      color:var(--txt);
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    input[type="range"]{ padding:0; height: 28px; }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .small{
      font-size:11px;
      color:rgba(168,179,214,.9);
      margin-top:6px;
      line-height:1.35;
    }

    .btns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:12px;
    }
    button{
      border:1px solid rgba(38,52,85,.9);
      background: rgba(14,23,48,.9);
      color:var(--txt);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:900;
      transition: transform .08s ease, filter .12s ease;
    }
    button:hover{ filter:brightness(1.18); }
    button:active{ transform: translateY(1px); }

    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:12px;
    }
    .kpi .box{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(38,52,85,.9);
      background: rgba(14,23,48,.85);
    }
    .kpi .v{
      font-size:18px;
      font-weight:950;
      letter-spacing:.2px;
    }
    .kpi .t{
      font-size:11px;
      color:var(--muted);
      margin-top:4px;
      line-height:1.2;
    }

    .divider{
      height:1px;
      background: rgba(38,52,85,.9);
      margin:12px 0;
    }

    .note{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
      margin-top:10px;
    }

    canvas{ width:100%; max-height:320px; }

    /* Train viz */
    #trainVizWrap{
      border:1px solid rgba(38,52,85,.9);
      background: rgba(14,23,48,.65);
      border-radius:16px;
      padding:12px;
      overflow:auto;
    }
    #trainLegend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .legendItem{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(14,23,48,.6);
    }
    .swatch{
      width:14px; height:14px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.20);
    }
  </style>
</head>

<body>
<header>
  <h1>
    Labétaillère — Fréquentation par voiture (biais “Metz/Lux” + nez/queue)
    <span class="pill">US/UM/UM3</span>
    <span class="pill">nez & queue biseautés</span>
  </h1>
  <p>
    Objectif: représenter la rame schématiquement et simuler une répartition réaliste.
    Exemple: à Metz, les gens montent plus dans le 1er wagon; en arrivant à Luxembourg, le positionnement quai pousse à se regrouper.
  </p>
</header>

<div class="wrap">
  <!-- LEFT: controls -->
  <section class="card">
    <h2>Paramètres</h2>

    <label>Heure de départ</label>
    <input id="time" type="time" value="07:20" />

    <div class="row">
      <div>
        <label>Type de jour</label>
        <select id="dayType">
          <option value="weekday" selected>Semaine (lun–ven)</option>
          <option value="saturday">Samedi</option>
          <option value="sunday">Dimanche</option>
          <option value="holiday">Jour férié</option>
        </select>
      </div>
      <div>
        <label>Saison</label>
        <select id="season">
          <option value="normal" selected>Normal</option>
          <option value="vacances">Vacances</option>
        </select>
      </div>
    </div>

    <label>Sens (important pour “tête/queue”)</label>
    <select id="direction">
      <option value="NANCY_LUX" selected>Nancy → Luxembourg</option>
      <option value="LUX_NANCY">Luxembourg → Nancy</option>
    </select>
    <div class="small">Le nez/queue et les biais “quai” s’appliquent selon le sens.</div>

    <label>Composition (voitures)</label>
    <select id="formation">
      <option value="3" selected>US — 3 voitures</option>
      <option value="6">UM — 6 voitures</option>
      <option value="9">UM3 — 9 voitures</option>
    </select>

    <div class="row">
      <div>
        <label>Capacité / voiture</label>
        <input id="capPerCar" type="number" min="80" max="260" value="160" />
      </div>
      <div>
        <label>Demande base (creuse)</label>
        <input id="baseDemand" type="number" min="0" max="4000" value="220" />
      </div>
    </div>

    <label>Intensité des pointes (multiplicateur max)</label>
    <input id="peakBoost" type="range" min="1" max="6" step="0.1" value="3.2" />
    <div class="small">Valeur: <b><span id="peakBoostVal">3.2</span>x</b></div>

    <label>Aléa (bruit) ± %</label>
    <input id="noisePct" type="range" min="0" max="30" step="1" value="10" />
    <div class="small">Valeur: <b>±<span id="noisePctVal">10</span>%</b></div>

    <div class="divider"></div>

    <h2 style="margin-top:0;">Biais “quai” (Metz / Luxembourg)</h2>

    <label>Biais Metz (pointe) → favorise le 1er wagon (%)</label>
    <input id="metzBias" type="range" min="0" max="60" step="1" value="25" />
    <div class="small">+<b><span id="metzBiasVal">25</span>%</b> sur la voiture “préférée” à Metz en heure de pointe.</div>

    <label>Biais Luxembourg (arrivée) → effet “remonter le quai” (%)</label>
    <input id="luxBias" type="range" min="0" max="60" step="1" value="18" />
    <div class="small">+<b><span id="luxBiasVal">18</span>%</b> sur un côté du train (selon sens).</div>

    <label>Effet “pointe” sur la répartition (0 = uniforme, 1 = très marqué)</label>
    <input id="peakDistribution" type="range" min="0" max="1" step="0.05" value="0.65" />
    <div class="small">Valeur: <b><span id="peakDistributionVal">0.65</span></b></div>

    <div class="btns">
      <button id="runOnce">Simuler 1 fois</button>
      <button id="run100">Simuler 100 fois (moyenne)</button>
    </div>

    <div class="kpi">
      <div class="box">
        <div class="v" id="kpiTotal">—</div>
        <div class="t">Demande totale estimée</div>
      </div>
      <div class="box">
        <div class="v" id="kpiMaxLoad">—</div>
        <div class="t">Charge max (segment affiché)</div>
      </div>
    </div>

    <div class="note">
      Ici on modélise ce que tu décris:
      <ul style="margin:8px 0 0; padding-left:18px; color:var(--muted);">
        <li>Metz pousse les montées vers une extrémité (configuration quai / accès).</li>
        <li>Luxembourg pousse à se regrouper (remonter le quai / correspondances).</li>
        <li>Effet plus fort en pointe (matin/soir).</li>
      </ul>
    </div>
  </section>

  <!-- RIGHT: outputs -->
  <section class="card">
    <h2>Rendu</h2>

    <div id="trainVizWrap">
      <div id="trainViz"></div>
      <div id="trainLegend"></div>
    </div>

    <div style="height:12px"></div>
    <canvas id="barChart"></canvas>
    <div class="note" id="diagnostic">—</div>
  </section>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  // ---------- helpers ----------
  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function randn(){
    let u=0,v=0;
    while(u===0) u=Math.random();
    while(v===0) v=Math.random();
    return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
  }
  function timeToMinutes(t){
    const [hh,mm]=t.split(":").map(Number);
    return hh*60+mm;
  }
  function gaussian(x,mu,sigma){
    const z=(x-mu)/sigma;
    return Math.exp(-0.5*z*z);
  }
  function isPeak(minutes){
    // pointes: 06:00–09:00 et 16:00–19:30
    const m1 = minutes >= 6*60 && minutes <= 9*60;
    const m2 = minutes >= 16*60 && minutes <= 19*60 + 30;
    return m1 || m2;
  }

  function dayFactor(dayType){
    switch(dayType){
      case "weekday": return 1.00;
      case "saturday": return 0.78;
      case "sunday": return 0.62;
      case "holiday": return 0.70;
      default: return 1.00;
    }
  }
  function seasonFactor(season){
    return (season==="vacances") ? 0.85 : 1.00;
  }
  function hourFactor(minutes, peakBoost){
    const morning = gaussian(minutes, 7*60+30, 55);
    const evening = gaussian(minutes, 17*60+30, 65);
    const base = 0.55;
    const peak = (morning + evening);
    return clamp(base + (peakBoost-1)*peak, 0.35, peakBoost);
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ---------- color scale ----------
  function loadToColor(pct){
    const p = Math.max(0, Math.min(160, pct));
    if(p < 40)  return "#22c55e";
    if(p < 70)  return "#a3e635";
    if(p < 90)  return "#facc15";
    if(p < 105) return "#fb923c";
    if(p < 125) return "#ef4444";
    return "#a855f7";
  }

  // ---------- Distribution bias model ----------
  // On part d'une répartition "naturelle" (un peu de hasard),
  // puis on applique:
  // - biais Metz en pointe vers une voiture préférée
  // - biais Luxembourg en pointe/arrivée vers une voiture préférée
  // - intensité du biais augmente si c'est une heure de pointe
  function biasedWeights(cars, minutes, direction, metzBiasPct, luxBiasPct, peakDistribution){
    // base weights (légère variabilité)
    const base = [];
    for(let i=0;i<cars;i++){
      base.push(clamp(1 + 0.08*randn(), 0.75, 1.25));
    }

    const peak = isPeak(minutes) ? 1 : 0;
    const peakStrength = peakDistribution * peak; // 0..1

    // Quelle voiture est "préférée" à Metz ?
    // Hypothèse (modifiable):
    // - si sens Nancy→Lux : à Metz, les gens montent plus côté "tête" (voiture 1)
    // - si sens Lux→Nancy : à Metz, ça favorise l'autre extrémité (dernière voiture)
    const metzPreferredIndex = (direction === "NANCY_LUX") ? 0 : (cars-1);

    // Quelle voiture est "préférée" à Luxembourg ?
    // Tu dis: à Lux les gens doivent remonter le quai (donc ils se regroupent vers un côté).
    // Hypothèse: si on arrive à Lux (sens Nancy→Lux), ça favorise la tête (voiture 1).
    // Si on part de Lux (sens Lux→Nancy), ça favorise la tête dans l'autre sens => donc dernière voiture.
    const luxPreferredIndex = (direction === "NANCY_LUX") ? 0 : (cars-1);

    // Application des biais en pointe (plus tu es en pointe, plus c'est marqué)
    const metzBoost = 1 + (metzBiasPct/100) * peakStrength;
    const luxBoost  = 1 + (luxBiasPct/100)  * peakStrength;

    base[metzPreferredIndex] *= metzBoost;
    base[luxPreferredIndex]  *= luxBoost;

    // Petite "pénalité" légère sur l'autre extrémité si biais fort
    // (pour matérialiser “moins de monde dans le dernier wagon”)
    const oppositeMetz = cars-1-metzPreferredIndex;
    base[oppositeMetz] *= (1 - 0.20 * (metzBiasPct/100) * peakStrength);

    const oppositeLux = cars-1-luxPreferredIndex;
    base[oppositeLux] *= (1 - 0.12 * (luxBiasPct/100) * peakStrength);

    // Clamp pour éviter n'importe quoi
    for(let i=0;i<cars;i++) base[i] = clamp(base[i], 0.55, 2.2);

    // normalisation
    const sum = base.reduce((a,b)=>a+b,0) || 1;
    return base.map(w => w/sum);
  }

  function splitPassengersPerCar(totalOnboard, weights){
    const cars = weights.length;
    const raw = weights.map(w => totalOnboard * w);
    const arr = raw.map(x => Math.floor(x));
    // distribue le reste pour arriver au total exact
    let rem = totalOnboard - arr.reduce((a,b)=>a+b,0);
    const idx = [...Array(cars).keys()].sort((i,j)=> raw[j]-raw[i]);
    let k=0;
    while(rem>0){
      arr[idx[k % cars]] += 1;
      rem--; k++;
    }
    return arr;
  }

  // ---------- simulation ----------
  function simulate(cfg){
    const minutes = timeToMinutes(cfg.time);
    const hf = hourFactor(minutes, cfg.peakBoost);
    const df = dayFactor(cfg.dayType);
    const sf = seasonFactor(cfg.season);
    const noise = clamp(1 + (cfg.noisePct/100) * 0.45 * randn(), 0.75, 1.35);

    const total = Math.max(0, Math.round(cfg.baseDemand * hf * df * sf * noise));

    // Pour le prototype, on affiche "segment max" = total à bord
    // (tu pourras remettre tes segments Nancy→Metz / Metz→Lux après)
    const onboard = total;

    // weights biaisés
    const weights = biasedWeights(
      cfg.cars,
      minutes,
      cfg.direction,
      cfg.metzBiasPct,
      cfg.luxBiasPct,
      cfg.peakDistribution
    );

    const perCar = splitPassengersPerCar(onboard, weights);

    const capTrain = cfg.cars * cfg.capPerCar;
    const loadPct = capTrain > 0 ? 100*onboard/capTrain : 0;

    return { total, onboard, perCar, capTrain, loadPct };
  }

  function meanSim(cfg, n){
    const acc = {
      total:0, onboard:0, loadPct:0,
      perCar: Array(cfg.cars).fill(0),
      capTrain: cfg.cars * cfg.capPerCar
    };
    for(let k=0;k<n;k++){
      const r = simulate(cfg);
      acc.total += r.total;
      acc.onboard += r.onboard;
      acc.loadPct += r.loadPct;
      for(let i=0;i<cfg.cars;i++) acc.perCar[i] += r.perCar[i];
    }
    acc.total = Math.round(acc.total/n);
    acc.onboard = Math.round(acc.onboard/n);
    acc.loadPct = acc.loadPct/n;
    acc.perCar = acc.perCar.map(x => Math.round(x/n));
    return acc;
  }

  // ---------- SVG train with beveled head+tail ----------
  // head = voiture 1 côté direction
  // tail = dernière voiture côté opposé
  function renderTrainCarsBeveled({ cars, capPerCar, perCarPassengers, directionLabel }){
    const el = document.getElementById("trainViz");
    const leg = document.getElementById("trainLegend");
    if(!el || !leg) return;

    const wCar = 160, hCar = 66, gap = 10, pad = 14;
    const width = pad*2 + cars*wCar + (cars-1)*gap;
    const height = 138;
    const topY = 44;

    // direction: NANCY→LUX => head on RIGHT (towards Lux) ? ou head on LEFT ?
    // Visuellement, on choisit simple:
    // - Si Nancy→Lux : on dessine le nez à droite (sens de lecture gauche→droite)
    // - Si Lux→Nancy : nez à gauche
    const headOnRight = (directionLabel === "NANCY_LUX");

    const loads = perCarPassengers.map(v => capPerCar>0 ? (100*v/capPerCar) : 0);

    // Une voiture biseautée se dessine en "path" plutôt qu'un rect
    // leftBevel / rightBevel
    function carPath(x,y,w,h,bevelLeft,bevelRight){
      const b = 18; // profondeur biseau
      const r = 14; // arrondi
      // On fait un polygone arrondi "à la main" simplifié via path
      // (assez propre pour un schéma)
      const x0=x, y0=y, x1=x+w, y1=y+h;

      const leftTip  = bevelLeft  ? (x0 + b) : x0;
      const rightTip = bevelRight ? (x1 - b) : x1;

      return `
        M ${leftTip} ${y0}
        Q ${leftTip - (bevelLeft?8:0)} ${y0} ${x0 + r} ${y0}
        L ${rightTip - r} ${y0}
        Q ${rightTip} ${y0} ${rightTip} ${y0 + r}
        L ${rightTip} ${y1 - r}
        Q ${rightTip} ${y1} ${rightTip - r} ${y1}
        L ${leftTip + r} ${y1}
        Q ${leftTip} ${y1} ${leftTip} ${y1 - r}
        L ${leftTip} ${y0 + r}
        Q ${leftTip} ${y0} ${leftTip + r} ${y0}
        Z
      `;
    }

    let svg = `
    <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="shine" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="rgba(255,255,255,.22)"/>
          <stop offset="1" stop-color="rgba(255,255,255,0)"/>
        </linearGradient>
        <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="6" stdDeviation="6" flood-color="rgba(0,0,0,.35)"/>
        </filter>
      </defs>

      <text x="10" y="22" fill="rgba(233,238,252,.9)"
            font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial"
            font-size="12" font-weight="900">
        Schéma rame (${cars} voitures) — sens: ${headOnRight ? "→" : "←"}
      </text>

      <!-- rails -->
      <line x1="10" y1="118" x2="${width-10}" y2="118" stroke="rgba(168,179,214,.25)" stroke-width="3"/>
      <line x1="10" y1="128" x2="${width-10}" y2="128" stroke="rgba(168,179,214,.15)" stroke-width="2"/>

      <!-- arrow direction -->
      <text x="${width-28}" y="22" fill="rgba(168,179,214,.8)"
            font-family="system-ui" font-size="14" font-weight="900">
        ${headOnRight ? "→" : "←"}
      </text>
    `;

    for(let i=0;i<cars;i++){
      const x = pad + i*(wCar+gap);
      const y = topY;

      // biseau selon position + sens
      const isFirst = (i===0);
      const isLast  = (i===cars-1);

      // Si nez à droite:
      // - voiture de tête = dernière (biseau à droite)
      // - voiture de queue = première (biseau à gauche)
      // Sinon inversé
      const bevelLeft  = headOnRight ? isFirst : isLast;
      const bevelRight = headOnRight ? isLast  : isFirst;

      const pct = loads[i];
      const fill = loadToColor(pct);

      const path = carPath(x,y,wCar,hCar, bevelLeft, bevelRight);

      const wheelY = y + hCar + 12;
      const wheel1 = x + 36;
      const wheel2 = x + wCar - 36;

      svg += `
        <g filter="url(#softShadow)">
          <path d="${path}" fill="${fill}" stroke="rgba(255,255,255,.22)" stroke-width="2"/>
          <path d="${path}" fill="url(#shine)"/>

          <!-- fenêtres -->
          <rect x="${x+20}" y="${y+18}" width="${wCar-40}" height="16" rx="6" fill="rgba(11,18,32,.45)"/>

          <!-- portes -->
          <rect x="${x+10}" y="${y+12}" width="14" height="${hCar-24}" rx="5" fill="rgba(11,18,32,.25)"/>
          <rect x="${x+wCar-24}" y="${y+12}" width="14" height="${hCar-24}" rx="5" fill="rgba(11,18,32,.25)"/>

          <text x="${x+12}" y="${y-10}" fill="rgba(233,238,252,.8)"
                font-family="system-ui" font-size="11" font-weight="900">Voiture ${i+1}</text>

          <text x="${x+20}" y="${y+54}" fill="rgba(11,18,32,.85)"
                font-family="system-ui" font-size="12" font-weight="950">${Math.round(pct)}%</text>
          <text x="${x+64}" y="${y+54}" fill="rgba(11,18,32,.75)"
                font-family="system-ui" font-size="11" font-weight="900">${perCarPassengers[i]} / ${capPerCar}</text>

          <!-- roues -->
          <circle cx="${wheel1}" cy="${wheelY}" r="7" fill="rgba(168,179,214,.35)"/>
          <circle cx="${wheel2}" cy="${wheelY}" r="7" fill="rgba(168,179,214,.35)"/>
        </g>
      `;
    }

    svg += `</svg>`;
    el.innerHTML = svg;

    leg.innerHTML = `
      <div class="legendItem"><span class="swatch" style="background:#22c55e"></span> <span>&lt; 40% (cool)</span></div>
      <div class="legendItem"><span class="swatch" style="background:#facc15"></span> <span>70–90% (ok)</span></div>
      <div class="legendItem"><span class="swatch" style="background:#fb923c"></span> <span>90–105% (debout)</span></div>
      <div class="legendItem"><span class="swatch" style="background:#ef4444"></span> <span>105–125% (chaud)</span></div>
      <div class="legendItem"><span class="swatch" style="background:#a855f7"></span> <span>&gt; 125% (sardines)</span></div>
    `;
  }

  // ---------- chart ----------
  let barChart;
  function initChart(){
    const ctx = document.getElementById("barChart").getContext("2d");
    barChart = new Chart(ctx, {
      type: 'bar',
      data: { labels: [], datasets: [{ label: "Occupation par voiture — %", data: [] }] },
      options: {
        responsive:true,
        plugins:{ legend:{ labels:{ color:"#e9eefc" } } },
        scales:{
          x:{ ticks:{ color:"#a8b3d6" }, grid:{ color:"rgba(38,52,85,.6)" } },
          y:{ ticks:{ color:"#a8b3d6" }, grid:{ color:"rgba(38,52,85,.6)" }, beginAtZero:true, suggestedMax:140 }
        }
      }
    });
  }

  // ---------- UI ----------
  const $ = (id)=>document.getElementById(id);

  const peakBoost = $("peakBoost");
  const noisePct = $("noisePct");
  const metzBias = $("metzBias");
  const luxBias = $("luxBias");
  const peakDistribution = $("peakDistribution");

  peakBoost.addEventListener("input", ()=> $("peakBoostVal").textContent = peakBoost.value);
  noisePct.addEventListener("input", ()=> $("noisePctVal").textContent = noisePct.value);
  metzBias.addEventListener("input", ()=> $("metzBiasVal").textContent = metzBias.value);
  luxBias.addEventListener("input", ()=> $("luxBiasVal").textContent = luxBias.value);
  peakDistribution.addEventListener("input", ()=> $("peakDistributionVal").textContent = peakDistribution.value);

  function readCfg(){
    return {
      time: $("time").value || "07:20",
      dayType: $("dayType").value,
      season: $("season").value,
      direction: $("direction").value,
      cars: parseInt($("formation").value,10),
      capPerCar: parseInt($("capPerCar").value,10) || 160,
      baseDemand: parseInt($("baseDemand").value,10) || 220,
      peakBoost: parseFloat($("peakBoost").value),
      noisePct: parseInt($("noisePct").value,10),
      metzBiasPct: parseInt($("metzBias").value,10),
      luxBiasPct: parseInt($("luxBias").value,10),
      peakDistribution: parseFloat($("peakDistribution").value),
    };
  }

  function render(cfg, res, label){
    $("kpiTotal").textContent = `${res.total} voyageurs`;
    $("kpiMaxLoad").textContent = `${Math.round(res.loadPct)}%`;

    // chart data
    barChart.data.labels = Array.from({length: cfg.cars}, (_,i)=>`Voiture ${i+1}`);
    barChart.data.datasets[0].data = res.perCar.map(v => cfg.capPerCar>0 ? Math.round(100*v/cfg.capPerCar) : 0);
    barChart.update();

    renderTrainCarsBeveled({
      cars: cfg.cars,
      capPerCar: cfg.capPerCar,
      perCarPassengers: res.perCar,
      directionLabel: cfg.direction
    });

    const pct = res.loadPct;
    let msg;
    if(pct < 55) msg = "Confort tranquille.";
    else if(pct < 85) msg = "Charge correcte.";
    else if(pct < 105) msg = "Zone orange : debout probable.";
    else msg = "Saturation probable : sardines 2 étages.";
    $("diagnostic").innerHTML =
      `<b>${label}</b> — Capacité train: <b>${res.capTrain}</b> (= ${cfg.capPerCar}×${cfg.cars}). `
      + `À bord: <b>${res.onboard}</b>. ${msg}`;
  }

  $("runOnce").addEventListener("click", ()=>{
    const cfg = readCfg();
    const r = simulate(cfg);
    render(cfg, r, "Simulation 1 tirage");
  });

  $("run100").addEventListener("click", ()=>{
    const cfg = readCfg();
    const r = meanSim(cfg, 100);
    render(cfg, r, "Moyenne (100 tirages)");
  });

  // init
  initChart();
  (() => {
    const cfg = readCfg();
    const r = meanSim(cfg, 60);
    render(cfg, r, "Prévisualisation (60 tirages)");
  })();
</script>
</body>
</html>
