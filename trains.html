<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>La B√©taill√®re ‚Äî G√©n√©rateur JSON (GTFS static + compo)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0f18;color:#e8eefc}
    header{padding:18px 16px;border-bottom:1px solid rgba(255,255,255,.08);background:#0a0e16;position:sticky;top:0;z-index:10}
    h1{margin:0;font-size:18px;letter-spacing:.3px}
    main{padding:16px;max-width:980px;margin:0 auto}
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px;margin:12px 0}
    label{display:block;font-size:12px;opacity:.85;margin:10px 0 6px}
    input,select,button,textarea{
      width:100%;box-sizing:border-box;border-radius:12px;border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);color:#e8eefc;padding:10px 12px;font-size:14px;outline:none
    }
    button{cursor:pointer;font-weight:700;background:linear-gradient(180deg,rgba(76,175,80,.25),rgba(76,175,80,.12))}
    button:disabled{opacity:.5;cursor:not-allowed}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .small{font-size:12px;opacity:.8;line-height:1.35}
    .log{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;
      background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px;min-height:140px}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.14);font-size:12px;opacity:.9}
    .ok{color:#8bff9a;border-color:rgba(139,255,154,.35)}
    .warn{color:#ffd38b;border-color:rgba(255,211,139,.35)}
    .bad{color:#ff8b8b;border-color:rgba(255,139,139,.35)}
    code{background:rgba(255,255,255,.08);padding:1px 6px;border-radius:6px}
  </style>
</head>
<body>
<header>
  <h1>üêÇ La B√©taill√®re ‚Äî G√©n√©rateur <span class="pill">resolved_trains_YYYY-MM-DD.json</span></h1>
</header>

<main>
  <div class="card">
    <div class="row">
      <div>
        <label>Date (Luxembourg)</label>
        <input id="ymd" type="date"/>
      </div>
      <div>
        <label>Corridor (filtre de gares)</label>
        <select id="corridor">
          <option value="BER">#BER Nancy‚ÄìMetz‚ÄìThionville‚ÄìLux</option>
          <option value="ALL">Tout (plus lourd)</option>
        </select>
      </div>
    </div>

    <label>Base GTFS statique (test√©e dans l‚Äôordre)</label>
    <textarea id="bases" rows="5"></textarea>

    <label>URL Compotrains.json (optionnel mais recommand√©)</label>
    <input id="compoUrl" type="text"/>

    <div class="small" style="margin-top:10px">
      Ce g√©n√©rateur fonctionne <b>sans calendar.txt</b> (ton GTFS utilise <code>calendar_dates.txt</code>).<br/>
      Fichiers requis dans chaque base : <code>stops.txt</code>, <code>trips.txt</code>, <code>stop_times.txt</code>, <code>calendar_dates.txt</code>.
    </div>

    <div class="row3" style="margin-top:12px">
      <button id="btnTest">üîé Tester les bases</button>
      <button id="btnGenerate">‚öôÔ∏è G√©n√©rer & t√©l√©charger le JSON</button>
      <button id="btnSample">‚ú® Aper√ßu (10 trains)</button>
    </div>
  </div>

  <div class="card">
    <div class="small">
      <span class="pill ok">OK</span> = base trouv√©e & fichiers charg√©s ‚Ä¢
      <span class="pill warn">WARN</span> = base trouv√©e mais compo absente (fallback US) ‚Ä¢
      <span class="pill bad">ERR</span> = aucun GTFS accessible (URL/CORS/fichiers).
    </div>
    <div id="status" class="small" style="margin:10px 0"></div>
    <div id="log" class="log"></div>
  </div>
</main>

<script>
/* =========================
   DEFAULT BASES (inclut ton VPS en premier)
   ========================= */
function defaultBases(){
  const here = location.href;
  const u = (rel)=> new URL(rel, here).href;
  return [
    'https://vps.labetaillere.fr/gtfs/static/',  // ‚úÖ TON VPS (valid√©)
    u('data/'),
    u('Assistant-train/data/'),
    'https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/Assistant-train/data/',
    'https://cdn.jsdelivr.net/gh/TekMaTe-lux/Assistant-train@main/Assistant-train/data/'
  ];
}

// ‚úÖ TON GTFS: pas de calendar.txt
const GTFS_FILES_REQUIRED = ['stops.txt','trips.txt','stop_times.txt','calendar_dates.txt'];

/* =========================
   UI helpers
   ========================= */
const $ = (id)=>document.getElementById(id);
function setStatus(html){ $('status').innerHTML = html; }
function logLine(msg){ $('log').textContent += ($('log').textContent ? '\n' : '') + msg; }
function clearLog(){ $('log').textContent=''; }
function ymdToday(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const da = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${da}`;
}
function compactYMD(ymd){ return String(ymd||'').replace(/-/g,''); }
function downloadJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
}
function setBusy(on){
  $('btnTest').disabled = on;
  $('btnGenerate').disabled = on;
  $('btnSample').disabled = on;
}

/* =========================
   CSV parser (support guillemets)
   ========================= */
function parseCSV(text){
  const rows = [];
  let i=0, field='', row=[], inQ=false;
  const pushField=()=>{ row.push(field); field=''; };
  const pushRow=()=>{ rows.push(row); row=[]; };
  const s = text.replace(/^\uFEFF/,'');
  while (i < s.length){
    const ch = s[i];
    if (inQ){
      if (ch === '"'){
        if (s[i+1] === '"'){ field+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      }
      field+=ch; i++; continue;
    } else {
      if (ch === '"'){ inQ=true; i++; continue; }
      if (ch === ','){ pushField(); i++; continue; }
      if (ch === '\r'){
        pushField(); pushRow();
        if (s[i+1] === '\n') i+=2; else i++;
        continue;
      }
      if (ch === '\n'){ pushField(); pushRow(); i++; continue; }
      field+=ch; i++; continue;
    }
  }
  if (field.length || row.length){ pushField(); }
  if (row.length) pushRow();

  const header = rows.shift() || [];
  const out = [];
  for (const r of rows){
    if (!r.length) continue;
    const obj = {};
    for (let k=0;k<header.length;k++){
      obj[header[k]] = (r[k] ?? '');
    }
    out.push(obj);
  }
  return out;
}

async function fetchText(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return await res.text();
}

/* =========================
   Base picker (log fichier par fichier)
   ========================= */
async function tryBase(base){
  const data = {};
  const errors = [];
  for (const f of GTFS_FILES_REQUIRED){
    const url = base + f;
    try{
      const txt = await fetchText(url);
      data[f] = parseCSV(txt);
      logLine(`   ‚úÖ ${f} (${data[f].length} lignes)`);
    } catch(e){
      errors.push({ file: f, url, err: e?.message || String(e) });
      logLine(`   ‚ùå ${f} -> ${e?.message || e}`);
    }
  }
  if (errors.length){
    const msg = errors.map(x => `${x.file}: ${x.err}`).join(' | ');
    throw new Error(`Base incompl√®te: ${msg}`);
  }
  return data;
}

async function pickWorkingBase(bases){
  let lastErr = null;
  for (const bRaw of bases){
    const b = bRaw.endsWith('/') ? bRaw : (bRaw + '/');
    try{
      logLine(`‚Üí test base: ${b}`);
      const gtfs = await tryBase(b);
      logLine(`‚úÖ OK: ${b}`);
      return { base: b, gtfs };
    } catch(e){
      lastErr = e;
      logLine(`‚úñ fail: ${b} :: ${e?.message || e}`);
    }
  }
  throw lastErr || new Error('Aucune base GTFS accessible');
}

/* =========================
   Core logic
   ========================= */
function extractTrainNumber(trip){
  const candidates = [trip.trip_short_name, trip.trip_headsign, trip.trip_id].filter(Boolean).map(String);
  for (const s of candidates){
    const m = s.match(/(?:^|[^0-9])(8\d{4,5})(?!\d)/);
    if (m) return m[1];
  }
  return null;
}

function unitsToWagons(units){
  if (units === 'UM') return 6;
  if (units === 'UM3') return 9;
  return 3; // US / inconnu
}

function buildStopNameById(stops){
  const map = new Map();
  for (const s of stops){
    if (s.stop_id && s.stop_name) map.set(s.stop_id, s.stop_name);
  }
  return map;
}

function buildStopTimesByTrip(stopTimes){
  const map = new Map();
  for (const st of stopTimes){
    const tid = st.trip_id;
    if (!tid) continue;
    if (!map.has(tid)) map.set(tid, []);
    map.get(tid).push(st);
  }
  for (const [tid, list] of map){
    list.sort((a,b)=>Number(a.stop_sequence||0)-Number(b.stop_sequence||0));
  }
  return map;
}

// ‚úÖ IMPORTANT: sans calendar.txt, on utilise calendar_dates.txt uniquement.
// On indexe les dates d'exception_type=1 (service actif ce jour-l√†).
function buildCalendarDatesActiveIndex(calendarDates){
  const map = new Map(); // service_id -> Set(YYYYMMDD)
  for (const cd of calendarDates){
    const sid = cd.service_id;
    const dt = cd.date;
    const ex = cd.exception_type;
    if (!sid || !dt) continue;
    if (String(ex) !== '1') continue;
    if (!map.has(sid)) map.set(sid, new Set());
    map.get(sid).add(dt);
  }
  return map;
}

function serviceActiveOnDate(service_id, ymd, activeIdx){
  if (!service_id) return false;
  const set = activeIdx.get(service_id);
  if (!set) return false;
  return set.has(ymd);
}

function isBerStop(name){
  const n = (name||'').toLowerCase();
  return n.includes('nancy') || n.includes('metz') || n.includes('thionville') || n.includes('luxembourg');
}

function inferDirection(stopNames){
  const idxNancy = stopNames.findIndex(n => (n||'').toLowerCase().includes('nancy'));
  const idxLux = stopNames.findIndex(n => (n||'').toLowerCase().includes('luxembourg'));
  if (idxNancy >= 0 && idxLux >= 0){
    return (idxNancy < idxLux) ? 'NNY_LUX' : 'LUX_NNY';
  }
  return null;
}

async function loadCompoData(url){
  const res = await fetch(url, {cache:'no-store'});
  if (!res.ok) throw new Error(`Compo HTTP ${res.status}`);
  return await res.json();
}

function normalizeCompoValue(v){
  const s = String(v||'').trim().toUpperCase();
  if (s === 'UM' || s === 'UM3' || s === 'US') return s;
  return 'US';
}

function pickUnitsForTrain(compoData, trainNo, dirKey){
  const entry = compoData?.[trainNo];
  if (!entry || !dirKey) return 'US';
  const v = entry[dirKey] ?? entry[String(dirKey)] ?? '';
  return normalizeCompoValue(v);
}

function hhmmssToHHMM(t){
  if (!t) return null;
  const s = String(t).trim();
  const m = s.match(/^(\d{1,2}):(\d{2})/);
  if (!m) return null;
  const hh = String(m[1]).padStart(2,'0');
  const mm = m[2];
  return `${hh}:${mm}`;
}

async function buildResolvedJSON({ bases, ymdISO, corridor, compoUrl }){
  const ymd = compactYMD(ymdISO);

  const { base, gtfs } = await pickWorkingBase(bases);

  let compoData = {};
  let compoStatus = 'OK';
  try{
    if (compoUrl){
      compoData = await loadCompoData(compoUrl);
      logLine(`‚úÖ Compo charg√©e: ${compoUrl}`);
    } else {
      compoStatus = 'NONE';
      logLine(`‚ö†Ô∏è Compo URL vide -> fallback US.`);
    }
  } catch(e){
    compoStatus = 'NONE';
    logLine(`‚ö†Ô∏è Compo non charg√©e -> fallback US. (${e?.message||e})`);
    compoData = {};
  }

  const stopsById = buildStopNameById(gtfs['stops.txt']);
  const stopTimesByTrip = buildStopTimesByTrip(gtfs['stop_times.txt']);
  const activeIdx = buildCalendarDatesActiveIndex(gtfs['calendar_dates.txt']);

  const out = {
    date: ymdISO,
    generatedAt: new Date().toISOString(),
    mode: 'calendar_dates_only',
    source: { gtfsBase: base, compo: compoUrl || null },
    trains: {}
  };

  for (const trip of gtfs['trips.txt']){
    if (!serviceActiveOnDate(trip.service_id, ymd, activeIdx)) continue;

    const trainNo = extractTrainNumber(trip);
    if (!trainNo) continue;

    const seq = stopTimesByTrip.get(trip.trip_id);
    if (!seq || !seq.length) continue;

    const stopNamesAll = [];
    const stopsObj = {};

    for (const st of seq){
      const name = stopsById.get(st.stop_id) || '';
      if (!name) continue;
      stopNamesAll.push(name);

      if (corridor === 'BER' && !isBerStop(name)) continue;

      const hhmm = hhmmssToHHMM(st.departure_time || st.arrival_time);
      if (!hhmm) continue;

      if (stopsObj[name] == null) stopsObj[name] = hhmm;
    }

    const stopsKeys = Object.keys(stopsObj);
    if (corridor === 'BER' && stopsKeys.length < 2) continue;

    const dirKey = inferDirection(stopNamesAll);
    const dirLabel = (dirKey === 'NNY_LUX') ? 'Nancy‚ÜíLux' : (dirKey === 'LUX_NNY' ? 'Lux‚ÜíNancy' : '‚Äî');

    const units = pickUnitsForTrain(compoData, trainNo, dirKey);
    const wagons = unitsToWagons(units);

    // D√©dup (si plusieurs trips = m√™me trainNo), on garde celui avec le plus de stops corridor
    const prev = out.trains[trainNo];
    const currentScore = stopsKeys.length;
    const prevScore = prev ? Object.keys(prev.stops || {}).length : -1;

    if (!prev || currentScore > prevScore){
      out.trains[trainNo] = {
        trip_id: trip.trip_id,
        service_id: trip.service_id,
        direction: dirLabel,
        dirKey: dirKey || null,
        units,
        wagons,
        stops: stopsObj
      };
    }
  }

  // petit r√©sum√©
  out.summary = {
    trainsCount: Object.keys(out.trains).length,
    compo: compoStatus
  };

  return out;
}

/* =========================
   Boot UI
   ========================= */
$('ymd').value = ymdToday();
$('bases').value = defaultBases().join('\n');
$('compoUrl').value = new URL('Compotrains.json', location.href).href;

function getBasesFromUI(){
  return $('bases').value.split('\n').map(s=>s.trim()).filter(Boolean).map(b => b.endsWith('/') ? b : (b + '/'));
}

$('btnTest').addEventListener('click', async ()=>{
  clearLog();
  setBusy(true);
  setStatus('Test en cours‚Ä¶');
  try{
    const bases = getBasesFromUI();
    await pickWorkingBase(bases);
    setStatus('<span class="pill ok">OK</span> Une base GTFS fonctionne. Tu peux g√©n√©rer.');
  } catch(e){
    setStatus('<span class="pill bad">ERR</span> Aucune base GTFS accessible. Regarde le log (URL/CORS/fichiers).');
  } finally {
    setBusy(false);
  }
});

$('btnSample').addEventListener('click', async ()=>{
  clearLog();
  setBusy(true);
  setStatus('Aper√ßu en cours‚Ä¶');
  try{
    const bases = getBasesFromUI();
    const ymdISO = $('ymd').value;
    const corridor = $('corridor').value;
    const compoUrl = $('compoUrl').value.trim();

    const out = await buildResolvedJSON({ bases, ymdISO, corridor, compoUrl });

    const keys = Object.keys(out.trains || {});
    const sample = keys.slice(0, 10).reduce((acc,k)=>{ acc[k]=out.trains[k]; return acc; },{});
    logLine('--- APER√áU 10 TRAINS ---');
    logLine(JSON.stringify({ date: out.date, summary: out.summary, trains: sample }, null, 2));
    setStatus(`<span class="pill ok">OK</span> Aper√ßu g√©n√©r√© (${keys.length} trains au total).`);
  } catch(e){
    logLine('Erreur: ' + (e?.message||e));
    setStatus('<span class="pill bad">ERR</span> Impossible de g√©n√©rer l‚Äôaper√ßu.');
  } finally {
    setBusy(false);
  }
});

$('btnGenerate').addEventListener('click', async ()=>{
  clearLog();
  setBusy(true);
  setStatus('G√©n√©ration en cours‚Ä¶');
  try{
    const bases = getBasesFromUI();
    const ymdISO = $('ymd').value;
    const corridor = $('corridor').value;
    const compoUrl = $('compoUrl').value.trim();

    const out = await buildResolvedJSON({ bases, ymdISO, corridor, compoUrl });

    const filename = `resolved_trains_${ymdISO}.json`;
    downloadJSON(out, filename);

    setStatus(`<span class="pill ok">OK</span> ${filename} t√©l√©charg√© (${out.summary?.trainsCount ?? 0} trains).`);
  } catch(e){
    logLine('Erreur: ' + (e?.message||e));
    setStatus('<span class="pill bad">ERR</span> G√©n√©ration impossible. V√©rifie le log.');
  } finally {
    setBusy(false);
  }
});
</script>
</body>
</html>
