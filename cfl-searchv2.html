<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Recherche trains CFL</title>
<style>
  :root {
    color-scheme: dark;
    --bg-page:#0b0f1a;
    --bg-card:#1a2238;
    --txt-main:#e0f0ff;
    --txt-dim:#7a8cae;
    --border:#2e374f;
    --accent:#e0f0ff;
    --accent-text:#0b0f1a;
    --accent2:#4ade80;
    --accent2-text:#001a08;
  }
  body{
    background:var(--bg-page);
    color:var(--txt-main);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    margin:0;
    padding:16px;
    line-height:1.4;
  }
  header{
    margin-bottom:16px;
  }
  header h1{
    font-size:1.1rem;
    font-weight:600;
    margin:0 0 4px 0;
    color:var(--txt-main);
  }
  header p{
    margin:0;
    color:var(--txt-dim);
    font-size:0.9rem;
    line-height:1.3;
  }

  form#searchForm{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:16px;
    display:flex;
    flex-direction:column;
    gap:12px;
    box-shadow:0 12px 24px rgb(0 0 0 / 0.6);
  }
  .field{
    display:flex;
    flex-direction:column;
  }
  label{
    font-size:14px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  select,
  input[type=time],
  input[type=date]{
    width:100%;
    background:var(--bg-page);
    color:var(--txt-main);
    border:1px solid var(--border);
    border-radius:8px;
    padding:8px;
    font-size:16px;
  }
  button#searchBtn{
    background:var(--accent);
    color:var(--accent-text);
    border:none;
    border-radius:8px;
    font-weight:600;
    padding:10px 14px;
    font-size:16px;
    cursor:pointer;
  }
  #formError{
    color:#ff6b6b;
    font-size:14px;
    min-height:1em;
  }

  #results h2{
    font-size:0.9rem;
    font-weight:600;
    color:var(--txt-main);
    margin:24px 0 8px 0;
    display:flex;
    align-items:center;
    gap:8px;
  }
  #results h2 .dot{
    width:8px;
    height:8px;
    border-radius:999px;
    background:var(--accent);
    box-shadow:0 0 12px var(--accent);
  }
  #results h2 .dot.alt{
    background:var(--accent2);
    box-shadow:0 0 12px var(--accent2);
  }

  .card{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:12px;
    box-shadow:0 8px 24px rgba(0,0,0,0.6);
  }
  .trainHeader{
    font-size:16px;
    font-weight:600;
    margin-bottom:4px;
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:6px;
    color:var(--txt-main);
  }
  .badge{
    background:var(--accent);
    color:var(--accent-text);
    border-radius:6px;
    font-size:14px;
    font-weight:600;
    padding:2px 6px;
    line-height:1.2;
  }
  .badge.secondary{
    background:var(--accent2);
    color:var(--accent2-text);
  }
  .mainline{
    font-size:15px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  .details{
    font-size:13px;
    color:var(--txt-dim);
  }
  .transferInfo{
    font-size:13px;
    color:var(--txt-main);
    margin:6px 0 4px 0;
    font-weight:500;
  }

  footer{
    margin-top:24px;
    color:var(--txt-dim);
    font-size:12px;
    text-align:center;
    line-height:1.4;
  }
  footer a{
    color:var(--txt-main);
  }

  @media(min-width:480px){
    body{ max-width:480px; margin:0 auto; }
  }
</style>
</head>
<body>
<header>
  <h1>Recherche trains CFL</h1>
  <p>Horaires statiques GTFS CFL (IC / RB / RE / TER / TGV). Résultats directs ou, si nécessaire, avec correspondance via les grands hubs.</p>
</header>

<form id="searchForm" onsubmit="return false;">
  <div class="field">
    <label for="fromStation">Départ</label>
    <select id="fromStation" required></select>
  </div>

  <div class="field">
    <label for="toStation">Arrivée</label>
    <select id="toStation" required></select>
  </div>

  <div class="field">
    <label for="dateDay">Date du trajet</label>
    <input id="dateDay" type="date" required>
  </div>

  <div class="field">
    <label for="minTime">Départ après</label>
    <input id="minTime" type="time" required>
  </div>

  <button id="searchBtn" type="button">Rechercher</button>
  <div id="formError"></div>
</form>

<section id="results"></section>

<footer>
  <div>Prototype horaire CFL – pas de retards temps réel.</div>
  <div>Source : GTFS CFL (statique).</div>
</footer>

<script>
// ====================== CONFIG ======================

const DATA_PATH = "CFL/";

// Trains CFL qu'on veut garder (agency_id = 11)
const ROUTE_IDS_ALLOWED = new Set(["302","301","300","299","297"]);

// Gares pivot autorisées pour correspondance
const HUBS = [
  "Luxembourg, Gare Centrale",
  "Bettembourg, Gare",
  "Ettelbruck, Gare"
  // tu peux en rajouter ici si besoin
];

// Mémoire globale
const DATA = {
  routesById:{},         // { route_id: {...} }
  stopsById:{},          // { stop_id: { name, lat, lon } }
  tripsById:{},          // { trip_id: { route_id, service_id, ... } }
  tripsStops:{},         // { trip_id: [ {stop_id,stop_name,arr,dep,seq}, ...] }
  calendar:{},           // { service_id: { startDate,endDate,days,exceptions } }
};

// ====================== CSV PARSER ======================

function splitCsvLine(line) {
  const out = [];
  let cur = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"') {
        if (line[i+1] === '"') {
          cur += '"'; i++;
        } else {
          inQuotes = false;
        }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',') {
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
  }
  out.push(cur);
  return out;
}

function parseCSV(rawText){
  const lines = rawText.trim().split(/\r?\n/);
  if (!lines.length) return [];
  const header = splitCsvLine(lines[0]);
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = splitCsvLine(lines[i]);
    if (cols.length===1 && cols[0]==="") continue;
    const obj={};
    for (let c=0;c<header.length;c++){
      obj[header[c]] = cols[c]!==undefined ? cols[c] : "";
    }
    rows.push(obj);
  }
  return rows;
}

// ====================== TIME / DATE ======================

function toMinutesSinceMidnight(hms){
  if(!hms || !hms.includes(":")) return null;
  const parts=hms.split(":");
  const H=parseInt(parts[0],10);
  const M=parseInt(parts[1],10);
  return H*60+M;
}

function hhmmToMinutes(hhmm){
  if(!hhmm||!hhmm.includes(":"))return 0;
  const [h,m]=hhmm.split(":");
  return parseInt(h,10)*60+parseInt(m,10);
}

function minutesToHHMM(mins){
  if(mins==null||isNaN(mins))return"--:--";
  let m=mins;
  while(m<0) m+=1440;
  while(m>=1440) m-=1440;
  const H=Math.floor(m/60);
  const M=m%60;
  return (H<10?"0"+H:H)+":"+(M<10?"0"+M:M);
}

// weekdayIdx: 0=lundi,...,6=dimanche
function dateInputToYMDinfo(dateStr){
  const [Y,M,D]=dateStr.split("-");
  const yyyymmdd=Y+M+D;
  const jsDate=new Date(+Y,+M-1,+D);
  // JS getDay(): 0=dimanche..6=samedi
  // On veut: 0=lundi..6=dimanche
  const map={1:0,2:1,3:2,4:3,5:4,6:5,0:6};
  const weekdayIdx=map[jsDate.getDay()];
  return { yyyymmdd, weekdayIdx };
}

// ====================== STATIONS FILTER ======================

function isRealStation(name){
  if (!name) return false;

  const lower = name.toLowerCase();

  // exclusions bus / tram / rue / rocade
  if (lower.includes("routière")) return false;
  if (lower.includes("routiere")) return false;
  if (lower.includes("rocade")) return false;
  if (lower.includes("(tram")) return false;
  if (lower.includes(" tram")) return false;
  if (lower.includes("rue de la gare")) return false;
  if (lower.includes("op der gare")) return false;
  if (lower.includes("bus")) return false;

  // exceptions à garder
  if (name === "Luxembourg, Gare Centrale") return true;
  if (name === "Howald, Gare") return true;

  // pattern "<Ville>, Gare"
  if (/, Gare\b/.test(name)) return true;

  return false;
}

// ====================== CALENDAR ======================

function serviceRunsOnDate(service_id, yyyymmdd, weekdayIdx){
  const svc = DATA.calendar[service_id];
  if(!svc) return false;

  // exceptions prio
  if (svc.exceptions && svc.exceptions[yyyymmdd] !== undefined) {
    return svc.exceptions[yyyymmdd] === 1;
  }
  // start/end
  if(svc.startDate && yyyymmdd < svc.startDate) return false;
  if(svc.endDate   && yyyymmdd > svc.endDate)   return false;

  // weekdayIdx 0=lundi,...,6=dimanche => GTFS 1..7
  const dayField = String(weekdayIdx+1);
  return !!svc.days[dayField];
}

// ====================== BUILDERS ======================

function buildRoutes(rows){
  for(const r of rows){
    const route_id  = (r.route_id||"").trim();
    const agency_id = (r.agency_id||"").trim();
    if(!ROUTE_IDS_ALLOWED.has(route_id)) continue;
    if(agency_id !== "11") continue; // CFL pur

    DATA.routesById[route_id] = {
      route_id,
      agency_id,
      shortName: (r.route_short_name||"").trim(),
      longName:  (r.route_long_name ||"").trim(),
      type:      (r.route_type      ||"").trim()
    };
  }
}

function buildStops(rows){
  for(const s of rows){
    const stop_id   = (s.stop_id||"").trim();
    const stop_name = (s.stop_name||"").trim();
    if(!stop_id || !stop_name) continue;
    if(!isRealStation(stop_name)) continue;
    DATA.stopsById[stop_id] = {
      name: stop_name,
      lat:  Number(s.stop_lat||"0"),
      lon:  Number(s.stop_lon||"0")
    };
  }
}

function buildTrips(rows){
  for(const t of rows){
    const trip_id    = (t.trip_id||"").trim();
    const route_id   = (t.route_id||"").trim();
    const service_id = (t.service_id||"").trim();
    if(!trip_id || !route_id || !service_id) continue;

    if(!DATA.routesById[route_id]) continue; // garder seulement CFL train

    DATA.tripsById[trip_id] = {
      route_id,
      service_id,
      headsign:  (t.trip_headsign  ||"").trim(),
      shortName: (t.trip_short_name||"").trim(),
      direction: (t.direction_id   ||"").trim()
    };
  }
}

function buildCalendar(calRows, calDatesRows){
  for(const c of calRows){
    const service_id=(c.service_id||"").trim();
    if(!service_id) continue;
    DATA.calendar[service_id] = {
      startDate:(c.start_date||"").trim(),
      endDate:(c.end_date||"").trim(),
      days:{
        "1": c.monday==="1",
        "2": c.tuesday==="1",
        "3": c.wednesday==="1",
        "4": c.thursday==="1",
        "5": c.friday==="1",
        "6": c.saturday==="1",
        "7": c.sunday==="1"
      },
      exceptions:{}
    };
  }

  for(const ce of calDatesRows){
    const service_id=(ce.service_id||"").trim();
    const date=(ce.date||"").trim();
    const exc=(ce.exception_type||"").trim();
    if(!service_id||!date||!exc) continue;

    if(!DATA.calendar[service_id]){
      DATA.calendar[service_id] = {
        startDate:"",
        endDate:"",
        days:{},
        exceptions:{}
      };
    }
    DATA.calendar[service_id].exceptions[date] = parseInt(exc,10); // 1=ajout,2=suppr
  }
}

function buildTripsStops(stopTimesRows){
  for(const st of stopTimesRows){
    const trip_id = (st.trip_id||"").trim();
    const stop_id = (st.stop_id||"").trim();
    if(!trip_id || !stop_id) continue;

    if(!DATA.tripsById[trip_id]) continue;
    if(!DATA.stopsById[stop_id]) continue;

    if(!DATA.tripsStops[trip_id]) DATA.tripsStops[trip_id] = [];

    DATA.tripsStops[trip_id].push({
      stop_id,
      stop_name: DATA.stopsById[stop_id].name,
      arr: toMinutesSinceMidnight(st.arrival_time),
      dep: toMinutesSinceMidnight(st.departure_time),
      seq: Number(st.stop_sequence||"0")
    });
  }

  for(const tripId of Object.keys(DATA.tripsStops)){
    const arrs = DATA.tripsStops[tripId];
    arrs.sort((a,b)=>a.seq-b.seq);
    if(arrs.length < 2){
      delete DATA.tripsStops[tripId];
      delete DATA.tripsById[tripId];
    }
  }
}

// ====================== RECHERCHE DIRECTE ======================

function findDirectTrains(fromName,toName,minDepartureMinutes,yyyymmdd,weekdayIdx){
  const fromIds = new Set();
  const toIds   = new Set();
  for(const sid in DATA.stopsById){
    const stName = DATA.stopsById[sid].name;
    if(stName === fromName) fromIds.add(sid);
    if(stName === toName)   toIds.add(sid);
  }

  const results = [];

  for(const tripId in DATA.tripsStops){
    const stopSeq = DATA.tripsStops[tripId];
    const tripMeta = DATA.tripsById[tripId];
    if(!tripMeta) continue;

    if(!serviceRunsOnDate(tripMeta.service_id, yyyymmdd, weekdayIdx)) continue;

    let depStop=null;
    let arrStop=null;

    for(let i=0;i<stopSeq.length;i++){
      const s=stopSeq[i];
      if(!depStop && fromIds.has(s.stop_id)){
        depStop = s;
      }
      if(depStop && toIds.has(s.stop_id) && s.seq>depStop.seq){
        arrStop = s;
        break;
      }
    }

    if(!depStop || !arrStop) continue;
    if(depStop.dep==null || depStop.dep < minDepartureMinutes) continue;

    const between = stopSeq.filter(s => s.seq>=depStop.seq && s.seq<=arrStop.seq);

    const routeMeta = DATA.routesById[tripMeta.route_id] || {};
    const trainType = routeMeta.shortName || "";
    const label = tripMeta.shortName || tripMeta.headsign || "";

    results.push({
      type: "direct",
      trip_id: tripId,
      train_type: trainType,
      train_label: label,
      depart_station: depStop.stop_name,
      depart_time_min: depStop.dep,
      arrive_station: arrStop.stop_name,
      arrive_time_min: arrStop.arr,
      duration_min: (arrStop.arr??0) - (depStop.dep??0),
      stops: between.map(s=>s.stop_name)
    });
  }

  results.sort((a,b)=>a.depart_time_min - b.depart_time_min);
  return results;
}

// ====================== OUTILS CORRESPONDANCE ======================

// 1. segments partant de startName vers toutes les gares (plus loin dans CE train)
function findSegmentsFrom(startName, minDepartureMinutes, yyyymmdd, weekdayIdx) {
  const startIds = new Set();
  for (const sid in DATA.stopsById) {
    if (DATA.stopsById[sid].name === startName) startIds.add(sid);
  }

  const segments = [];

  for (const tripId in DATA.tripsStops) {
    const seqList = DATA.tripsStops[tripId];
    const tripMeta = DATA.tripsById[tripId];
    if (!tripMeta) continue;
    if (!serviceRunsOnDate(tripMeta.service_id, yyyymmdd, weekdayIdx)) continue;

    let originStop = null;
    for (let i=0;i<seqList.length;i++){
      const st=seqList[i];

      if (!originStop && startIds.has(st.stop_id)) {
        originStop = st;
      }

      if (originStop) {
        if (st.seq <= originStop.seq) continue;
        if (originStop.dep == null) continue;
        if (originStop.dep < minDepartureMinutes) continue;

        const routeMeta = DATA.routesById[tripMeta.route_id] || {};
        const trainType = routeMeta.shortName || "";
        const label = tripMeta.shortName || tripMeta.headsign || "";

        const sliceBetween = seqList
          .filter(x => x.seq>=originStop.seq && x.seq<=st.seq)
          .map(x => x.stop_name);

        segments.push({
          from_stop_name: originStop.stop_name,
          to_stop_name: st.stop_name,
          dep_min: originStop.dep,
          arr_min: st.arr,
          train_type: trainType,
          train_label: label,
          stops_between: sliceBetween
        });
      }
    }
  }
  return segments;
}

// 2. segments allant vers endName depuis toutes les gares avant dans CE train
function findSegmentsTo(endName, yyyymmdd, weekdayIdx) {
  const endIds = new Set();
  for (const sid in DATA.stopsById) {
    if (DATA.stopsById[sid].name === endName) endIds.add(sid);
  }

  const segments = [];

  for (const tripId in DATA.tripsStops) {
    const seqList = DATA.tripsStops[tripId];
    const tripMeta = DATA.tripsById[tripId];
    if (!tripMeta) continue;
    if (!serviceRunsOnDate(tripMeta.service_id, yyyymmdd, weekdayIdx)) continue;

    for (let i=0;i<seqList.length;i++){
      const endSt = seqList[i];
      if (!endIds.has(endSt.stop_id)) continue;

      for (let j=0;j<i;j++){
        const startSt = seqList[j];
        if (startSt.seq >= endSt.seq) continue;
        if (startSt.dep == null) continue;

        const routeMeta = DATA.routesById[tripMeta.route_id] || {};
        const trainType = routeMeta.shortName || "";
        const label = tripMeta.shortName || tripMeta.headsign || "";

        const sliceBetween = seqList
          .filter(x => x.seq>=startSt.seq && x.seq<=endSt.seq)
          .map(x => x.stop_name);

        segments.push({
          from_stop_name: startSt.stop_name,
          to_stop_name: endSt.stop_name,
          dep_min: startSt.dep,
          arr_min: endSt.arr,
          train_type: trainType,
          train_label: label,
          stops_between: sliceBetween
        });
      }
    }
  }
  return segments;
}

// 3. construit les correspondances via HUBS uniquement
function findSmartTransfers(startName, endName, yyyymmdd, weekdayIdx, minDepartureMinutes, minTransferMinutes = 5) {
  const segOut = findSegmentsFrom(startName, minDepartureMinutes, yyyymmdd, weekdayIdx);
  const segIn  = findSegmentsTo(endName, yyyymmdd, weekdayIdx);

  const trips = [];

  for (const s1 of segOut) {
    for (const s2 of segIn) {

      // même gare pivot ?
      if (s1.to_stop_name !== s2.from_stop_name) continue;

      // pivot autorisé ?
      if (!HUBS.includes(s1.to_stop_name)) continue;

      // correspondance faisable ? (s2 part après arrivée de s1 + marge)
      if (s2.dep_min < s1.arr_min + minTransferMinutes) continue;

      // construire l’itinéraire complet
      trips.push({
        pivot: s1.to_stop_name,

        start_station: s1.from_stop_name,
        start_time_min: s1.dep_min,

        arrive_pivot_min: s1.arr_min,
        leave_pivot_min: s2.dep_min,

        end_station: s2.to_stop_name,
        end_time_min: s2.arr_min,

        total_duration_min: (s2.arr_min ?? 0) - (s1.dep_min ?? 0),

        first_train_type: s1.train_type,
        first_train_label: s1.train_label,
        first_segment_stops: s1.stops_between,

        second_train_type: s2.train_type,
        second_train_label: s2.train_label,
        second_segment_stops: s2.stops_between
      });
    }
  }

  // Trier les correspondances trouvées.
  // Logique : d’abord l’heure de départ du premier train, puis durée totale.
  trips.sort((a,b)=>{
    if (a.start_time_min !== b.start_time_min) {
      return a.start_time_min - b.start_time_min;
    }
    return a.total_duration_min - b.total_duration_min;
  });

  // Dédupliquer si jamais on crée deux fois le même trajet (même départ, même pivot, même arrivée)
  const unique = [];
  const seen = new Set();
  for (const t of trips) {
    const sig = [
      t.start_station,
      t.start_time_min,
      t.pivot,
      t.leave_pivot_min,
      t.end_station,
      t.end_time_min
    ].join("|");
    if (!seen.has(sig)) {
      seen.add(sig);
      unique.push(t);
    }
  }

  // limiter un peu pour éviter une liste énorme (genre les 10 prochains itinéraires)
  return unique.slice(0, 10);
}

// ====================== RENDU UI ======================

function populateStationsSelect(){
  const setNames=new Set();
  for(const sid in DATA.stopsById){
    setNames.add(DATA.stopsById[sid].name);
  }
  const names=[...setNames].sort((a,b)=>a.localeCompare(b,"fr"));
  const fromSel=document.getElementById("fromStation");
  const toSel=document.getElementById("toStation");
  fromSel.innerHTML="";
  toSel.innerHTML="";
  for(const n of names){
    const o1=document.createElement("option");
    o1.value=n;o1.textContent=n;
    fromSel.appendChild(o1);
    const o2=document.createElement("option");
    o2.value=n;o2.textContent=n;
    toSel.appendChild(o2);
  }
}

function prefillDateTime(){
  const now=new Date();
  const yyyy=now.getFullYear();
  const mm=String(now.getMonth()+1).padStart(2,"0");
  const dd=String(now.getDate()).padStart(2,"0");
  const HH=String(now.getHours()).padStart(2,"0");
  const MM=String(now.getMinutes()).padStart(2,"0");
  const dateInput=document.getElementById("dateDay");
  const timeInput=document.getElementById("minTime");
  if(!dateInput.value)dateInput.value=`${yyyy}-${mm}-${dd}`;
  if(!timeInput.value)timeInput.value=`${HH}:${MM}`;
}

function renderDirectSection(container, directList){
  const dirTitle=document.createElement("h2");
  dirTitle.innerHTML=`<span class="dot"></span>Trains directs`;
  container.appendChild(dirTitle);

  if (!directList.length){
    const no=document.createElement("div");
    no.className="card";
    no.style.color="var(--txt-dim)";
    no.textContent="Aucun train direct trouvé après cette heure.";
    container.appendChild(no);
    return;
  }

  for(const r of directList){
    const card=document.createElement("div");
    card.className="card";

    const head=document.createElement("div");
    head.className="trainHeader";

    const badge=document.createElement("span");
    badge.className="badge";
    badge.textContent=r.train_type || "?";
    head.appendChild(badge);

    const lbl=document.createElement("span");
    lbl.textContent=r.train_label || "";
    head.appendChild(lbl);

    const mainline=document.createElement("div");
    mainline.className="mainline";
    const depHHMM=minutesToHHMM(r.depart_time_min);
    const arrHHMM=minutesToHHMM(r.arrive_time_min);
    const dur=(r.duration_min!=null && r.duration_min>=0)? r.duration_min+" min":"";
    mainline.textContent =
      `${r.depart_station} ${depHHMM} → ${r.arrive_station} ${arrHHMM}`+
      (dur?` (${dur})`:"");

    const details=document.createElement("div");
    details.className="details";
    details.textContent="Dessert : "+r.stops.join(" · ");

    card.appendChild(head);
    card.appendChild(mainline);
    card.appendChild(details);
    container.appendChild(card);
  }
}

function renderTransferSection(container, transferList){
  const viaTitle=document.createElement("h2");
  viaTitle.innerHTML=`<span class="dot alt"></span>Avec correspondance via hub majeur`;
  container.appendChild(viaTitle);

  if (!transferList.length){
    const no=document.createElement("div");
    no.className="card";
    no.style.color="var(--txt-dim)";
    no.textContent="Aucun trajet avec correspondance pertinent.";
    container.appendChild(no);
    return;
  }

  for(const j of transferList){
    const card=document.createElement("div");
    card.className="card";

    // 1er train
    const head1=document.createElement("div");
    head1.className="trainHeader";

    const badge1=document.createElement("span");
    badge1.className="badge";
    badge1.textContent=j.first_train_type || "?";
    head1.appendChild(badge1);

    const lbl1=document.createElement("span");
    lbl1.textContent=j.first_train_label || "";
    head1.appendChild(lbl1);

    const line1=document.createElement("div");
    line1.className="mainline";
    line1.textContent =
      `${j.start_station} ${minutesToHHMM(j.start_time_min)} → ${j.pivot} ${minutesToHHMM(j.arrive_pivot_min)}`;

    const stops1=document.createElement("div");
    stops1.className="details";
    stops1.textContent="1er train : "+j.first_segment_stops.join(" · ");

    const tx=document.createElement("div");
    tx.className="transferInfo";
    const waitMin = (j.leave_pivot_min - j.arrive_pivot_min);
    tx.textContent = `Correspondance à ${j.pivot} (~${waitMin} min d'attente)`;

    // 2e train
    const head2=document.createElement("div");
    head2.className="trainHeader";

    const badge2=document.createElement("span");
    badge2.className="badge secondary";
    badge2.textContent=j.second_train_type || "?";
    head2.appendChild(badge2);

    const lbl2=document.createElement("span");
    lbl2.textContent=j.second_train_label || "";
    head2.appendChild(lbl2);

    const line2=document.createElement("div");
    line2.className="mainline";
    const totalDur = (j.total_duration_min!=null && j.total_duration_min>=0)
      ? ` (${j.total_duration_min} min total)`
      : "";
    line2.textContent =
      `${j.pivot} ${minutesToHHMM(j.leave_pivot_min)} → ${j.end_station} ${minutesToHHMM(j.end_time_min)}${totalDur}`;

    const stops2=document.createElement("div");
    stops2.className="details";
    stops2.textContent="2e train : "+j.second_segment_stops.join(" · ");

    card.appendChild(head1);
    card.appendChild(line1);
    card.appendChild(stops1);
    card.appendChild(tx);
    card.appendChild(head2);
    card.appendChild(line2);
    card.appendChild(stops2);

    container.appendChild(card);
  }
}

function renderResultsSmart(directList, transferList){
  const container=document.getElementById("results");
  container.innerHTML="";

  if (directList.length > 0) {
    // On n'affiche QUE les directs si au moins un direct existe
    renderDirectSection(container, directList);
  } else {
    // pas de direct -> on affiche les correspondances intelligentes
    renderTransferSection(container, transferList);
  }
}

// ====================== INTERACTION ======================

function setupSearchHandler(){
  const btn=document.getElementById("searchBtn");
  const errBox=document.getElementById("formError");

  btn.addEventListener("click",()=>{
    errBox.textContent="";

    const fromStation=document.getElementById("fromStation").value;
    const toStation=document.getElementById("toStation").value;
    const dateStr=document.getElementById("dateDay").value;
    const minTimeStr=document.getElementById("minTime").value;

    if(!fromStation||!toStation){
      errBox.textContent="Choisis une gare de départ et une gare d'arrivée.";
      return;
    }
    if(fromStation===toStation){
      errBox.textContent="Départ et arrivée identiques.";
      return;
    }
    if(!dateStr){
      errBox.textContent="Choisis une date.";
      return;
    }
    if(!minTimeStr){
      errBox.textContent="Choisis une heure minimale.";
      return;
    }

    const { yyyymmdd, weekdayIdx } = dateInputToYMDinfo(dateStr);
    const minDepartureMinutes = hhmmToMinutes(minTimeStr);

    const directFound = findDirectTrains(
      fromStation,
      toStation,
      minDepartureMinutes,
      yyyymmdd,
      weekdayIdx
    );

    const transferFound = findSmartTransfers(
      fromStation,
      toStation,
      yyyymmdd,
      weekdayIdx,
      minDepartureMinutes,
      5 // marge min correspondance en minutes
    );

    renderResultsSmart(directFound, transferFound);
  });
}

// ====================== INIT ======================

async function loadAll(){
  const [
    routesText,
    stopsText,
    tripsText,
    stopTimesText,
    calText,
    calDatesText
  ] = await Promise.all([
    fetch(DATA_PATH+"routescfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"stopscfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"tripscfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"stop_timescfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"calendarcfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"calendar_datescfl.txt").then(r=>r.text())
  ]);

  const routesRows    = parseCSV(routesText);
  const stopsRows     = parseCSV(stopsText);
  const tripsRows     = parseCSV(tripsText);
  const stopTimesRows = parseCSV(stopTimesText);
  const calRows       = parseCSV(calText);
  const calDatesRows  = parseCSV(calDatesText);

  buildRoutes(routesRows);
  buildStops(stopsRows);
  buildTrips(tripsRows);
  buildCalendar(calRows, calDatesRows);
  buildTripsStops(stopTimesRows);

  console.log("DEBUG:", {
    routesKept:Object.keys(DATA.routesById).length,
    stopsKept:Object.keys(DATA.stopsById).length,
    tripsKept:Object.keys(DATA.tripsById).length,
    tripsWithStops:Object.keys(DATA.tripsStops).length
  });
}

document.addEventListener("DOMContentLoaded", async ()=>{
  await loadAll();
  populateStationsSelect();
  prefillDateTime();
  setupSearchHandler();
});
</script>
</body>
</html>
