<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Train Bétail V4.1 CLEAN</title>
  <style>
    body {
      background: black;
      color: #0ff;
      font-family: 'Orbitron', monospace;
      text-align: center;
    }
    canvas {
      border: 3px solid #0ff;
      margin-top: 20px;
    }
    #info {
      margin-top: 15px;
      font-size: 18px;
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    #gameOverMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0ff;
      font-family: 'Orbitron', monospace;
      font-size: 48px;
      text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
      background: rgba(0,0,0,0.8);
      padding: 20px 40px;
      border: 3px solid #0ff;
      border-radius: 10px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>

<h1>Train Bétail - Évite les suppressions !</h1>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="info">
  Utilise les <b>flèches</b> pour tourner.<br>
  Prends le <span style="color: yellow;">bétail jaune</span> pour grandir.<br>
  Évite les <span style="color: red;">cases rouges (suppressions)</span>.<br>
  Les <span style="color: orange;">oranges</span> accélèrent ou ralentissent.<br>
  Attention aux <span style="color: white;">vaches blanches</span> !<br>
  Score : <span id="score">0</span>
</div>

<div id="gameOverMessage"></div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const gridSize = 20, cols = canvas.width / gridSize, rows = canvas.height / gridSize;

  let train = [{x: 10, y: 10}];
  let direction = {x: 1, y: 0};
  let nextDirection = direction;
  let score = 0;
  let baseSpeed = 200;
  let speedModifier = 0;
  let betail = null;
  let suppressions = [];
  let oranges = [];
  let vaches = [];
  let vachesActive = false;
  let vacheFrequency = 15000;
  let gameStopped = false;

  const colorTrainHead = "#0ff", colorTrainBody = "#088";
  const colorSuppression = "red", colorAcceleration = "orange", colorBetail = "yellow", colorVache = "white";
  const messagesSuppression = [
    "Supprimé pour absence du conducteur.",
    "Supprimé pour travaux aléatoires.",
    "Supprimé pour grève surprise.",
    "Supprimé pour cause d'invasion de hérissons.",
    "Supprimé pour défaillance du réveil du chef de bord.",
    "Supprimé pour surcharge de passagers imaginaires.",
    "Supprimé pour alignement des planètes défavorable.",
    "Supprimé pour panne de distributeur de café."
  ];

  function placePerturbations() {
    for (let i = 0; i < 10; i++) suppressions.push(randomFreePosition());
    for (let i = 0; i < 5; i++) oranges.push(randomFreePosition());
  }

  function randomFreePosition() {
    let pos;
    do {
      pos = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
    } while (isOccupied(pos));
    return pos;
  }

  function isOccupied(pos) {
    return train.some(p => p.x === pos.x && p.y === pos.y)
      || suppressions.some(p => p.x === pos.x && p.y === pos.y)
      || oranges.some(p => p.x === pos.x && p.y === pos.y)
      || (betail && betail.x === pos.x && betail.y === pos.y);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    suppressions.forEach(p => {
      ctx.fillStyle = colorSuppression;
      ctx.fillRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4);
    });

    oranges.forEach(p => {
      ctx.fillStyle = colorAcceleration;
      ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8);
    });

    if (betail) {
      ctx.fillStyle = colorBetail;
      ctx.beginPath();
      ctx.arc(betail.x * gridSize + gridSize/2, betail.y * gridSize + gridSize/2, gridSize/3, 0, 2*Math.PI);
      ctx.fill();
    }

    vaches.forEach(p => {
      ctx.fillStyle = colorVache;
      ctx.beginPath();
      ctx.arc(p.x * gridSize + gridSize/2, p.y * gridSize + gridSize/2, gridSize/3, 0, 2*Math.PI);
      ctx.fill();
    });

    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? colorTrainHead : colorTrainBody;
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  function update() {
    if (gameStopped) return;

    direction = nextDirection;
    let newHead = { x: train[0].x + direction.x, y: train[0].y + direction.y };
    if (newHead.x < 0) newHead.x = cols - 1;
    if (newHead.x >= cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = rows - 1;
    if (newHead.y >= rows) newHead.y = 0;

    if (train.some(p => p.x === newHead.x && p.y === newHead.y)) return showGameOver("Collision avec soi-même !");
    if (vaches.some(p => p.x === newHead.x && p.y === newHead.y)) return showGameOver("Percuté des vaches !");
    if (suppressions.some(p => p.x === newHead.x && p.y === newHead.y)) {
      const msg = messagesSuppression[Math.floor(Math.random() * messagesSuppression.length)];
      return showGameOver(msg);
    }

    train.unshift(newHead);

    if (betail && newHead.x === betail.x && newHead.y === betail.y) {
      score++;
      document.getElementById("score").textContent = score;
      generateBetail();
    } else {
      train.pop();
    }

    if (oranges.some(p => p.x === newHead.x && p.y === newHead.y)) {
      speedModifier = (Math.random() < 0.5) ? -150 : 150;
      setTimeout(() => { speedModifier = 0; }, 2000);
    }

    moveVaches();
  }

  function moveVaches() {
    vaches.forEach(v => v.x--);
    vaches = vaches.filter(v => v.x >= 0);
  }

  function scheduleNextVaches() {
    if (gameStopped) return;
    vaches.push({x: cols-1, y: Math.floor(Math.random() * rows)});
    setTimeout(scheduleNextVaches, vacheFrequency);
  }

  function increaseVacheFrequency() {
    if (vacheFrequency > 3000) vacheFrequency -= 1000;
    setTimeout(increaseVacheFrequency, 60000);
  }

  function showGameOver(message) {
    gameStopped = true;
    const div = document.getElementById("gameOverMessage");
    div.textContent = message + "\nScore: " + score;
    div.style.display = "block";
    let opacity = 0;
    const fade = setInterval(() => {
      opacity += 0.05;
      div.style.opacity = opacity;
      if (opacity >= 1) clearInterval(fade);
    }, 50);
  }

  function gameLoop() {
    update();
    draw();
    if (!gameStopped) {
      const delay = Math.max(50, baseSpeed + speedModifier);
      setTimeout(gameLoop, delay);
    }
  }

  function generateBetail() {
    betail = randomFreePosition();
  }

  window.addEventListener("keydown", e => {
    switch(e.key) {
      case "ArrowUp": if(direction.y !== 1) nextDirection = {x: 0, y: -1}; break;
      case "ArrowDown": if(direction.y !== -1) nextDirection = {x: 0, y: 1}; break;
      case "ArrowLeft": if(direction.x !== 1) nextDirection = {x: -1, y: 0}; break;
      case "ArrowRight": if(direction.x !== -1) nextDirection = {x: 1, y: 0}; break;
    }
  });

  placePerturbations();
  generateBetail();
  gameLoop();

  setTimeout(() => {
    vachesActive = true;
    scheduleNextVaches();
    increaseVacheFrequency();
  }, 60000);

})();
</script>
</body>
</html>
