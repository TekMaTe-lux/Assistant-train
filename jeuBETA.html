<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Jeu de la B√©taill√®re</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #0b0f1a 0%, #020308 60%, #000000 100%);
      color: #00f6ff;
      font-family: 'Orbitron', 'Segoe UI', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
        }

    header {
      text-align: center;
      padding: 16px 8px 4px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: clamp(1.4rem, 2.5vw, 2rem);
      text-shadow: 0 0 10px rgba(0, 246, 255, 0.7);
    }

    #container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      padding: 0 12px 12px;
      gap: 8px;
    }

    #gameWrapper {
      width: min(100vw - 24px, 540px);
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      margin: 0 auto;
    }
    
    canvas {
      border: 3px solid rgba(0, 246, 255, 0.9);
      border-radius: 16px;
      box-shadow: 0 0 20px rgba(0, 246, 255, 0.25);
      background: rgba(0, 5, 10, 0.85);
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 1 / 1;
      max-width: 100%;
    }

    #info {
      font-size: 15px;
      margin: 0 auto;
      padding: 6px 12px;
      border: 1px solid rgba(0, 246, 255, 0.2);
      border-radius: 10px;
      background: rgba(5, 15, 25, 0.7);
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      text-shadow: 0 0 6px rgba(0, 246, 255, 0.6);
    }

    /* √âcran de d√©marrage */
    #startOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      z-index: 10000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #startMessage {
      background: #111;
      padding: 20px 40px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 15px #0ff;
    }

    #startMessage button {
      background: #0ff;
      color: black;
      border: none;
      padding: 10px 20px;
      margin-top: 15px;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 0 10px #0ff;
    }

    /* Game Over */
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      background-color: rgba(0,0,0,0.7);
    }

    #gameOverMessage {
      background: rgba(20,20,20,0.95);
      color: #eee;
      text-align: center;
      padding: 20px 25px;
      border-radius: 12px;
      max-width: 90vw;
      width: 320px;
      box-shadow: 0 0 15px rgba(0,255,0,0.6);
      font-size: 1.2rem;
    }

    #gameOverMessage button {
      font-size: 1.1rem;
      padding: 10px 18px;
      margin: 8px 10px 0 10px;
      border-radius: 8px;
      border: none;
      background-color: #0f0;
      color: #000;
      cursor: pointer;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 11000;
    }

    .modal-content {
      background: rgba(10, 20, 35, 0.95);
      border: 2px solid rgba(0, 246, 255, 0.4);
      border-radius: 14px;
      padding: 20px;
      width: min(90vw, 420px);
      color: #e0f9ff;
      text-align: left;
      box-shadow: 0 0 18px rgba(0, 246, 255, 0.25);
    }

    .modal-content h2 {
      margin-top: 0;
      text-align: center;
      letter-spacing: 1px;
    }

    .modal-content ul {
      padding-left: 18px;
      line-height: 1.5;
      font-size: 0.95rem;
    }

    #closeRules {
      width: 100%;
      margin-top: 16px;
      padding: 10px 16px;
      font-size: 1rem;
      border-radius: 10px;
      border: none;
      background: linear-gradient(145deg, #00f6ff, #00a8d6);
      color: #001922;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 246, 255, 0.3);
    }

    #controlPanel {
      width: min(100vw - 24px, 560px);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 16px;
      padding-bottom: 12px;
      margin: 0 auto;
    }

    #touchControls {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .up-row {
      display: flex;
      justify-content: center;
    }

    .middle-row {
      display: flex;
      justify-content: center;
      gap: 12px;
    }
    #touchControls button,
    .utility-buttons button {
      width: 64px;
      height: 64px;
      font-size: 24px;
      border-radius: 14px;
      border: none;
      background: linear-gradient(145deg, rgba(20,35,50,0.95), rgba(8,15,25,0.95));
      color: #e8faff;
      box-shadow: inset 0 0 8px rgba(0, 246, 255, 0.3), 0 6px 14px rgba(0, 0, 0, 0.6);
      touch-action: manipulation;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 2px;
    }

    #touchControls button:active,
    .utility-buttons button:active {
      transform: translateY(2px);
      box-shadow: inset 0 0 12px rgba(0, 246, 255, 0.5), 0 2px 6px rgba(0,0,0,0.6);
    }

    #touchControls button:disabled,
    .utility-buttons button:disabled {
      opacity: 0.45;
      box-shadow: none;
    }

    .utility-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-left: auto;
    }

    .utility-buttons button {
      width: 60px;
      height: 60px;
      font-size: 20px;
    }

    .utility-buttons button span {
      display: block;
      font-size: 10px;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }

    @media (min-width: 768px) {
      #touchControls button,
      .utility-buttons button {
        width: 70px;
        height: 70px;
      }
    }

    @media (max-width: 380px) {
      #touchControls button,
      .utility-buttons button {
        width: 56px;
        height: 56px;
      }
    }  
  </style>
</head>
<body>
  <header>Jeu de la B√©taill√®re</header>

  <!-- √âcran de d√©marrage -->
  <div id="startOverlay">
    <div id="startMessage">
      <p>üöÜ Pr√™t √† d√©marrer ?</p>
      <button id="startBtn">Jouer</button>
    </div>
  </div>

  <div id="container">
    <div id="gameWrapper">
      <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>

    <div id="info">
      Score : <span id="score">0</span>
      <span aria-hidden="true">‚Ä¢</span>
      Record : <span id="highscore">0</span>
      <span aria-hidden="true">‚Ä¢</span>
      Temps : <span id="timer">00:00</span>
    </div>

    <!-- Contr√¥les tactiles -->
    <div id="controlPanel">
      <div id="touchControls" aria-label="Contr√¥les directionnels">
        <div class="up-row">
          <button id="up" aria-label="Haut">‚ñ≤</button>
        </div>
        <div class="middle-row">
          <button id="left" aria-label="Gauche">‚óÄ</button>
          <button id="down" aria-label="Bas">‚ñº</button>
          <button id="right" aria-label="Droite">‚ñ∂</button>
        </div>
      </div>
      <div class="utility-buttons">
        <button id="pauseBtn" aria-label="Mettre en pause le jeu">‚è∏<span>Pause</span></button>
        <button id="rulesBtn" aria-label="Afficher les r√®gles">‚ÑπÔ∏è<span>R√®gles</span></button>
      </div>
    </div>

    <!-- √âcran Game Over -->
    <div id="overlay">
      <div id="gameOverMessage" style="display:none;">
        <div id="gameOverText"></div>
        <button id="restartBtn">Rejouer</button>
        <button id="returnBtn">Retour</button>
      </div>
    </div>

    <!-- Musique -->
    <audio id="gameMusic" loop>
      <source src="https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/Tek'Ma'Te%20-%20Power%20of%20the%20SNCF%20jingle.mp3" type="audio/mpeg">
      Votre navigateur ne supporte pas l‚Äôaudio.
    </audio>
  </div>

  <div id="rulesOverlay" class="modal" style="display:none;">
    <div class="modal-content">
      <h2>R√®gles express</h2>
      <ul>
        <li>Collectez le b√©tail lumineux pour marquer des points.</li>
        <li>√âvitez les zones rouges (trains supprim√©s) et les carr√©s oranges surprises.</li>
        <li>Attention aux vaches et aux TGV prioritaires qui traversent la ligne.</li>
        <li>Apr√®s 90 secondes, les TGV arrivent plus souvent. Restez concentr√© !</li>
        <li>Utilisez les fl√®ches ou glissez sur l'√©cran pour diriger votre train.</li>
      </ul>
      <button id="closeRules">Fermer</button>
    </div>
  </div>
<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const headerEl = document.querySelector("header");
  const infoBar = document.getElementById("info");
  const controlPanel = document.getElementById("controlPanel");
  const gameWrapper = document.getElementById("gameWrapper");
  let cols = 20, rows = 20, gridSize = 20;

  function resizeCanvas() {
    const headerHeight = headerEl ? headerEl.offsetHeight : 0;
    const infoHeight = infoBar ? infoBar.offsetHeight : 0;
    const controlsHeight = controlPanel ? controlPanel.offsetHeight : 0;
    const verticalPadding = 48;
    const availableHeight = window.innerHeight - headerHeight - infoHeight - controlsHeight - verticalPadding;
    const availableWidth = gameWrapper.clientWidth || window.innerWidth;
    let size = Math.min(availableWidth, availableHeight);
    if (!size || size <= 0) {
      size = availableWidth;
    }
    const minSize = Math.min(availableWidth, 320);
    if (size < minSize) {
      size = minSize;
    }

    canvas.style.width = canvas.style.height = `${size}px`;
    canvas.width = canvas.height = size;
    gridSize = size / cols;
  }

  window.addEventListener("resize", () => requestAnimationFrame(resizeCanvas));
  window.addEventListener("orientationchange", () => setTimeout(resizeCanvas, 300));
  resizeCanvas();

  let train, direction, nextDirection, score, highscore = 0;
  let baseSpeed = 200, speedModifier = 0;
  let betail, suppressions, oranges, vaches, tgvs;
  let vacheFrequency, scheduleVachesTimeoutId, increaseVacheFreqTimeoutId;
  let tgvFrequency, scheduleTGVTimeoutId, increaseTGVFreqTimeoutId, tgvStartTimeoutId;
  let gameStopped, gamePaused, countdownInterval, startTime, gameLoopTimeoutId;
  let pauseStartTime = 0;
  let resumeAfterRules = false;

  const messagesSuppression = [
    "Supprim√© : signal d√©fectueux entre Thionville et Luxembourg.",
    "Supprim√© : travaux impr√©vus sur la voie √† Metz.",
    "Supprim√© : passage √† niveau bloqu√© par un tracteur rebelle.",
    "Supprim√© : intemp√©ries, pluie diluvienne sur la ligne.",
    "Supprim√© : incident voyageur √† la gare de Nancy.",
    "Supprim√© : panne √©lectrique dans le tunnel de Bettembourg.",
    "Supprim√© : circulation perturb√©e par un arbre tomb√©.",
    "Supprim√© : probl√®me technique au niveau du mat√©riel roulant.",
    "Supprim√© : intervention d‚Äôurgence sur la cat√©naire.",
    "Supprim√© : personnel malade, service r√©duit.",
    "Supprim√© : contr√¥le al√©atoire des billets ralenti le d√©part.",
    "Supprim√© : le sable du Sahara obstrue la voie.",
    "Supprim√© : d√©rangement li√© aux op√©rations de d√©neigement.",
    "Supprim√© : probl√®me de coordination transfrontali√®re.",
    "Supprim√© : retard li√© √† un incident dans le spa du train.",
    "Supprim√© : fuite de fonte en fusion √† PAM.",
    "Supprim√© : l'agent de conduite a une urgence explosive.",
    "Supprim√© : le TGV avec Thibault, Franck et David √©tait prioritaire."
  ];

  function initGame() {
    train = [{x: 10, y: 10}];
    direction = {x: 1, y: 0};
    nextDirection = direction;
    score = 0;
    suppressions = [];
    oranges = [];
    vaches = [];
    tgvs = [];
    vacheFrequency = 60000; // une vache toutes les 60s au d√©but
    tgvFrequency = 12000;
    gameStopped = false;
    gamePaused = false;
    speedModifier = 0;
    resumeAfterRules = false;

    document.getElementById("score").textContent = score;
    document.getElementById("gameOverMessage").style.display = "none";
    document.getElementById("overlay").style.display = "none";

    // Annuler timers existants
    if (scheduleVachesTimeoutId) clearTimeout(scheduleVachesTimeoutId);
    if (increaseVacheFreqTimeoutId) clearTimeout(increaseVacheFreqTimeoutId);
    if (scheduleTGVTimeoutId) clearTimeout(scheduleTGVTimeoutId);
    if (increaseTGVFreqTimeoutId) clearTimeout(increaseTGVFreqTimeoutId);
    if (tgvStartTimeoutId) clearTimeout(tgvStartTimeoutId);

    // Planifier vaches
    scheduleVachesTimeoutId = setTimeout(scheduleVaches, vacheFrequency);
    increaseVacheFreqTimeoutId = setTimeout(increaseVacheFrequency, 15000);

    // Planifier TGV apr√®s 90 secondes
    tgvStartTimeoutId = setTimeout(startTGVs, 90000);

    placePerturbations();
    generateBetail();
    if (gameLoopTimeoutId) clearTimeout(gameLoopTimeoutId);
    gameLoop();

    // Chronom√®tre
    startTime = Date.now();
    document.getElementById("timer").textContent = "00:00";
    startTimer();
    updatePauseButton(false);
    requestAnimationFrame(resizeCanvas);
    pauseBtn.disabled = false;
  }

  function placePerturbations() {
    for (let i = 0; i < 10; i++) suppressions.push(randomFreePosition());
    for (let i = 0; i < 5; i++) oranges.push(randomFreePosition());
  }

  function randomFreePosition() {
    let pos;
    do {
      pos = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
    } while (isOccupied(pos));
    return pos;
  }

  function isOccupied(pos) {
    return train.some(p => p.x === pos.x && p.y === pos.y)
      || suppressions.some(p => p.x === pos.x && p.y === pos.y)
      || oranges.some(p => p.x === pos.x && p.y === pos.y)
      || (betail && betail.x === pos.x && betail.y === pos.y)
      || (tgvs && tgvs.some(convoy => convoy.segments.some(s => s.x === pos.x && s.y === pos.y)));
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    suppressions.forEach(p => {
      ctx.fillStyle = "red";
      ctx.fillRect(p.x * gridSize, p.y * gridSize, gridSize, gridSize);
    });

    oranges.forEach(p => {
      ctx.fillStyle = "orange";
      ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8);
    });

    if (betail) {
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(betail.x * gridSize + gridSize/2, betail.y * gridSize + gridSize/2, gridSize/3, 0, 2 * Math.PI);
      ctx.fill();
    }

    vaches.forEach(band => {
      band.forEach(p => {
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(p.x * gridSize + gridSize/2, p.y * gridSize + gridSize/2, gridSize/3, 0, 2 * Math.PI);
        ctx.fill();
      });
    });

    if (tgvs) {
      tgvs.forEach(train => {
        train.segments.forEach((segment, index) => {
          if (segment.x < 0 || segment.x >= cols) return;
          ctx.fillStyle = index === 0 ? "#ff63ff" : "#7bf3ff";
          ctx.fillRect(segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4);
          if (index === 0) {
            ctx.fillStyle = "#1a1036";
            ctx.fillRect(segment.x * gridSize + gridSize/3, segment.y * gridSize + gridSize/3, gridSize/3, gridSize/3);
          }
        });
      });
    }    

    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? "#0ff" : "#088";
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  function update() {
    if (gameStopped || gamePaused) return;

    direction = nextDirection;
    let newHead = { x: train[0].x + direction.x, y: train[0].y + direction.y };

    // rebouclage √©cran
    if (newHead.x < 0) newHead.x = cols - 1;
    if (newHead.x >= cols) newHead.x = 0;
    if (newHead.y < 0) newHead.y = rows - 1;
    if (newHead.y >= rows) newHead.y = 0;

    // collisions
    if (train.some(p => p.x === newHead.x && p.y === newHead.y)) return gameOver("Auto collision !");
    if (vaches.some(band => band.some(p => p.x === newHead.x && p.y === newHead.y))) return gameOver("Votre train a percut√© des vaches !");
    if (tgvs.some(convoy => convoy.segments.some(p => p.x === newHead.x && p.y === newHead.y))) return gameOver("Collision avec un TGV prioritaire !");
    if (suppressions.some(p => p.x === newHead.x && p.y === newHead.y)) {
      const msg = messagesSuppression[Math.floor(Math.random() * messagesSuppression.length)];
      return gameOver(msg);
    }

    train.unshift(newHead);

    if (betail && newHead.x === betail.x && newHead.y === betail.y) {
      score++;
      document.getElementById("score").textContent = score;
      if (score > highscore) {
        highscore = score;
        document.getElementById("highscore").textContent = highscore;
        localStorage.setItem("highscore", highscore);
      }
      generateBetail();
    } else {
      train.pop();
    }

    // carr√© orange
    if (oranges.some(p => p.x === newHead.x && p.y === newHead.y)) {
      speedModifier = (Math.random() < 0.5) ? -150 : 150;
      setTimeout(() => { speedModifier = 0; }, 2000);
    }

    moveVaches();
    moveTGVs();    
  }

  function moveVaches() {
    vaches.forEach(band => band.forEach(v => v.x--));
    vaches = vaches.filter(band => band.some(v => v.x >= 0));
  }

    function moveTGVs() {
    tgvs.forEach(train => train.segments.forEach(s => s.x--));
    tgvs = tgvs.filter(train => train.segments.some(s => s.x >= -5));
  }

  function scheduleVaches() {
    if (gameStopped) return;
    if (gamePaused) {
      scheduleVachesTimeoutId = setTimeout(scheduleVaches, 500);
      return;
    }
    const size = Math.floor(Math.random() * 4) + 1;
    const yStart = Math.floor(Math.random() * (rows - size));
    const band = Array.from({ length: size }, (_, i) => ({ x: cols - 1, y: yStart + i }));
    vaches.push(band);
    scheduleVachesTimeoutId = setTimeout(scheduleVaches, vacheFrequency);
  }

  function increaseVacheFrequency() {
    if (vacheFrequency > 3000) {
      vacheFrequency -= 1000;
      increaseVacheFreqTimeoutId = setTimeout(increaseVacheFrequency, 60000);
    }
  }

  function startTGVs() {
    if (gameStopped) return;
    scheduleTGVs();
    increaseTGVFreqTimeoutId = setTimeout(increaseTGVFrequency, 45000);
  }

  function scheduleTGVs() {
    if (gameStopped) return;
    if (gamePaused) {
      scheduleTGVTimeoutId = setTimeout(scheduleTGVs, 500);
      return;
    }
    const wagons = Math.floor(Math.random() * 3) + 3; // 3 √† 5 wagons
    const totalSegments = wagons + 1; // +1 locomotive
    const y = Math.floor(Math.random() * rows);
    const segments = Array.from({ length: totalSegments }, (_, i) => ({ x: cols + i, y }));
    tgvs.push({ segments });
    scheduleTGVTimeoutId = setTimeout(scheduleTGVs, tgvFrequency);
  }

  function increaseTGVFrequency() {
    if (tgvFrequency > 4500) {
      tgvFrequency -= 1500;
      increaseTGVFreqTimeoutId = setTimeout(increaseTGVFrequency, 45000);
    }
  }

  function gameOver(message) {
    gameStopped = true;
    clearInterval(countdownInterval);
    if (scheduleVachesTimeoutId) clearTimeout(scheduleVachesTimeoutId);
    if (scheduleTGVTimeoutId) clearTimeout(scheduleTGVTimeoutId);
    if (increaseTGVFreqTimeoutId) clearTimeout(increaseTGVFreqTimeoutId);
    if (tgvStartTimeoutId) clearTimeout(tgvStartTimeoutId);
    if (gameLoopTimeoutId) clearTimeout(gameLoopTimeoutId);
    gamePaused = false;
    updatePauseButton(false);
    pauseBtn.disabled = true;
    resumeAfterRules = false;
    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
    const seconds = (elapsedTime % 60).toString().padStart(2, '0');
    const textHTML = `<p>${message}</p><p>Score: ${score}</p><p>Temps : ${minutes}:${seconds}</p>`;
    document.getElementById("gameOverText").innerHTML = textHTML;
    document.getElementById("overlay").style.display = "flex";
    document.getElementById("gameOverMessage").style.display = "block";
  }

  function gameLoop() {
    update();
    draw();
    if (!gameStopped) {
      const delay = Math.max(50, baseSpeed + speedModifier);
      gameLoopTimeoutId = setTimeout(gameLoop, delay);
    }
  }

  function generateBetail() {
    betail = randomFreePosition();
  }

  // contr√¥les
window.addEventListener("keydown", e => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
      e.preventDefault();
      handleDirection(e.key);
    }
  });
  document.getElementById("up").addEventListener("click", () => handleDirection("ArrowUp"));
  document.getElementById("down").addEventListener("click", () => handleDirection("ArrowDown"));
  document.getElementById("left").addEventListener("click", () => handleDirection("ArrowLeft"));
  document.getElementById("right").addEventListener("click", () => handleDirection("ArrowRight"));

  let touchStartPos = null;
  canvas.addEventListener("touchstart", e => {
    if (e.touches.length === 1) {
      touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  }, { passive: true });

  canvas.addEventListener("touchend", e => {
    if (!touchStartPos || e.changedTouches.length === 0) return;
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartPos.x;
    const dy = touch.clientY - touchStartPos.y;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    if (Math.max(absX, absY) < 20) return;
    if (absX > absY) {
      handleDirection(dx > 0 ? "ArrowRight" : "ArrowLeft");
    } else {
      handleDirection(dy > 0 ? "ArrowDown" : "ArrowUp");
    }
    touchStartPos = null;
  }, { passive: true });

  
  function handleDirection(key) {
    switch(key) {
      case "ArrowUp": if(direction.y !== 1) nextDirection = {x: 0, y: -1}; break;
      case "ArrowDown": if(direction.y !== -1) nextDirection = {x: 0, y: 1}; break;
      case "ArrowLeft": if(direction.x !== 1) nextDirection = {x: -1, y: 0}; break;
      case "ArrowRight": if(direction.x !== -1) nextDirection = {x: 1, y: 0}; break;
    }
  }

  // boutons fin de partie
  document.getElementById('restartBtn').addEventListener('click', () => initGame());
  document.getElementById('returnBtn').addEventListener('click', () => {
    window.location.href = 'index.html';
  });

  const pauseBtn = document.getElementById("pauseBtn");
  pauseBtn.disabled = true;
  function updatePauseButton(paused) {
    if (paused) {
      pauseBtn.innerHTML = '‚ñ∂<span>Jouer</span>';
    } else {
      pauseBtn.innerHTML = '‚è∏<span>Pause</span>';
    }
  }

  function togglePause() {
    if (gameStopped) return;
    gamePaused = !gamePaused;
    updatePauseButton(gamePaused);
    if (gamePaused) {
      pauseStartTime = Date.now();
      clearInterval(countdownInterval);
    } else {
      const pauseDuration = Date.now() - pauseStartTime;
      startTime += pauseDuration;
      startTimer();
    }
  }

  pauseBtn.addEventListener('click', togglePause);

  const rulesBtn = document.getElementById('rulesBtn');
  const rulesOverlay = document.getElementById('rulesOverlay');
  const closeRules = document.getElementById('closeRules');

  rulesBtn.addEventListener('click', () => {
    if (!gameStopped && !gamePaused && !pauseBtn.disabled) {
      togglePause();
      resumeAfterRules = true;
    } else {
      resumeAfterRules = false;
    }
    rulesOverlay.style.display = 'flex';
    closeRules.focus();
  });

  closeRules.addEventListener('click', () => {
    rulesOverlay.style.display = 'none';
    if (resumeAfterRules && gamePaused && !gameStopped) {
      togglePause();
    }
    resumeAfterRules = false;
    rulesBtn.focus();
  });

  rulesOverlay.addEventListener('click', (event) => {
    if (event.target === rulesOverlay) {
      rulesOverlay.style.display = 'none';
      if (resumeAfterRules && gamePaused && !gameStopped) {
        togglePause();
      }
      resumeAfterRules = false;
      rulesBtn.focus();
    }
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' && rulesOverlay.style.display === 'flex') {
      rulesOverlay.style.display = 'none';
      if (resumeAfterRules && gamePaused && !gameStopped) {
        togglePause();
      }
      resumeAfterRules = false;
      rulesBtn.focus();
    }
  });
  
  if (localStorage.getItem("highscore")) {
    highscore = parseInt(localStorage.getItem("highscore"));
    document.getElementById("highscore").textContent = highscore;
  }

  // bouton Jouer
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  startBtn.addEventListener('click', () => {
    startOverlay.style.display = 'none';
    initGame();
    const audio = document.getElementById("gameMusic");
    if (audio.paused) audio.play();
  });

  function startTimer() {
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(updateTimer, 1000);
    updateTimer();
  }

  function updateTimer() {
    let elapsed = Math.floor((Date.now() - startTime) / 1000);
    let minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
    let seconds = (elapsed % 60).toString().padStart(2, '0');
    document.getElementById("timer").textContent = `${minutes}:${seconds}`;
  }
})();
</script>

<script>
  // D√©marre la musique apr√®s un clic utilisateur si besoin
  document.addEventListener('DOMContentLoaded', function () {
    document.body.addEventListener('click', function () {
      const audio = document.getElementById("gameMusic");
      if (audio.paused) audio.play();
    }, { once: true });
  });
</script>
</body>
</html>
