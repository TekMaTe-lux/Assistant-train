<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Jeu de la B√©taill√®re</title>
  <!-- important pour l‚Äôoccupation d‚Äô√©cran totale + encoches iOS -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<style>
  :root{
    color-scheme: dark;
    --bg-color:#0b0f1a;
    --surface-color:rgba(11,20,35,.85);
    --surface-alt-color:rgba(6,14,26,.85);
    --text-color:#e0f0ff;
    --muted-text:rgba(224,240,255,.75);
    --accent-color:#00f0ff;
    --accent-strong:rgba(0,240,255,.85);
    --safe-bottom: calc(env(safe-area-inset-bottom) + 8px);
    --safe-top: env(safe-area-inset-top);
    --header-h: 56px;   /* hauteur visuelle du header */
    --info-h: 30px;     /* barre info compacte */
    --controls-pad: 180px;
  }

  *{ box-sizing:border-box }

  html, body{
    margin:0; padding:0;
    min-height:100svh; /* hauteur stable sur mobile */
    background: radial-gradient(circle at top,#0b0f1a 0%,#020308 60%,#000 100%);
    color:#00f6ff;
    font-family:'Orbitron','Segoe UI',sans-serif;
  }

  body{
    display:grid;
    grid-template-rows:auto 1fr; /* header en haut + zone centrale */
    position:relative;
  }

  body::before{
    content:"";
    position:fixed; inset:0;
    background-image:linear-gradient(45deg, rgba(0,240,255,.05) 25%, transparent 25%, transparent 50%, rgba(0,240,255,.05) 50%, rgba(0,240,255,.05) 75%, transparent 75%, transparent);
    background-size:70px 70px;
    opacity:.45; pointer-events:none; z-index:0;
  }

  /* ===== Header (haut) ===== */
  header{
    position:sticky; top:0; z-index:2;
    min-height: var(--header-h);
    display:grid; place-items:center;
    padding:8px 8px;
    text-transform:uppercase; letter-spacing:2px;
    font-size:clamp(1.4rem, 2.5vw, 2rem);
    color:var(--accent-color);
    text-shadow:0 0 12px var(--accent-strong), 0 0 22px rgba(0,240,255,.4);
    background: linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,0));
    backdrop-filter: blur(2px);
  }

  /* ===== Zone centrale ===== */
  #container{
    position: relative;
    display: grid;
    justify-items: center;   /* centre horizontal */
    align-content: start;    /* colle les enfants en haut */
    row-gap: 6px;            /* petit espace entre #info et le canvas */
    padding: 0 12px;
    padding-top: 0;          /* pas d‚Äôespace suppl√©mentaire sous le titre */
    padding-bottom: calc(120px + var(--safe-bottom));
    z-index: 1;
  }

  #gameWrapper{
    width: min(100vw - 24px, 540px);
    display: flex; align-items: center; justify-content: center;
    margin: 0 auto;          /* pas de marge verticale auto */
    align-self: start;       /* ancr√© en haut du conteneur */
    touch-action: none;
  }

  canvas{
    border:3px solid var(--accent-strong);
    border-radius:16px;
    box-shadow:0 0 22px rgba(0,240,255,.2), inset 0 0 12px rgba(0,240,255,.12);
    background:var(--surface-alt-color);
    display:block;
    width:100%; height:auto;
    aspect-ratio:1/1; max-width:100%;
    touch-action:none;
  }

  /* ===== Barre d‚Äôinfos ===== */
  #info{
    position: static;
    margin-top: 2px;         /* sous le titre */
    margin-bottom: 4px;      /* juste avant le canvas */
    font-size: clamp(12px, 3.6vw, 14px);
    line-height: 1.2;
    padding: 4px 10px;
    border: 1px solid rgba(0,240,255,.35);
    border-radius: 12px;
    background: var(--surface-color);
    display: flex; align-items: center; gap: 10px;
    white-space: nowrap;
    color: var(--muted-text);
    text-shadow: 0 0 6px rgba(0,240,255,.4);
    width: max-content; max-width: calc(100vw - 20px);
  }
  #info span{ color:var(--accent-color); font-weight:600; }
  #info span[aria-hidden="true"]{ color:var(--muted-text); font-weight:400; }

  /* ===== Contr√¥les bas ===== */
  #controlPanel{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom: var(--safe-bottom);
    width:min(100vw - 24px, 560px);
    display:grid;
    grid-template-columns: 1fr auto 1fr; /* gauche | centre | droite */
    align-items:end;
    column-gap:16px;
    z-index:4;
  }

  /* Pav√© directionnel centr√© */
  #touchControls{
    grid-column:2;
    justify-self:center;
    display:flex; flex-direction:column; align-items:center; gap:10px;
  }
  .up-row{ display:flex; justify-content:center; }
  .middle-row{ display:flex; justify-content:center; gap:12px; }

  /* Pause/R√®gles √† droite */
  .utility-buttons{
    grid-column:3;
    justify-self:end;
    display:flex; gap:10px; flex-wrap:wrap;
  }

  /* ===== Boutons ===== */
  button{
    font-family:inherit;
    transition:transform .18s ease, box-shadow .18s ease;
  }
  button:hover{ transform:translateY(-1px); box-shadow:0 0 18px rgba(0,240,255,.35); }
  button:focus-visible{ outline:2px solid var(--accent-color); outline-offset:3px; }
  button:disabled, button:disabled:hover{ cursor:not-allowed; transform:none; box-shadow:none; }

  #touchControls button,
  .utility-buttons button{
    width:64px; height:64px; font-size:24px; border-radius:16px;
    border:1px solid rgba(0,240,255,.35);
    background:linear-gradient(145deg, rgba(8,18,32,.95), rgba(4,10,20,.95));
    color:var(--text-color);
    box-shadow: inset 0 0 8px rgba(0,240,255,.25), 0 8px 18px rgba(0,0,0,.55);
    touch-action:manipulation;
    display:flex; align-items:center; justify-content:center; flex-direction:column; gap:2px;
    transition:transform .1s ease, box-shadow .1s ease;
  }
  #touchControls button:active,
  .utility-buttons button:active{
    transform:translateY(2px);
    box-shadow:inset 0 0 12px rgba(0,240,255,.5), 0 3px 8px rgba(0,0,0,.6);
  }
  #touchControls button:disabled,
  .utility-buttons button:disabled{ opacity:.45; box-shadow:none; }

  .utility-buttons button{
    width:60px; height:60px; font-size:20px; letter-spacing:.5px;
  }
  .utility-buttons button span{
    display:block; font-size:11px; margin-top:4px; color:var(--muted-text);
  }

  /* ===== Overlays / Modales ===== */
  #startOverlay{
    position:fixed; inset:0; background:rgba(11,15,26,.92);
    z-index:10000; display:flex; justify-content:center; align-items:center;
  }
  #startMessage{
    background:var(--surface-color); padding:28px 42px; border-radius:18px; text-align:center;
    border:2px solid rgba(0,240,255,.35); box-shadow:0 0 22px rgba(0,240,255,.35); color:var(--text-color);
  }
  #startMessage p{
    margin:0; font-size:1.2rem; letter-spacing:1px; color:var(--accent-color);
    text-shadow:0 0 12px rgba(0,240,255,.6);
  }
  #startMessage button{
    background:linear-gradient(135deg, var(--accent-color), rgba(0,166,210,.85));
    color:#002733; border:none; padding:12px 26px; margin-top:18px; border-radius:12px; font-size:18px;
    cursor:pointer; box-shadow:0 0 18px rgba(0,240,255,.4); font-weight:700; letter-spacing:1px;
  }

  #overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    z-index:9999; background-color:rgba(4,8,16,.7);
  }
  #gameOverMessage{
    background:rgba(11,20,35,.95); color:var(--text-color); text-align:center;
    padding:24px 28px; border-radius:16px; max-width:90vw; width:320px;
    box-shadow:0 0 24px rgba(0,240,255,.35); border:1px solid rgba(0,240,255,.35); font-size:1.2rem;
  }
  #gameOverMessage button{
    font-size:1.1rem; padding:10px 18px; margin:8px 10px 0 10px; border-radius:10px;
    border:1px solid rgba(0,240,255,.4);
    background:linear-gradient(135deg, var(--accent-color), rgba(0,150,210,.85));
    color:#00202a; cursor:pointer; font-weight:600; box-shadow:0 0 16px rgba(0,240,255,.3);
  }

  .modal{
    position:fixed; inset:0; background:rgba(0,0,0,.75);
    display:flex; justify-content:center; align-items:center; z-index:11000;
  }
  .modal-content{
    background:rgba(9,18,32,.95); border:2px solid rgba(0,240,255,.35);
    border-radius:18px; padding:24px; width:min(90vw, 420px);
    color:var(--text-color); text-align:left; box-shadow:0 0 24px rgba(0,240,255,.25);
  }
  .modal-content h2{
    margin-top:0; text-align:center; letter-spacing:1px; color:var(--accent-color);
    text-shadow:0 0 12px rgba(0,240,255,.5);
  }
  .modal-content ul{
    padding-left:18px; line-height:1.5; font-size:.95rem; color:var(--muted-text);
  }
  #closeRules{
    width:100%; margin-top:18px; padding:12px 16px; font-size:1rem; border-radius:12px;
    border:1px solid rgba(0,240,255,.4);
    background:linear-gradient(135deg, var(--accent-color), rgba(0,150,210,.85));
    color:#00242f; font-weight:600; cursor:pointer; box-shadow:0 6px 14px rgba(0,240,255,.25);
  }

  /* ===== Responsif ===== */
  @media (min-width:768px){
    #touchControls button, .utility-buttons button{ width:70px; height:70px; }
    #info{ top: calc(var(--safe-top) + var(--header-h) + 6px); }
  }
  @media (max-width:380px){
    #touchControls button, .utility-buttons button{ width:56px; height:56px; }
  }
</style>

</head>
<body>
  <header>Jeu de la B√©taill√®re</header>

  <!-- √âcran de d√©marrage -->
  <div id="startOverlay">
    <div id="startMessage">
      <p>üöÜ Pr√™t √† d√©marrer ?</p>
      <button id="startBtn">Jouer</button>
    </div>
  </div>

  <!-- Zone centrale -->
  <div id="container">
    <div id="info" role="status" aria-live="polite">
      Score : <span id="score">0</span>
      <span aria-hidden="true">‚Ä¢</span>
      Record : <span id="highscore">0</span>
      <span aria-hidden="true">‚Ä¢</span>
      Temps : <span id="timer">00:00</span>
    </div>

    <div id="gameWrapper">
      <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>
  </div>

  <!-- Contr√¥les FIXES en bas -->
  <div id="controlPanel" aria-label="Pav√© directionnel et actions">
    <div id="touchControls" aria-label="Contr√¥les directionnels">
      <div class="up-row">
        <button id="up" aria-label="Haut">‚ñ≤</button>
      </div>
      <div class="middle-row">
        <button id="left" aria-label="Gauche">‚óÄ</button>
        <button id="down" aria-label="Bas">‚ñº</button>
        <button id="right" aria-label="Droite">‚ñ∂</button>
      </div>
    </div>

    <!-- √âpingl√©s bas droite -->
    <div class="utility-buttons">
      <button id="pauseBtn" aria-label="Mettre en pause le jeu">‚è∏<span>Pause</span></button>
      <button id="rulesBtn" aria-label="Afficher les r√®gles">‚ÑπÔ∏è<span>R√®gles</span></button>
    </div>
  </div>

  <!-- √âcran Game Over -->
  <div id="overlay">
    <div id="gameOverMessage" style="display:none;">
      <div id="gameOverText"></div>
      <button id="restartBtn">Rejouer</button>
      <button id="returnBtn">Retour</button>
    </div>
  </div>

  <!-- Musique -->
  <audio id="gameMusic" loop>
    <source src="https://raw.githubusercontent.com/TekMaTe-lux/Assistant-train/main/Tek'Ma'Te%20-%20Power%20of%20the%20SNCF%20jingle.mp3" type="audio/mpeg">
    Votre navigateur ne supporte pas l‚Äôaudio.
  </audio>

  <!-- R√®gles -->
  <div id="rulesOverlay" class="modal" style="display:none;">
    <div class="modal-content">
      <h2>R√®gles express</h2>
      <ul>
        <li>Collectez le b√©tail lumineux pour marquer des points.</li>
        <li>√âvitez les zones rouges (trains supprim√©s), les carr√©s oranges vous r√©servent des surprises.</li>
        <li>Attention aux vaches et aux TGV prioritaires qui traversent la ligne.</li>
        <li>Apr√®s 90 secondes, les TGV arrivent plus souvent. Restez concentr√© !</li>
        <li>Utilisez les fl√®ches ou glissez sur l'√©cran pour diriger votre train.</li>
        <li>Toutes les 60 s, un train de fret s'engage et tombe en panne, puis repart. Le percuter met fin √† la partie.</li>
      </ul>
      <button id="closeRules">Fermer</button>
    </div>
  </div>

  <!-- ===== Script de jeu ===== -->
  <script>
  (() => {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const headerEl = document.querySelector("header");
    const infoBar  = document.getElementById("info");
    const controlPanel = document.getElementById("controlPanel");
    const gameWrapper  = document.getElementById("gameWrapper");
    let cols = 20, rows = 20, gridSize = 20;

    /* --- boucle stable au rAF --- */
    let rafId = null, acc = 0, lastTs = 0;
    /* --- verrouillage de la taille du canvas pendant la partie --- */
    let lockCanvasSize = false;

    function resizeCanvas(force = false){
      if (lockCanvasSize && !force) return; // on ignore les petits resize pendant la partie

      // mesure les √©l√©ments (m√™me s'ils sont fixed)
      const headerHeight   = headerEl ? headerEl.offsetHeight : 0;
      const infoHeight     = infoBar ? infoBar.offsetHeight : 0;
      const controlsHeight = controlPanel ? controlPanel.offsetHeight : 0;

      const verticalPadding = 48; // marge de respiration
      const availableHeight = window.innerHeight - headerHeight - infoHeight - controlsHeight - verticalPadding;
      const availableWidth  = gameWrapper.clientWidth || window.innerWidth;

      let size = Math.min(availableWidth, availableHeight);
      if (!size || size <= 0) size = availableWidth;

      const minSize = Math.min(availableWidth, 320);
      if (size < minSize) size = minSize;

      // üëâ taille arrondie au multiple de la grille (√©vite les demi-pixels)
      size = Math.floor(size / cols) * cols;
      if (size < cols) size = cols;

      canvas.style.width = canvas.style.height = `${size}px`;
      canvas.width = canvas.height = size;
      gridSize = size / cols;
    }

    window.addEventListener("resize", () => requestAnimationFrame(() => resizeCanvas()));
    window.addEventListener("orientationchange", () => setTimeout(() => resizeCanvas(true), 300));
    // petit timeout pour laisser iOS stabiliser la barre d‚ÄôURL
    setTimeout(() => resizeCanvas(true), 50);

    /* ====== √©tat du jeu ====== */
    let train, direction, nextDirection, score, highscore = 0;
    let baseSpeed = 200, speedModifier = 0;
    let betail, suppressions, oranges, vaches, tgvs;
    let vacheFrequency, scheduleVachesTimeoutId, increaseVacheFreqTimeoutId;
    let tgvFrequency, scheduleTGVTimeoutId, increaseTGVFreqTimeoutId, tgvStartTimeoutId;
    let gameStopped, gamePaused, countdownInterval, startTime, gameLoopTimeoutId;
    let pauseStartTime = 0;
    let resumeAfterRules = false;

    /* ====== FRET (nouvelle difficult√©) ====== */
    let freight = null;                  // { state, segments[], until, dir:{x,y}, stopCoord, speedSteps, step }
    let scheduleFreightTimeoutId;
    const FREIGHT_PERIOD   = 60000;      // spawn toutes les 60 s
    const FREIGHT_STOP_MS  = 3000;       // arr√™t court avant panne
    const FREIGHT_BREAK_MS = 10000;      // panne 10 s
    const FREIGHT_COLOR    = '#7b5b3a';  // brun

    const messagesSuppression = [
      "Supprim√© : signal d√©fectueux entre Thionville et Luxembourg.",
      "Supprim√© : travaux impr√©vus sur la voie √† Metz.",
      "Supprim√© : passage √† niveau bloqu√© par un tracteur rebelle.",
      "Supprim√© : intemp√©ries, pluie diluvienne sur la ligne.",
      "Supprim√© : incident voyageur √† la gare de Nancy.",
      "Supprim√© : panne √©lectrique dans le tunnel de Bettembourg.",
      "Supprim√© : circulation perturb√©e par un arbre tomb√©.",
      "Supprim√© : probl√®me technique au niveau du mat√©riel roulant.",
      "Supprim√© : intervention d‚Äôurgence sur la cat√©naire.",
      "Supprim√© : personnel malade, service r√©duit.",
      "Supprim√© : contr√¥le al√©atoire des billets ralenti le d√©part.",
      "Supprim√© : le sable du Sahara obstrue la voie.",
      "Supprim√© : d√©rangement li√© aux op√©rations de d√©neigement.",
      "Supprim√© : probl√®me de coordination transfrontali√®re.",
      "Supprim√© : retard li√© √† un incident dans le spa du train.",
      "Supprim√© : fuite de fonte en fusion √† PAM.",
      "Supprim√© : l'agent de conduite a une urgence explosive.",
      "Supprim√© : le TGV avec Thibault, Franck et David √©tait prioritaire."
    ];

    function initGame(){
      train = [{x:10,y:10}];
      direction = {x:1,y:0};
      nextDirection = direction;
      score = 0;
      suppressions = [];
      oranges = [];
      vaches = [];
      tgvs = [];
      vacheFrequency = 60000;
      tgvFrequency = 12000;
      gameStopped = false;
      gamePaused = false;
      speedModifier = 0;
      resumeAfterRules = false;

      /* reset fret */
      freight = null;
      if (scheduleFreightTimeoutId) clearTimeout(scheduleFreightTimeoutId);
      scheduleFreightTimeoutId = setTimeout(scheduleFreight, FREIGHT_PERIOD);

      document.getElementById("score").textContent = score;
      document.getElementById("gameOverMessage").style.display = "none";
      document.getElementById("overlay").style.display = "none";

      if (scheduleVachesTimeoutId) clearTimeout(scheduleVachesTimeoutId);
      if (increaseVacheFreqTimeoutId) clearTimeout(increaseVacheFreqTimeoutId);
      if (scheduleTGVTimeoutId) clearTimeout(scheduleTGVTimeoutId);
      if (increaseTGVFreqTimeoutId) clearTimeout(increaseTGVFreqTimeoutId);
      if (tgvStartTimeoutId) clearTimeout(tgvStartTimeoutId);

      scheduleVachesTimeoutId = setTimeout(scheduleVaches, vacheFrequency);
      increaseVacheFreqTimeoutId = setTimeout(increaseVacheFrequency, 15000);
      tgvStartTimeoutId = setTimeout(startTGVs, 90000);

      placePerturbations();
      generateBetail();

      // loop + canvas
      lockCanvasSize = true;
      resizeCanvas(true);
      startLoop();

      // chrono
      startTime = Date.now();
      document.getElementById("timer").textContent = "00:00";
      startTimer();
      updatePauseButton(false);
      pauseBtn.disabled = false;
    }

    /* --- boucle rAF √† timestep fixe --- */
    function startLoop(){
      if (rafId) cancelAnimationFrame(rafId);
      acc = 0; lastTs = 0;
      rafId = requestAnimationFrame(loop);
    }
    function loop(ts){
      if (gameStopped){ rafId = null; return; }
      const step = Math.max(50, baseSpeed + speedModifier); // 200ms par d√©faut
      if (!lastTs) lastTs = ts;
      acc += ts - lastTs;
      lastTs = ts;

      // updates √† cadence fixe (limite pour √©viter la spirale)
      let safety = 0;
      while (acc >= step && safety < 4){
        update();
        acc -= step;
        safety++;
      }

      draw();
      rafId = requestAnimationFrame(loop);
    }

    function placePerturbations(){ for (let i=0;i<10;i++) suppressions.push(randomFreePosition()); for (let i=0;i<5;i++) oranges.push(randomFreePosition()); }
    function randomFreePosition(){ let pos; do{ pos={x:Math.floor(Math.random()*cols), y:Math.floor(Math.random()*rows)} } while(isOccupied(pos)); return pos; }
    function isOccupied(pos){
      return train.some(p=>p.x===pos.x&&p.y===pos.y)
        || suppressions.some(p=>p.x===pos.x&&p.y===pos.y)
        || oranges.some(p=>p.x===pos.x&&p.y===pos.y)
        || (betail && betail.x===pos.x && betail.y===pos.y)
        || (tgvs && tgvs.some(convoy=>convoy.segments.some(s=>s.x===pos.x&&s.y===pos.y)))
        || (freight && freight.segments && freight.segments.some(s => s.x===pos.x && s.y===pos.y)); // FRET occupe ses cases
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      suppressions.forEach(p=>{ ctx.fillStyle="red"; ctx.fillRect(p.x*gridSize, p.y*gridSize, gridSize, gridSize); });
      oranges.forEach(p=>{ ctx.fillStyle="orange"; ctx.fillRect(p.x*gridSize+4, p.y*gridSize+4, gridSize-8, gridSize-8); });
      if (betail){ ctx.fillStyle="yellow"; ctx.beginPath(); ctx.arc(betail.x*gridSize+gridSize/2, betail.y*gridSize+gridSize/2, gridSize/3, 0, 2*Math.PI); ctx.fill(); }
      vaches.forEach(band=> band.forEach(p=>{ ctx.fillStyle="#fef9c3"; ctx.beginPath(); ctx.arc(p.x*gridSize+gridSize/2, p.y*gridSize+gridSize/2, gridSize/3, 0, 2*Math.PI); ctx.fill(); }));

      if (tgvs){
        tgvs.forEach(train=>{
          train.segments.forEach((segment,index)=>{
            if (segment.x<0 || segment.x>=cols || segment.y<0 || segment.y>=rows) return;
            ctx.fillStyle = index===0 ? "#ff63ff" : "#7bf3ff";
            ctx.fillRect(segment.x*gridSize+2, segment.y*gridSize+2, gridSize-4, gridSize-4);
            if(index===0){ ctx.fillStyle="#1a1036"; ctx.fillRect(segment.x*gridSize+gridSize/3, segment.y*gridSize+gridSize/3, gridSize/3, gridSize/3); }
          });
        });
      }

      /* FRET (dessin brun) */
      if (freight && freight.segments){
        freight.segments.forEach((s, idx) => {
          if (s.x<0 || s.x>=cols || s.y<0 || s.y>=rows) return;
          ctx.fillStyle = FREIGHT_COLOR;
          ctx.fillRect(s.x*gridSize+1, s.y*gridSize+1, gridSize-2, gridSize-2);
          if (idx === 0 && (freight.state === 'moving' || freight.state === 'leaving')){
            ctx.fillStyle = '#4e3724';
            ctx.fillRect(s.x*gridSize + gridSize/3, s.y*gridSize + gridSize/3, gridSize/3, gridSize/3);
          }
        });
      }

      train.forEach((pos,i)=>{ ctx.fillStyle = (i===0) ? "#00f0ff" : "#006c8b"; ctx.fillRect(pos.x*gridSize+1, pos.y*gridSize+1, gridSize-2, gridSize-2); });
    }

    function update(){
      if (gameStopped || gamePaused) return;
      direction = nextDirection;
      let newHead = { x: train[0].x + direction.x, y: train[0].y + direction.y };
      if (newHead.x<0) newHead.x=cols-1; if (newHead.x>=cols) newHead.x=0;
      if (newHead.y<0) newHead.y=rows-1; if (newHead.y>=rows) newHead.y=0;

      if (train.some(p=>p.x===newHead.x&&p.y===newHead.y)) return gameOver("Auto collision !");
      if (vaches.some(band=>band.some(p=>p.x===newHead.x&&p.y===newHead.y))) return gameOver("Votre train a percut√© des vaches !");
      if (tgvs.some(convoy=>convoy.segments.some(p=>p.x===newHead.x&&p.y===newHead.y))) return gameOver("Collision avec un TGV prioritaire !");
      /* Collision fret (quel que soit l‚Äô√©tat) */
      if (freight && freight.segments && freight.segments.some(p=>p.x===newHead.x && p.y===newHead.y)){
        const why = (freight.state === 'broken')
          ? "Collision avec un train de fret en panne !"
          : "Collision avec un train de fret !";
        return gameOver(why);
      }

      if (suppressions.some(p=>p.x===newHead.x&&p.y===newHead.y)){
        const msg = messagesSuppression[Math.floor(Math.random()*messagesSuppression.length)];
        return gameOver(msg);
      }

      train.unshift(newHead);
      if (betail && newHead.x===betail.x && newHead.y===betail.y){
        score++; document.getElementById("score").textContent = score;
        if (score > highscore){ highscore = score; document.getElementById("highscore").textContent = highscore; localStorage.setItem("highscore", highscore); }
        generateBetail();
      } else { train.pop(); }

      // Effet orange (acc√©l√®re/ralentit 2 s)
      if (oranges.some(p=>p.x===newHead.x&&p.y===newHead.y)){
        speedModifier = (Math.random()<0.5) ? -150 : 150;
        setTimeout(()=>{ speedModifier=0; }, 2000);
      }

      moveVaches();
      moveTGVs();
      updateFreight(); // <--- avance/√©tats du fret
    }

    function moveVaches(){ vaches.forEach(band=> band.forEach(v=> v.x--)); vaches = vaches.filter(band=> band.some(v=> v.x>=0)); }
    function moveTGVs(){ tgvs.forEach(train=> train.segments.forEach(s=> s.x--)); tgvs = tgvs.filter(train=> train.segments.some(s=> s.x>=-5)); }

    function scheduleVaches(){
      if (gameStopped) return;
      if (gamePaused){ scheduleVachesTimeoutId = setTimeout(scheduleVaches, 500); return; }
      const size = Math.floor(Math.random()*4)+1;
      const yStart = Math.floor(Math.random()*(rows - size));
      const band = Array.from({length:size}, (_,i)=>({x:cols-1, y:yStart+i}));
      vaches.push(band);
      scheduleVachesTimeoutId = setTimeout(scheduleVaches, vacheFrequency);
    }
    function increaseVacheFrequency(){ if (vacheFrequency>3000){ vacheFrequency -= 1000; increaseVacheFreqTimeoutId = setTimeout(increaseVacheFrequency, 60000); } }
    function startTGVs(){ if (gameStopped) return; scheduleTGVs(); increaseTGVFreqTimeoutId = setTimeout(increaseTGVFrequency, 45000); }
    function scheduleTGVs(){
      if (gameStopped) return;
      if (gamePaused){ scheduleTGVTimeoutId = setTimeout(scheduleTGVs, 500); return; }
      const wagons = Math.floor(Math.random()*3)+3; // 3‚Äì5
      const totalSegments = wagons + 1;             // + loco
      const y = Math.floor(Math.random()*rows);
      const segments = Array.from({length:totalSegments}, (_,i)=>({x:cols+i, y}));
      tgvs.push({segments});
      scheduleTGVTimeoutId = setTimeout(scheduleTGVs, tgvFrequency);
    }
    function increaseTGVFrequency(){ if (tgvFrequency>4500){ tgvFrequency -= 1500; increaseTGVFreqTimeoutId = setTimeout(increaseTGVFrequency, 45000); } }

    /* ============ FRET : spawn, d√©placements, √©tats ============ */
    function randInt(min, max){ return min + Math.floor(Math.random() * (max - min + 1)); }

    function scheduleFreight(){
      if (gameStopped) return;
      if (gamePaused){ scheduleFreightTimeoutId = setTimeout(scheduleFreight, 500); return; }
      if (!freight){ freight = createFreight(); }
      // Replanifie la tentative suivante m√™me si un fret est d√©j√† pr√©sent (un seul actif)
      scheduleFreightTimeoutId = setTimeout(scheduleFreight, FREIGHT_PERIOD);
    }

    function createFreight(){
      const length = randInt(5,10);
      const side = Math.floor(Math.random()*4); // 0: gauche->droite, 1: droite->gauche, 2: haut->bas, 3: bas->haut
      let dir = {x:0,y:0};
      let segments = [];
      let stopCoord = 0;

      if (side === 0){ // gauche -> droite
        dir = {x:1,y:0};
        const y = Math.floor(Math.random()*rows);
        segments = Array.from({length}, (_,i)=>({ x: -1 - i, y })); // t√™te √† -1
        stopCoord = Math.floor(cols * (0.45 + Math.random()*0.1));  // x cible centre
      } else if (side === 1){ // droite -> gauche
        dir = {x:-1,y:0};
        const y = Math.floor(Math.random()*rows);
        segments = Array.from({length}, (_,i)=>({ x: cols + i, y }));
        stopCoord = Math.floor(cols * (0.45 + Math.random()*0.1));  // x cible centre
      } else if (side === 2){ // haut -> bas
        dir = {x:0,y:1};
        const x = Math.floor(Math.random()*cols);
        segments = Array.from({length}, (_,i)=>({ x, y: -1 - i }));
        stopCoord = Math.floor(rows * (0.45 + Math.random()*0.1));  // y cible centre
      } else { // bas -> haut
        dir = {x:0,y:-1};
        const x = Math.floor(Math.random()*cols);
        segments = Array.from({length}, (_,i)=>({ x, y: rows + i }));
        stopCoord = Math.floor(rows * (0.45 + Math.random()*0.1));  // y cible centre
      }

      return {
        state: 'moving',                 // moving -> stopped -> broken -> leaving
        segments,
        dir,
        stopCoord,
        until: 0,
        speedSteps: 3,                   // plus lent que le joueur/TGV
        step: 0
      };
    }

    function updateFreight(){
      if (!freight || gameStopped || gamePaused) return;

      switch (freight.state){
        case 'moving': {
          maybeAdvanceFreight();
          const head = freight.segments[0];
          if (!head) break;

          // condition d'arr√™t "pr√®s du centre" selon l'axe
          if (freight.dir.x !== 0){ // mouvement horizontal -> on check x
            if ((freight.dir.x > 0 && head.x >= freight.stopCoord)
             || (freight.dir.x < 0 && head.x <= freight.stopCoord)){
              freight.state = 'stopped';
              freight.until = Date.now() + FREIGHT_STOP_MS;
            }
          } else { // vertical -> on check y
            if ((freight.dir.y > 0 && head.y >= freight.stopCoord)
             || (freight.dir.y < 0 && head.y <= freight.stopCoord)){
              freight.state = 'stopped';
              freight.until = Date.now() + FREIGHT_STOP_MS;
            }
          }
          break;
        }

        case 'stopped': {
          if (Date.now() >= freight.until){
            freight.state = 'broken';
            freight.until = Date.now() + FREIGHT_BREAK_MS; // panne 10 s
          }
          break;
        }

        case 'broken': {
          // bloqu√© sur place
          if (Date.now() >= freight.until){
            freight.state = 'leaving'; // repart dans la m√™me direction
          }
          break;
        }

        case 'leaving': {
          maybeAdvanceFreight();
          // despawn quand enti√®rement hors champ (marge de 5)
          const visible = freight.segments.some(s => s.x >= -5 && s.x < cols+5 && s.y >= -5 && s.y < rows+5);
          if (!visible){ freight = null; }
          break;
        }
      }
    }

    function maybeAdvanceFreight(){
      freight.step = (freight.step + 1) % freight.speedSteps;
      if (freight.step !== 0) return;
      // pousse chaque segment dans la direction du fret
      freight.segments.forEach(s => {
        s.x += freight.dir.x;
        s.y += freight.dir.y;
      });
    }

    function gameOver(message){
      gameStopped = true;
      clearInterval(countdownInterval);
      if (scheduleVachesTimeoutId) clearTimeout(scheduleVachesTimeoutId);
      if (scheduleTGVTimeoutId) clearTimeout(scheduleTGVTimeoutId);
      if (increaseTGVFreqTimeoutId) clearTimeout(increaseTGVFreqTimeoutId);
      if (tgvStartTimeoutId) clearTimeout(tgvStartTimeoutId);
      if (gameLoopTimeoutId) clearTimeout(gameLoopTimeoutId);
      if (scheduleFreightTimeoutId) clearTimeout(scheduleFreightTimeoutId); // stop fret scheduler
      if (rafId) cancelAnimationFrame(rafId), rafId = null;
      gamePaused = false; updatePauseButton(false); pauseBtn.disabled = true; resumeAfterRules=false;
      lockCanvasSize = false;

      const elapsedTime = Math.floor((Date.now()-startTime)/1000);
      const minutes = Math.floor(elapsedTime/60).toString().padStart(2,'0');
      const seconds = (elapsedTime%60).toString().padStart(2,'0');
      const textHTML = `<p>${message}</p><p>Score: ${score}</p><p>Temps : ${minutes}:${seconds}</p>`;
      document.getElementById("gameOverText").innerHTML = textHTML;
      document.getElementById("overlay").style.display = "flex";
      document.getElementById("gameOverMessage").style.display = "block";
    }

    function generateBetail(){ betail = randomFreePosition(); }

    // contr√¥les
    window.addEventListener("keydown", e => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)){ e.preventDefault(); handleDirection(e.key); }
    });
    document.getElementById("up").addEventListener("click",   ()=>handleDirection("ArrowUp"));
    document.getElementById("down").addEventListener("click", ()=>handleDirection("ArrowDown"));
    document.getElementById("left").addEventListener("click", ()=>handleDirection("ArrowLeft"));
    document.getElementById("right").addEventListener("click",()=>handleDirection("ArrowRight"));

    let touchStartPos=null;
    canvas.addEventListener("touchstart", e=>{
      if (e.touches.length===1){ touchStartPos={x:e.touches[0].clientX, y:e.touches[0].clientY}; }
    }, {passive:true});
    canvas.addEventListener("touchend", e=>{
      if (!touchStartPos || e.changedTouches.length===0) return;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStartPos.x;
      const dy = touch.clientY - touchStartPos.y;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      if (Math.max(absX,absY) < 20) return;
      if (absX > absY){ handleDirection(dx>0 ? "ArrowRight" : "ArrowLeft"); }
      else{ handleDirection(dy>0 ? "ArrowDown" : "ArrowUp"); }
      touchStartPos=null;
    }, {passive:true});

    function handleDirection(key){
      switch(key){
        case "ArrowUp":    if(direction.y!== 1) nextDirection={x:0,y:-1}; break;
        case "ArrowDown":  if(direction.y!==-1) nextDirection={x:0,y: 1}; break;
        case "ArrowLeft":  if(direction.x!== 1) nextDirection={x:-1,y:0}; break;
        case "ArrowRight": if(direction.x!==-1) nextDirection={x: 1,y:0}; break;
      }
    }

    document.getElementById('restartBtn').addEventListener('click', ()=> initGame());
    document.getElementById('returnBtn').addEventListener('click', ()=> { window.location.href='https://www.labetaillere.fr/'; });

    const pauseBtn = document.getElementById("pauseBtn");
    pauseBtn.disabled = true;
    function updatePauseButton(paused){ pauseBtn.innerHTML = paused ? '‚ñ∂<span>Jouer</span>' : '‚è∏<span>Pause</span>'; }
    function togglePause(){
      if (gameStopped) return;
      gamePaused = !gamePaused; updatePauseButton(gamePaused);
      if (gamePaused){
        pauseStartTime=Date.now();
        clearInterval(countdownInterval);
        lockCanvasSize = false;               // autorise le redimensionnement en pause
      } else {
        const pauseDuration = Date.now()-pauseStartTime;
        startTime += pauseDuration; startTimer();
        lockCanvasSize = true;                // refige pendant le jeu
        requestAnimationFrame(() => resizeCanvas(true));
        // relance la boucle si elle a √©t√© mise en veille par le navigateur
        if (!rafId) startLoop();
      }
    }
    pauseBtn.addEventListener('click', togglePause);

    const rulesBtn = document.getElementById('rulesBtn');
    const rulesOverlay = document.getElementById('rulesOverlay');
    const closeRules = document.getElementById('closeRules');

    rulesBtn.addEventListener('click', ()=>{
      if (!gameStopped && !gamePaused && !pauseBtn.disabled){ togglePause(); resumeAfterRules=true; } else { resumeAfterRules=false; }
      rulesOverlay.style.display='flex'; closeRules.focus();
    });
    closeRules.addEventListener('click', ()=>{
      rulesOverlay.style.display='none';
      if (resumeAfterRules && gamePaused && !gameStopped){ togglePause(); }
      resumeAfterRules=false; rulesBtn.focus();
    });
    rulesOverlay.addEventListener('click', (e)=>{
      if (e.target===rulesOverlay){
        rulesOverlay.style.display='none';
        if (resumeAfterRules && gamePaused && !gameStopped){ togglePause(); }
        resumeAfterRules=false; rulesBtn.focus();
      }
    });
    document.addEventListener('keydown', (e)=>{
      if (e.key==='Escape' && rulesOverlay.style.display==='flex'){
        rulesOverlay.style.display='none';
        if (resumeAfterRules && gamePaused && !gameStopped){ togglePause(); }
        resumeAfterRules=false; rulesBtn.focus();
      }
    });

    if (localStorage.getItem("highscore")){
      highscore = parseInt(localStorage.getItem("highscore"));
      document.getElementById("highscore").textContent = highscore;
    }

    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    startBtn.addEventListener('click', ()=>{
      startOverlay.style.display='none';
      initGame();
      const audio = document.getElementById("gameMusic");
      if (audio.paused) audio.play();
    });

    function startTimer(){ if (countdownInterval) clearInterval(countdownInterval); countdownInterval = setInterval(updateTimer, 1000); updateTimer(); }
    function updateTimer(){
      let elapsed = Math.floor((Date.now()-startTime)/1000);
      let minutes = Math.floor(elapsed/60).toString().padStart(2,'0');
      let seconds = (elapsed%60).toString().padStart(2,'0');
      document.getElementById("timer").textContent = `${minutes}:${seconds}`;
    }
  })();
  </script>

  <!-- D√©marre la musique apr√®s un clic utilisateur si besoin -->
  <script>
    document.addEventListener('DOMContentLoaded', function(){
      document.body.addEventListener('click', function(){
        const audio = document.getElementById("gameMusic");
        if (audio.paused) audio.play();
      }, { once:true });
    });
  </script>

  <!-- Calibrage des hauteurs (visuel, pas obligatoire) -->
  <script>
  (function(){
    const root = document.documentElement;
    function calibrateTop(){
      const h = Math.round((document.querySelector('header')?.getBoundingClientRect().height) || 56);
      const i = Math.round((document.getElementById('info')?.getBoundingClientRect().height) || 28);
      root.style.setProperty('--header-h', h + 'px');
      root.style.setProperty('--info-h',   i + 'px');
    }
    window.addEventListener('load', ()=>{ calibrateTop(); setTimeout(calibrateTop, 60); });
    window.addEventListener('orientationchange', ()=> setTimeout(calibrateTop, 250));
  })();
  </script>

</body>
</html>
