<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Scan SIRI Lite - Voies</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1120;
      color: #e5e7eb;
      margin: 0;
      padding: 20px;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }
    .card {
      max-width: 900px;
      margin: 0 auto;
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 16px 20px 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    button {
      cursor: pointer;
      border-radius: 999px;
      padding: 8px 16px;
      border: none;
      font-size: 0.9rem;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    #scan-btn {
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
    }
    #download-btn {
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #4b5563;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    pre {
      background: #020617;
      color: #bbf7d0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      max-height: 400px;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .small {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Scanner des num√©ros de voie (SIRI Lite EstimatedTimetable)</h1>
    <p style="font-size:0.9rem; color:#d1d5db;">
      Ce petit outil appelle le flux public
      <code>sncf-siri-lite-estimated-timetable</code> et extrait
      <strong>uniquement les arr√™ts qui ont une voie (Arrival/DeparturePlatformName)</strong>.
    </p>

    <div style="margin:12px 0 10px;">
      <button id="scan-btn">üîç Scanner le flux</button>
      <button id="download-btn" disabled>üíæ T√©l√©charger le JSON</button>
    </div>

    <pre id="output">Clique sur "Scanner le flux" pour commencer‚Ä¶</pre>

    <p class="small">
      Remarque : les voies ne sont pas toujours publi√©es par SNCF. Si le r√©sultat est 0, ce n‚Äôest pas un bug,
      c‚Äôest probablement que la zone ou le jour ne renvoient aucune voie dans SIRI Lite.
    </p>
  </div>


<script>
  const SIRI_URL = 'https://proxy.transport.data.gouv.fr/resource/sncf-siri-lite-estimated-timetable';
  const SIRI_NS = 'http://www.siri.org.uk/siri';

  const scanBtn = document.getElementById('scan-btn');
  const downloadBtn = document.getElementById('download-btn');
  const outputEl = document.getElementById('output');

  let lastBlobUrl = null;
  let lastData = null;

  function getFirstTextNS(parent, localName) {
    const el = parent.getElementsByTagNameNS(SIRI_NS, localName)[0];
    if (!el) return null;
    const txt = (el.textContent || '').trim();
    return txt || null;
  }

  scanBtn.addEventListener('click', async () => {
    outputEl.textContent = '‚è≥ R√©cup√©ration du flux SIRI Lite EstimatedTimetable (XML)...\n';
    scanBtn.disabled = true;
    downloadBtn.disabled = true;

    try {
      const res = await fetch(SIRI_URL);
      const rawText = await res.text();

      if (!res.ok) {
        outputEl.textContent +=
          `\n‚ùå HTTP ${res.status} ${res.statusText}\n\nR√©ponse brute (d√©but) :\n` +
          rawText.slice(0, 500);
        return;
      }

      // üîÅ Parse XML
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(rawText, 'application/xml');

      const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
      if (parseError) {
        outputEl.textContent +=
          '\n‚ùå Erreur de parsing XML.\n\nD√©but de la r√©ponse :\n\n' +
          rawText.slice(0, 500);
        console.error('parsererror:', parseError.textContent);
        return;
      }

      // üîç On r√©cup√®re tous les EstimatedVehicleJourney
      const evjNodes = xmlDoc.getElementsByTagNameNS(SIRI_NS, 'EstimatedVehicleJourney');
      const allVehicleJourneysCount = evjNodes.length;

      const results = [];

      for (let i = 0; i < evjNodes.length; i++) {
        const evj = evjNodes[i];

        const lineRef = getFirstTextNS(evj, 'LineRef');
        const routeName = getFirstTextNS(evj, 'PublishedLineName');
        const datedVJRef = getFirstTextNS(evj, 'DatedVehicleJourneyRef');
        const vjRef = getFirstTextNS(evj, 'VehicleJourneyRef');
        const trainRef = datedVJRef || vjRef || null;

        // Tous les EstimatedCall de CE v√©hicule
        const callNodes = evj.getElementsByTagNameNS(SIRI_NS, 'EstimatedCall');

        for (let j = 0; j < callNodes.length; j++) {
          const call = callNodes[j];

          const stopPointRef = getFirstTextNS(call, 'StopPointRef');
          const stopName = getFirstTextNS(call, 'StopPointName');

          const arrivalPlatform = getFirstTextNS(call, 'ArrivalPlatformName');
          const departurePlatform = getFirstTextNS(call, 'DeparturePlatformName');

          // On ne garde que s'il y a une info de voie
          if (!arrivalPlatform && !departurePlatform) continue;

          const aimedArrivalTime =
            getFirstTextNS(call, 'AimedArrivalTime') ||
            getFirstTextNS(call, 'AimedArrival');

          const expectedArrivalTime =
            getFirstTextNS(call, 'ExpectedArrivalTime') ||
            getFirstTextNS(call, 'EstimatedArrivalTime');

          const aimedDepartureTime =
            getFirstTextNS(call, 'AimedDepartureTime') ||
            getFirstTextNS(call, 'AimedDeparture');

          const expectedDepartureTime =
            getFirstTextNS(call, 'ExpectedDepartureTime') ||
            getFirstTextNS(call, 'EstimatedDepartureTime');

          results.push({
            lineRef,
            routeName,
            trainRef,
            stopPointRef,
            stopName,
            aimedArrivalTime,
            expectedArrivalTime,
            aimedDepartureTime,
            expectedDepartureTime,
            arrivalPlatform,
            departurePlatform
          });
        }
      }

      lastData = results;

      let txt = '';
      txt += '‚úÖ Scan termin√©.\n\n';
      txt += `- V√©hicules trouv√©s (EstimatedVehicleJourney) : ${allVehicleJourneysCount}\n`;
      txt += `- Arr√™ts avec une voie : ${results.length}\n\n`;

      if (results.length === 0) {
        txt += 'Aucun champ ArrivalPlatformName / DeparturePlatformName trouv√© dans ce flux.\n';
      } else {
        txt += 'Extrait JSON (max 30 lignes) :\n\n';
        txt += JSON.stringify(results.slice(0, 30), null, 2);
        if (results.length > 30) {
          txt += `\n\n(... ${results.length - 30} lignes suppl√©mentaires non affich√©es)`;
        }
      }

      outputEl.textContent = txt;

      if (results.length > 0) {
        if (lastBlobUrl) {
          URL.revokeObjectURL(lastBlobUrl);
        }
        const blob = new Blob([JSON.stringify(results, null, 2)], {
          type: 'application/json'
        });
        lastBlobUrl = URL.createObjectURL(blob);
        downloadBtn.disabled = false;
      } else {
        downloadBtn.disabled = true;
      }
    } catch (err) {
      console.error(err);
      outputEl.textContent += '\n‚ùå Erreur JS : ' + err.message;
      downloadBtn.disabled = true;
    } finally {
      scanBtn.disabled = false;
    }
  });

  downloadBtn.addEventListener('click', () => {
    if (!lastBlobUrl || !lastData) return;

    const a = document.createElement('a');
    const now = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const filename =
      'siri_voies_' +
      now.getFullYear() +
      pad(now.getMonth() + 1) +
      pad(now.getDate()) + '_' +
      pad(now.getHours()) +
      pad(now.getMinutes()) +
      '.json';

    a.href = lastBlobUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  });
</script>

</body>
</html>
