<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Recherche trains CFL</title>
<style>
  :root {
    color-scheme: dark;
    --bg-page:#0b0f1a;
    --bg-card:#1a2238;
    --txt-main:#e0f0ff;
    --txt-dim:#7a8cae;
    --border:#2e374f;
    --accent:#e0f0ff;
    --accent-text:#0b0f1a;
  }
  body{
    background:var(--bg-page);
    color:var(--txt-main);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    margin:0;
    padding:16px;
    line-height:1.4;
  }
  header{
    margin-bottom:16px;
  }
  header h1{
    font-size:1.1rem;
    font-weight:600;
    margin:0 0 4px 0;
    color:var(--txt-main);
  }
  header p{
    margin:0;
    color:var(--txt-dim);
    font-size:0.9rem;
    line-height:1.3;
  }

  form#searchForm{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:16px;
    display:flex;
    flex-direction:column;
    gap:12px;
    box-shadow:0 12px 24px rgb(0 0 0 / 0.6);
  }
  .field{
    display:flex;
    flex-direction:column;
  }
  label{
    font-size:14px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  select,
  input[type=time],
  input[type=date]{
    width:100%;
    background:var(--bg-page);
    color:var(--txt-main);
    border:1px solid var(--border);
    border-radius:8px;
    padding:8px;
    font-size:16px;
  }
  button#searchBtn{
    background:var(--accent);
    color:var(--accent-text);
    border:none;
    border-radius:8px;
    font-weight:600;
    padding:10px 14px;
    font-size:16px;
    cursor:pointer;
  }
  #formError{
    color:#ff6b6b;
    font-size:14px;
    min-height:1em;
  }

  #results .card{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:12px;
    box-shadow:0 8px 24px rgba(0,0,0,0.6);
  }
  .trainHeader{
    font-size:16px;
    font-weight:600;
    margin-bottom:4px;
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:6px;
    color:var(--txt-main);
  }
  .badge{
    background:var(--accent);
    color:var(--accent-text);
    border-radius:6px;
    font-size:14px;
    font-weight:600;
    padding:2px 6px;
    line-height:1.2;
  }
  .mainline{
    font-size:15px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  .details{
    font-size:13px;
    color:var(--txt-dim);
  }

  footer{
    margin-top:24px;
    color:var(--txt-dim);
    font-size:12px;
    text-align:center;
    line-height:1.4;
  }
  footer a{
    color:var(--txt-main);
  }

  @media(min-width:480px){
    body{ max-width:480px; margin:0 auto; }
  }
</style>
</head>
<body>
<header>
  <h1>Recherche trains CFL</h1>
  <p>Données GTFS CFL filtrées (IC / RB / RE / TER / TGV). Résultats selon la date réelle et l'heure choisie.</p>
</header>

<form id="searchForm" onsubmit="return false;">
  <div class="field">
    <label for="fromStation">Départ</label>
    <select id="fromStation" required></select>
  </div>

  <div class="field">
    <label for="toStation">Arrivée</label>
    <select id="toStation" required></select>
  </div>

  <div class="field">
    <label for="dateDay">Date du trajet</label>
    <input id="dateDay" type="date" required>
  </div>

  <div class="field">
    <label for="minTime">Départ après</label>
    <input id="minTime" type="time" required>
  </div>

  <button id="searchBtn" type="button">Rechercher</button>
  <div id="formError"></div>
</form>

<section id="results"></section>

<footer>
  <div>Prototype horaire CFL – hors retards temps réel.</div>
  <div>Source : GTFS CFL (routes[1].txt, trips[1].txt, stop_times[1].txt, etc.). Traitement côté navigateur.</div>
</footer>

<script>
// ------------------------------------------------------
// 0. CONFIG
// ------------------------------------------------------
// Les .txt sont dans le sous-dossier CFL/
const DATA_PATH = "CFL/";

// Routes (lignes) CFL à garder
// 302=TGV, 301=TER, 300=RE, 299=RB, 297=IC
const ROUTE_IDS_ALLOWED = new Set(["302","301","300","299","297"]);

// Structures en mémoire
const CFL_DATA = {
  routesById: {},          // route_id -> {shortName,...}
  stopsById: {},           // stop_id -> {name,lat,lon}
  tripsById: {},           // trip_id -> {route_id,service_id,shortName,...}
  tripsStops: {},          // trip_id -> [ {stop_id,stop_name,arrival,departure,seq}, ... ]
  serviceCalendar: {},     // service_id -> { days:{}, startDate, endDate }
  serviceExceptions: {}    // service_id -> { yyyymmdd: 1|2, ... }
};

// ------------------------------------------------------
// 1. Utils: CSV parser & temps
// ------------------------------------------------------

// Découpe une ligne CSV en tenant compte des guillemets.
function splitCsvLine(line) {
  const out = [];
  let cur = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"') {
        if (line[i+1] === '"') {
          // guillemet échappé ""
          cur += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',') {
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
  }
  out.push(cur);
  return out;
}

// parseCSV : texte brut -> tableau d'objets {col:val,...}
function parseCSV(rawText) {
  const lines = rawText.trim().split(/\r?\n/);
  if (!lines.length) return [];
  const header = splitCsvLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = splitCsvLine(lines[i]);
    if (cols.length === 1 && cols[0] === "") continue; // ignore lignes vides
    const obj = {};
    for (let c = 0; c < header.length; c++) {
      obj[header[c]] = cols[c] !== undefined ? cols[c] : "";
    }
    rows.push(obj);
  }
  return rows;
}

// "HH:MM:SS" -> minutes depuis minuit
// ATTENTION : GTFS peut dépasser 24h (genre "25:10:00"), on accepte tel quel.
function toMinutesSinceMidnight(hms) {
  if (!hms || !hms.includes(":")) return null;
  const [hh, mm] = hms.split(":");
  const H = parseInt(hh,10);
  const M = parseInt(mm,10);
  return H*60 + M;
}

// "18:00" -> 1080
function hhmmToMinutes(hhmm) {
  if (!hhmm || !hhmm.includes(":")) return 0;
  const [h,m] = hhmm.split(":");
  return parseInt(h,10)*60 + parseInt(m,10);
}

// 1126 -> "18:46"
function minutesToHHMM(mins) {
  if (mins==null || isNaN(mins)) return "--:--";
  let m = mins;
  while (m < 0) m += 1440;
  while (m >= 1440) m -= 1440;
  const H = Math.floor(m/60);
  const M = m % 60;
  return (H<10?"0"+H:H)+":"+(M<10?"0"+M:M);
}

// yyyy-mm-dd -> { yyyymmdd:"20251028", weekdayIdx:0..6 }
// weekdayIdx: 0 = lundi, ..., 6 = dimanche
function dateInputToYMDinfo(dateStr) {
  const [Y,M,D] = dateStr.split("-");
  const yyyymmdd = Y+M+D;
  const jsDate = new Date(+Y, +M-1, +D);
  // JS getDay(): 0=dimanche..6=samedi
  // On veut lundi=0,...dimanche=6
  const map = {1:0,2:1,3:2,4:3,5:4,6:5,0:6};
  const weekdayIdx = map[jsDate.getDay()];
  return { yyyymmdd, weekdayIdx };
}

// filtre gares CFL réelles (pas "Gare routière")
function isRealTrainStation(name) {
  if (!name) return false;
  if (name === "Luxembourg, Gare Centrale") return true;
  if (name.endsWith(", Gare")) return true;
  return false;
}

// ------------------------------------------------------
// 2. Chargement des fichiers GTFS
// ------------------------------------------------------

async function loadAllData() {
  const [
    routesText,
    stopsText,
    tripsText,
    stopTimesText1,
    stopTimesText2,
    calText,
    calDatesText
  ] = await Promise.all([
    fetch(DATA_PATH + "routes[1].txt").then(r=>r.text()),
    fetch(DATA_PATH + "stops[1].txt").then(r=>r.text()),
    fetch(DATA_PATH + "trips[1].txt").then(r=>r.text()),
    fetch(DATA_PATH + "stop_times[1].txt").then(r=>r.text()),
    fetch(DATA_PATH + "stop_times[2].txt").then(r=>r.text()),
    fetch(DATA_PATH + "calendar[1].txt").then(r=>r.text()),
    fetch(DATA_PATH + "calendar_dates[1].txt").then(r=>r.text())
  ]);

  const routesRows     = parseCSV(routesText);
  const stopsRows      = parseCSV(stopsText);
  const tripsRows      = parseCSV(tripsText);
  const stopTimesRows  = parseCSV(stopTimesText1).concat(parseCSV(stopTimesText2));
  const calRows        = parseCSV(calText);
  const calDatesRows   = parseCSV(calDatesText);

  buildRoutes(routesRows);
  buildStops(stopsRows);
  buildTrips(tripsRows);
  buildServiceCalendar(calRows);
  buildServiceExceptions(calDatesRows);
  buildTripsStops(stopTimesRows);

  populateStationsSelect();
  prefillDateTime();
}

// ------------------------------------------------------
// 3. Construction des index (routes, stops, trips, calendriers)
// ------------------------------------------------------

function buildRoutes(rows) {
  for (const r of rows) {
    const route_id  = (r.route_id||"").trim();
    const agency_id = (r.agency_id||"").trim();
    if (!ROUTE_IDS_ALLOWED.has(route_id)) continue;
    if (agency_id !== "11") continue;
    CFL_DATA.routesById[route_id] = {
      shortName: r.route_short_name || "",
      longName:  r.route_long_name  || "",
      type:      r.route_type       || ""
    };
  }
}

function buildStops(rows) {
  for (const s of rows) {
    const stop_id   = (s.stop_id||"").trim();
    const stop_name = (s.stop_name||"").trim();
    if (!stop_id || !stop_name) continue;
    if (!isRealTrainStation(stop_name)) continue;
    CFL_DATA.stopsById[stop_id] = {
      name: stop_name,
      lat:  Number(s.stop_lat||"0"),
      lon:  Number(s.stop_lon||"0")
    };
  }
}

function buildTrips(rows) {
  for (const t of rows) {
    const trip_id    = (t.trip_id||"").trim();
    const route_id   = (t.route_id||"").trim();
    const service_id = (t.service_id||"").trim();
    if (!trip_id || !route_id || !service_id) continue;
    if (!CFL_DATA.routesById[route_id]) continue; // garde seulement CFL trains
    CFL_DATA.tripsById[trip_id] = {
      route_id,
      service_id,
      headsign:  (t.trip_headsign||"").trim(),
      shortName: (t.trip_short_name||"").trim(),
      direction: (t.direction_id||"").trim()
    };
  }
}

// calendar[1].txt
function buildServiceCalendar(rows) {
  for (const c of rows) {
    const service_id = (c.service_id||"").trim();
    if (!service_id) continue;
    CFL_DATA.serviceCalendar[service_id] = {
      days:{
        monday:    c.monday==="1",
        tuesday:   c.tuesday==="1",
        wednesday: c.wednesday==="1",
        thursday:  c.thursday==="1",
        friday:    c.friday==="1",
        saturday:  c.saturday==="1",
        sunday:    c.sunday==="1"
      },
      startDate:(c.start_date||"").trim(), // YYYYMMDD
      endDate:(c.end_date||"").trim()
    };
  }
}

// calendar_dates[1].txt
function buildServiceExceptions(rows) {
  for (const ce of rows) {
    const service_id = (ce.service_id||"").trim();
    const date = (ce.date||"").trim(); // YYYYMMDD
    const exc  = (ce.exception_type||"").trim(); // "1"=ajouté, "2"=supprimé
    if (!service_id || !date || !exc) continue;
    if (!CFL_DATA.serviceExceptions[service_id]) {
      CFL_DATA.serviceExceptions[service_id] = {};
    }
    CFL_DATA.serviceExceptions[service_id][date] = parseInt(exc,10); 
  }
}

// Vérifie si un service circule un certain jour
// weekdayIdx: 0=lundi,...,6=dimanche
function serviceRunsOnDate(service_id, yyyymmdd, weekdayIdx) {
  // exceptions d'abord
  const exMap = CFL_DATA.serviceExceptions[service_id];
  if (exMap && exMap[yyyymmdd] === 1) {
    return true; // ajouté exceptionnellement
  }
  if (exMap && exMap[yyyymmdd] === 2) {
    return false; // supprimé exceptionnellement
  }
  // sinon calendrier normal
  const base = CFL_DATA.serviceCalendar[service_id];
  if (!base) return false;
  if (yyyymmdd < base.startDate) return false;
  if (yyyymmdd > base.endDate)  return false;
  const field = [
    "monday","tuesday","wednesday","thursday","friday","saturday","sunday"
  ][weekdayIdx];
  return !!base.days[field];
}

// ------------------------------------------------------
// 4. Construire les parcours de chaque train (tripsStops)
// ------------------------------------------------------

function buildTripsStops(rows) {
  for (const st of rows) {
    const trip_id = (st.trip_id||"").trim();
    const stop_id = (st.stop_id||"").trim();
    if (!trip_id || !stop_id) continue;

    // garder seulement si le tripId est un train CFL et le stop une vraie gare
    if (!CFL_DATA.tripsById[trip_id]) continue;
    if (!CFL_DATA.stopsById[stop_id]) continue;

    if (!CFL_DATA.tripsStops[trip_id]) {
      CFL_DATA.tripsStops[trip_id] = [];
    }
    CFL_DATA.tripsStops[trip_id].push({
      stop_id,
      stop_name: CFL_DATA.stopsById[stop_id].name,
      arrival:   toMinutesSinceMidnight(st.arrival_time),
      departure: toMinutesSinceMidnight(st.departure_time),
      seq:       Number(st.stop_sequence||"0")
    });
  }

  // Trier les arrêts d'un même train et virer les trains qui n'ont pas au moins 2 gares
  for (const tripId in CFL_DATA.tripsStops) {
    const seqList = CFL_DATA.tripsStops[tripId];
    seqList.sort((a,b)=>a.seq-b.seq);
    if (seqList.length < 2) {
      delete CFL_DATA.tripsStops[tripId];
      delete CFL_DATA.tripsById[tripId];
    }
  }
}

// ------------------------------------------------------
// 5. Trouver les trains directs A -> B ce jour-là après heureX
// ------------------------------------------------------

function findDirectTrainsForDate(
  data,
  fromStopName,
  toStopName,
  minDepartureMinutes,
  yyyymmdd,
  weekdayIdx
) {
  // 1. Stop IDs pour les deux gares choisies
  const fromIds = new Set();
  const toIds   = new Set();
  for (const sid in data.stopsById) {
    if (data.stopsById[sid].name === fromStopName) fromIds.add(sid);
    if (data.stopsById[sid].name === toStopName)   toIds.add(sid);
  }

  const results = [];

  // 2. On parcourt chaque train (trip_id)
  for (const tripId in data.tripsStops) {
    const seqList  = data.tripsStops[tripId];
    const tripMeta = data.tripsById[tripId];
    if (!tripMeta) continue;

    // Vérifier si le train roule ce jour-là
    if (!serviceRunsOnDate(tripMeta.service_id, yyyymmdd, weekdayIdx)) continue;

    let depStop = null;
    let arrStop = null;

    // on cherche un arrêt de départ, puis un arrêt d'arrivée plus tard dans le même train
    for (let i = 0; i < seqList.length; i++) {
      const st = seqList[i];
      if (!depStop && fromIds.has(st.stop_id)) {
        depStop = st;
      }
      if (depStop && toIds.has(st.stop_id) && st.seq > depStop.seq) {
        arrStop = st;
        break;
      }
    }

    if (!depStop || !arrStop) continue;
    if (depStop.departure == null || depStop.departure < minDepartureMinutes) continue;

    // lister les arrêts intermédiaires entre depStop et arrStop
    const betweenStops = seqList
      .filter(s => s.seq >= depStop.seq && s.seq <= arrStop.seq)
      .map(s => ({
        name: s.stop_name,
        arr:  s.arrival,
        dep:  s.departure
      }));

    const routeMeta = data.routesById[tripMeta.route_id] || { shortName:"" };
    const label = tripMeta.shortName || routeMeta.shortName || "";

    results.push({
      trip_id: tripId,
      train_type: routeMeta.shortName || "",
      train_label: label,
      depart_station: depStop.stop_name,
      depart_time_min: depStop.departure,
      arrive_station: arrStop.stop_name,
      arrive_time_min: arrStop.arrival,
      duration_min: (arrStop.arrival ?? 0) - (depStop.departure ?? 0),
      stops: betweenStops
    });
  }

  // tri par heure réelle de départ
  results.sort((a,b)=>a.depart_time_min - b.depart_time_min);
  return results;
}

// ------------------------------------------------------
// 6. UI : gares + affichage résultats
// ------------------------------------------------------

function populateStationsSelect() {
  const namesSet = new Set();
  for (const sid in CFL_DATA.stopsById) {
    namesSet.add(CFL_DATA.stopsById[sid].name);
  }
  const sortedNames = Array.from(namesSet).sort((a,b)=>a.localeCompare(b,"fr"));

  const fromSel = document.getElementById("fromStation");
  const toSel   = document.getElementById("toStation");
  fromSel.innerHTML = "";
  toSel.innerHTML = "";

  for (const n of sortedNames) {
    const o1 = document.createElement("option");
    o1.value = n; o1.textContent = n;
    fromSel.appendChild(o1);

    const o2 = document.createElement("option");
    o2.value = n; o2.textContent = n;
    toSel.appendChild(o2);
  }
}

function prefillDateTime() {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth()+1).padStart(2,"0");
  const dd = String(now.getDate()).padStart(2,"0");
  const HH = String(now.getHours()).padStart(2,"0");
  const MM = String(now.getMinutes()).padStart(2,"0");

  const dateInput = document.getElementById("dateDay");
  const timeInput = document.getElementById("minTime");

  if (!dateInput.value) dateInput.value = `${yyyy}-${mm}-${dd}`;
  if (!timeInput.value) timeInput.value = `${HH}:${MM}`;
}

function renderResults(results) {
  const container = document.getElementById("results");
  container.innerHTML = "";

  if (!results.length) {
    const div = document.createElement("div");
    div.className = "card";
    div.style.color = "var(--txt-dim)";
    div.textContent = "Aucun train direct trouvé après cette heure.";
    container.appendChild(div);
    return;
  }

  for (const r of results) {
    const card = document.createElement("div");
    card.className = "card";

    const head = document.createElement("div");
    head.className = "trainHeader";

    const badge = document.createElement("span");
    badge.className = "badge";
    badge.textContent = r.train_type || "?";
    head.appendChild(badge);

    const lbl = document.createElement("span");
    lbl.textContent = r.train_label || "";
    head.appendChild(lbl);

    const mainline = document.createElement("div");
    mainline.className = "mainline";
    const depHHMM = minutesToHHMM(r.depart_time_min);
    const arrHHMM = minutesToHHMM(r.arrive_time_min);
    const dur = (r.duration_min!=null && r.duration_min>=0) ? r.duration_min+" min" : "";
    mainline.textContent =
      `${r.depart_station} ${depHHMM} → ${r.arrive_station} ${arrHHMM}` +
      (dur ? ` (${dur})` : "");

    const details = document.createElement("div");
    details.className = "details";
    const uniqueNames = [];
    for (const st of r.stops) {
      if (uniqueNames[uniqueNames.length-1] !== st.name) {
        uniqueNames.push(st.name);
      }
    }
    details.textContent = "Dessert : " + uniqueNames.join(" · ");

    card.appendChild(head);
    card.appendChild(mainline);
    card.appendChild(details);
    container.appendChild(card);
  }
}

// ------------------------------------------------------
// 7. Bouton "Rechercher"
// ------------------------------------------------------

function setupSearchHandler() {
  const btn = document.getElementById("searchBtn");
  const errBox = document.getElementById("formError");

  btn.addEventListener("click", function(){
    errBox.textContent = "";

    const fromStation = document.getElementById("fromStation").value;
    const toStation   = document.getElementById("toStation").value;
    const dateStr     = document.getElementById("dateDay").value;
    const minTimeStr  = document.getElementById("minTime").value;

    if (!fromStation || !toStation) {
      errBox.textContent = "Choisis une gare de départ et une gare d'arrivée.";
      return;
    }
    if (fromStation === toStation) {
      errBox.textContent = "Départ et arrivée identiques.";
      return;
    }
    if (!dateStr) {
      errBox.textContent = "Choisis une date.";
      return;
    }
    if (!minTimeStr) {
      errBox.textContent = "Choisis une heure minimale.";
      return;
    }

    const { yyyymmdd, weekdayIdx } = dateInputToYMDinfo(dateStr);
    const minDepartureMinutes = hhmmToMinutes(minTimeStr);

    const found = findDirectTrainsForDate(
      CFL_DATA,
      fromStation,
      toStation,
      minDepartureMinutes,
      yyyymmdd,
      weekdayIdx
    );

    renderResults(found);
  });
}

// ------------------------------------------------------
// 8. Init
// ------------------------------------------------------

document.addEventListener("DOMContentLoaded", async () => {
  await loadAllData();
  setupSearchHandler();
});
</script>
</body>
</html>
