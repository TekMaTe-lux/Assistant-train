<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Recherche trains CFL</title>
  <style>
    body { background:#0b0f1a; color:#e0f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; padding:16px; line-height:1.4; }
    header { margin-bottom:16px; }
    h1 { font-size:24px; margin:0 0 8px; }
    p { margin:0; color:#7a8cae; }
    form { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:16px; display:flex; flex-direction:column; gap:12px; }
    label { font-size:14px; color:#e0f0ff; display:block; margin-bottom:4px; }
    select, input[type=time] { width:100%; background:#0b0f1a; color:#e0f0ff; border:1px solid #2e374f; border-radius:8px; padding:8px; font-size:16px; }
    button { background:#e0f0ff; color:#0b0f1a; border:none; border-radius:8px; font-weight:600; padding:10px 14px; font-size:16px; cursor:pointer; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    #formError { color:#ff6b6b; font-size:14px; min-height:1em; }
    #results { min-height:48px; }
    .card { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:12px; box-shadow:0 8px 24px rgba(0,0,0,0.6); }
    .trainHeader { font-size:16px; font-weight:600; margin-bottom:4px; display:flex; align-items:center; flex-wrap:wrap; gap:6px; }
    .badge { background:#e0f0ff; color:#0b0f1a; border-radius:6px; font-size:14px; font-weight:600; padding:2px 6px; line-height:1.2; }
    .mainline { font-size:15px; font-weight:500; color:#e0f0ff; margin-bottom:4px; }
    .details { font-size:13px; color:#7a8cae; }
    .loading { font-size:15px; color:#7a8cae; }
  </style>
</head>
<body>
  <header>
    <h1>Recherche trains CFL</h1>
    <p>Données GTFS CFL filtrées (IC / RB / RE / TER / TGV)</p>
  </header>
  <form id="searchForm">
    <div>
      <label for="fromStation">Départ :</label>
      <select id="fromStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="toStation">Arrivée :</label>
      <select id="toStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="minTime">Départ après :</label>
      <input id="minTime" type="time" required>
    </div>
    <button id="searchBtn" type="button" disabled>Rechercher</button>
    <div id="formError"></div>
  </form>
  <div id="results" class="loading">Chargement des données GTFS…</div>
  <script>
    // 1. utils CSV
    function parseCSV(text) {
      const cleanedText = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/^\uFEFF/, "");
      const rows = [];
      let currentRow = [];
      let currentField = "";
      let inQuotes = false;
      for (let i = 0; i < cleanedText.length; i++) {
        const char = cleanedText[i];
        if (inQuotes) {
          if (char === '"') {
            const nextChar = cleanedText[i + 1];
            if (nextChar === '"') {
              currentField += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            currentField += char;
          }
        } else {
          if (char === '"') {
            inQuotes = true;
          } else if (char === ',') {
            currentRow.push(currentField);
            currentField = "";
          } else if (char === '\n') {
            currentRow.push(currentField);
            rows.push(currentRow);
            currentRow = [];
            currentField = "";
          } else {
            currentField += char;
          }
        }
      }
      if (inQuotes) {
        currentRow.push(currentField);
      } else if (currentField !== "" || currentRow.length) {
        currentRow.push(currentField);
      }
      if (currentRow.length) {
        rows.push(currentRow);
      }
      if (!rows.length) {
        return [];
      }
      const header = rows.shift().map((col, idx) => (idx === 0 ? col.replace(/^\uFEFF/, "") : col));
      const data = [];
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (row.length === 1 && row[0] === "") {
          continue;
        }
        const record = {};
        for (let j = 0; j < header.length; j++) {
          record[header[j]] = row[j] !== undefined ? row[j] : "";
        }
        data.push(record);
      }
      return data;
    }

    function toMinutesSinceMidnight(timeStr) {
      if (!timeStr) {
        return null;
      }
      const parts = timeStr.split(':');
      if (parts.length < 2) {
        return null;
      }
      const hours = Number(parts[0]);
      const minutes = Number(parts[1]);
      const seconds = parts.length > 2 ? Number(parts[2]) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes) || Number.isNaN(seconds)) {
        return null;
      }
      return hours * 60 + minutes + Math.floor(seconds / 60);
    }

    function minutesToHHMM(totalMinutes) {
      if (totalMinutes === null || totalMinutes === undefined) {
        return "--:--";
      }
      const hours = Math.floor(totalMinutes / 60);
      const minutes = totalMinutes % 60;
      return String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0');
    }

    function hhmmToMinutes(value) {
      if (!value) {
        return 0;
      }
      const [hh, mm] = value.split(':').map(Number);
      if (Number.isNaN(hh) || Number.isNaN(mm)) {
        return 0;
      }
      return hh * 60 + mm;
    }

    function isRealTrainStation(name) {
      if (!name) {
        return false;
      }
      if (name === "Luxembourg, Gare Centrale") {
        return true;
      }
      return name.endsWith(', Gare');
    }

    // 2. chargement et parsing GTFS
    async function loadGTFSData() {
      const [routesText, stopsText, tripsText, stopTimes1Text, stopTimes2Text] = await Promise.all([
        fetch('routes[1].txt').then((res) => res.text()),
        fetch('stops[1].txt').then((res) => res.text()),
        fetch('trips[1].txt').then((res) => res.text()),
        fetch('stop_times[1].txt').then((res) => res.text()),
        fetch('stop_times[2].txt').then((res) => res.text())
      ]);

      const routesRows = parseCSV(routesText);
      const stopsRows = parseCSV(stopsText);
      const tripsRows = parseCSV(tripsText);
      const stopTimesRows = parseCSV(stopTimes1Text).concat(parseCSV(stopTimes2Text));

      return buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows);
    }

    // 3. construction des index (routesById, stopsById, tripsById, tripsStops)
    function buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows) {
      const allowedRouteIds = new Set(['302', '301', '300', '299', '297']);
      const routesById = {};
      for (let i = 0; i < routesRows.length; i++) {
        const route = routesRows[i];
        if (route.agency_id === '11' && allowedRouteIds.has(route.route_id)) {
          routesById[route.route_id] = {
            shortName: route.route_short_name || '',
            longName: route.route_long_name || '',
            type: route.route_type || ''
          };
        }
      }

      const stopsById = {};
      for (let i = 0; i < stopsRows.length; i++) {
        const stop = stopsRows[i];
        if (!isRealTrainStation(stop.stop_name)) {
          continue;
        }
        const stopId = stop.stop_id;
        stopsById[stopId] = {
          name: stop.stop_name,
          lat: stop.stop_lat ? Number(stop.stop_lat) : null,
          lon: stop.stop_lon ? Number(stop.stop_lon) : null
        };
      }

      const tripsById = {};
      for (let i = 0; i < tripsRows.length; i++) {
        const trip = tripsRows[i];
        if (!routesById[trip.route_id]) {
          continue;
        }
        tripsById[trip.trip_id] = {
          route_id: trip.route_id,
          headsign: trip.trip_headsign || '',
          shortName: trip.trip_short_name || '',
          direction: trip.direction_id || ''
        };
      }

      const tripsStopsTemp = {};
      for (let i = 0; i < stopTimesRows.length; i++) {
        const row = stopTimesRows[i];
        const tripId = row.trip_id;
        if (!tripsById[tripId]) {
          continue;
        }
        const stopInfo = stopsById[row.stop_id];
        if (!stopInfo) {
          continue;
        }
        const arrival = toMinutesSinceMidnight(row.arrival_time);
        const departure = toMinutesSinceMidnight(row.departure_time);
        const effectiveArrival = arrival !== null ? arrival : departure;
        const effectiveDeparture = departure !== null ? departure : arrival;
        if (effectiveArrival === null || effectiveDeparture === null) {
          continue;
        }
        if (!tripsStopsTemp[tripId]) {
          tripsStopsTemp[tripId] = [];
        }
        tripsStopsTemp[tripId].push({
          stop_id: row.stop_id,
          stop_name: stopInfo.name,
          lat: stopInfo.lat,
          lon: stopInfo.lon,
          arrival: effectiveArrival,
          departure: effectiveDeparture,
          seq: Number(row.stop_sequence)
        });
      }

      const tripsStops = {};
      const filteredTripsById = {};
      const tripIds = Object.keys(tripsStopsTemp);
      for (let i = 0; i < tripIds.length; i++) {
        const tripId = tripIds[i];
        const stopsArray = tripsStopsTemp[tripId];
        stopsArray.sort((a, b) => a.seq - b.seq);
        if (stopsArray.length >= 2) {
          tripsStops[tripId] = stopsArray;
          filteredTripsById[tripId] = tripsById[tripId];
        }
      }

      return {
        routesById,
        stopsById,
        tripsById: filteredTripsById,
        tripsStops
      };
    }

    // 4. moteur findDirectTrains
    function findDirectTrains(data, fromStopName, toStopName, minDepartureMinutes) {
      const allFromStopIds = new Set();
      const allToStopIds = new Set();
      const stopEntries = Object.entries(data.stopsById);
      for (let i = 0; i < stopEntries.length; i++) {
        const [stopId, stopInfo] = stopEntries[i];
        if (stopInfo.name === fromStopName) {
          allFromStopIds.add(stopId);
        }
        if (stopInfo.name === toStopName) {
          allToStopIds.add(stopId);
        }
      }

      const results = [];
      const tripIds = Object.keys(data.tripsStops);
      for (let i = 0; i < tripIds.length; i++) {
        const tripId = tripIds[i];
        const stopsSeq = data.tripsStops[tripId];
        let depStop = null;
        let arrStop = null;
        let depIndex = -1;
        let arrIndex = -1;
        for (let j = 0; j < stopsSeq.length; j++) {
          const currentStop = stopsSeq[j];
          if (!depStop && allFromStopIds.has(currentStop.stop_id) && currentStop.departure !== null) {
            depStop = currentStop;
            depIndex = j;
          }
          if (depStop && j > depIndex && allToStopIds.has(currentStop.stop_id) && currentStop.arrival !== null) {
            arrStop = currentStop;
            arrIndex = j;
            break;
          }
        }
        if (!depStop || !arrStop) {
          continue;
        }
        if (depStop.departure < minDepartureMinutes) {
          continue;
        }
        const tripInfo = data.tripsById[tripId];
        if (!tripInfo) {
          continue;
        }
        const routeInfo = data.routesById[tripInfo.route_id];
        if (!routeInfo) {
          continue;
        }
        const interSlice = stopsSeq.slice(depIndex, arrIndex + 1);
        const intermediateStops = interSlice.map((stop) => ({
          name: stop.stop_name,
          arr: stop.arrival,
          dep: stop.departure
        }));
        let duration = arrStop.arrival - depStop.departure;
        if (duration < 0) {
          duration += 1440;
        }
        results.push({
          trip_id: tripId,
          train_type: routeInfo.shortName || '',
          train_label: tripInfo.shortName || routeInfo.shortName || '',
          depart_station: depStop.stop_name,
          depart_time_min: depStop.departure,
          arrive_station: arrStop.stop_name,
          arrive_time_min: arrStop.arrival,
          duration_min: duration,
          intermediate_stops: intermediateStops
        });
      }

      results.sort((a, b) => a.depart_time_min - b.depart_time_min);
      return results;
    }

    // 5. rendu UI
    function renderResults(results, container) {
      container.innerHTML = '';
      if (!results.length) {
        const empty = document.createElement('div');
        empty.className = 'card';
        empty.textContent = 'Aucun train direct trouvé après cette heure.';
        container.appendChild(empty);
        return;
      }
      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'trainHeader';
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = result.train_type || 'Train';
        header.appendChild(badge);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = result.train_label || '';
        header.appendChild(labelSpan);
        card.appendChild(header);

        const mainline = document.createElement('div');
        mainline.className = 'mainline';
        mainline.textContent = result.depart_station + ' ' + minutesToHHMM(result.depart_time_min) + ' → ' + result.arrive_station + ' ' + minutesToHHMM(result.arrive_time_min) + ' (' + result.duration_min + ' min)';
        card.appendChild(mainline);

        const details = document.createElement('div');
        details.className = 'details';
        const seenNames = new Set();
        const stopNames = [];
        for (let j = 0; j < result.intermediate_stops.length; j++) {
          const stop = result.intermediate_stops[j];
          if (!seenNames.has(stop.name)) {
            seenNames.add(stop.name);
            stopNames.push(stop.name);
          }
        }
        details.textContent = 'Dessert : ' + stopNames.join(' · ');
        card.appendChild(details);

        container.appendChild(card);
      }
    }

    function populateStationSelects(stopsById, selectElements) {
      const uniqueNames = new Set();
      const names = [];
      const stopValues = Object.values(stopsById);
      for (let i = 0; i < stopValues.length; i++) {
        const stop = stopValues[i];
        if (!uniqueNames.has(stop.name)) {
          uniqueNames.add(stop.name);
          names.push(stop.name);
        }
      }
      names.sort((a, b) => a.localeCompare(b, 'fr'));
      for (let i = 0; i < selectElements.length; i++) {
        const select = selectElements[i];
        while (select.options.length > 1) {
          select.remove(1);
        }
        for (let j = 0; j < names.length; j++) {
          const option = document.createElement('option');
          option.value = names[j];
          option.textContent = names[j];
          select.appendChild(option);
        }
      }
    }

    function setCurrentTimeDefault(input) {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      input.value = hours + ':' + minutes;
    }

    // 6. wiring des events
    document.addEventListener('DOMContentLoaded', () => {
      const fromSelect = document.getElementById('fromStation');
      const toSelect = document.getElementById('toStation');
      const minTimeInput = document.getElementById('minTime');
      const searchBtn = document.getElementById('searchBtn');
      const resultsContainer = document.getElementById('results');
      const errorEl = document.getElementById('formError');

      setCurrentTimeDefault(minTimeInput);

      loadGTFSData()
        .then((data) => {
          window.CFL_DATA = data;
          populateStationSelects(data.stopsById, [fromSelect, toSelect]);
          searchBtn.disabled = false;
          resultsContainer.textContent = '';
        })
        .catch((err) => {
          console.error('Erreur lors du chargement GTFS', err);
          resultsContainer.textContent = "Impossible de charger les données GTFS.";
        });

      searchBtn.addEventListener('click', () => {
        errorEl.textContent = '';
        const fromName = fromSelect.value;
        const toName = toSelect.value;
        if (!fromName || !toName) {
          errorEl.textContent = 'Veuillez sélectionner une gare de départ et d\'arrivée.';
          return;
        }
        if (fromName === toName) {
          errorEl.textContent = 'La gare de départ doit être différente de la gare d\'arrivée.';
          return;
        }
        if (!window.CFL_DATA) {
          errorEl.textContent = 'Les données ne sont pas encore chargées.';
          return;
        }
        const minMinutes = hhmmToMinutes(minTimeInput.value);
        const results = findDirectTrains(window.CFL_DATA, fromName, toName, minMinutes);
        renderResults(results, resultsContainer);
      });
    });
  </script>
</body>
</html>
