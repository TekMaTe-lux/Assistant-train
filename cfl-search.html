<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Recherche trains CFL</title>
  <style>
    body { background:#0b0f1a; color:#e0f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; padding:16px; line-height:1.4; }
    header { margin-bottom:16px; }
    h1 { font-size:24px; margin:0 0 8px; }
    p { margin:0; color:#7a8cae; }
    form { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:16px; display:flex; flex-direction:column; gap:12px; }
    label { font-size:14px; color:#e0f0ff; display:block; margin-bottom:4px; }
    select, input[type=time] { width:100%; background:#0b0f1a; color:#e0f0ff; border:1px solid #2e374f; border-radius:8px; padding:8px; font-size:16px; }
    button { background:#e0f0ff; color:#0b0f1a; border:none; border-radius:8px; font-weight:600; padding:10px 14px; font-size:16px; cursor:pointer; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    #formError { color:#ff6b6b; font-size:14px; min-height:1em; }
    #results { min-height:48px; }
    .card { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:12px; box-shadow:0 8px 24px rgba(0,0,0,0.6); }
    .trainHeader { font-size:16px; font-weight:600; margin-bottom:4px; display:flex; align-items:center; flex-wrap:wrap; gap:6px; }
    .badge { background:#e0f0ff; color:#0b0f1a; border-radius:6px; font-size:14px; font-weight:600; padding:2px 6px; line-height:1.2; }
    .mainline { font-size:15px; font-weight:500; color:#e0f0ff; margin-bottom:4px; }
    .details { font-size:13px; color:#7a8cae; }
    .loading { font-size:15px; color:#7a8cae; }
  </style>
</head>
<body>
  <header>
    <h1>Recherche trains CFL</h1>
    <p>Données GTFS CFL filtrées (IC / RB / RE / TER / TGV)</p>
  </header>
  <form id="searchForm">
    <div>
      <label for="fromStation">Départ :</label>
      <select id="fromStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="toStation">Arrivée :</label>
      <select id="toStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="minTime">Départ après :</label>
      <input id="minTime" type="time" required>
    </div>
    <button id="searchBtn" type="submit" disabled>Rechercher</button>
    <div id="formError"></div>
  </form>
  <div id="results" class="loading">Chargement des données GTFS…</div>
  <script>
    // 1. utils CSV
    function parseCSV(text) {
      const cleaned = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/^\uFEFF/, '');
      const rows = [];
      let currentRow = [];
      let currentField = '';
      let inQuotes = false;
      for (let i = 0; i < cleaned.length; i++) {
        const char = cleaned[i];
        if (inQuotes) {
          if (char === '"') {
            const next = cleaned[i + 1];
            if (next === '"') {
              currentField += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            currentField += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          currentRow.push(currentField);
          currentField = '';
        } else if (char === '\n') {
          currentRow.push(currentField);
          rows.push(currentRow);
          currentRow = [];
          currentField = '';
        } else {
          currentField += char;
        }
      }
      if (inQuotes) {
        currentRow.push(currentField);
      } else if (currentField !== '' || currentRow.length) {
        currentRow.push(currentField);
      }
      if (currentRow.length) {
        rows.push(currentRow);
      }
      if (!rows.length) {
        return [];
      }
      const header = rows.shift().map((col, index) => (index === 0 ? col.replace(/^\uFEFF/, '') : col));
      const data = [];
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (row.length === 1 && row[0] === '') {
          continue;
        }
        const record = {};
        for (let j = 0; j < header.length; j++) {
          record[header[j]] = row[j] !== undefined ? row[j] : '';
        }
        data.push(record);
      }
      return data;
    }

    function toMinutesSinceMidnight(timeStr) {
      if (!timeStr) {
        return null;
      }
      const parts = timeStr.split(':');
      if (parts.length < 2) {
        return null;
      }
      const hours = Number(parts[0]);
      const minutes = Number(parts[1]);
      const seconds = parts.length > 2 ? Number(parts[2]) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes) || Number.isNaN(seconds)) {
        return null;
      }
      return hours * 60 + minutes + Math.floor(seconds / 60);
    }

    function minutesToHHMM(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) {
        return '--:--';
      }
      const normalized = ((totalMinutes % 1440) + 1440) % 1440;
      const hours = Math.floor(normalized / 60);
      const minutes = normalized % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    function hhmmToMinutes(value) {
      if (!value) {
        return 0;
      }
      const [hh, mm] = value.split(':').map((num) => parseInt(num, 10));
      if (Number.isNaN(hh) || Number.isNaN(mm)) {
        return 0;
      }
      return hh * 60 + mm;
    }

    function isRealTrainStation(name) {
      if (!name) {
        return false;
      }
      const trimmed = name.trim();
      if (trimmed === 'Luxembourg, Gare Centrale') {
        return true;
      }
      return trimmed.endsWith(', Gare');
    }

    // 2. chargement et parsing GTFS
    async function loadGTFSData() {
      const pagePath = (window.location && typeof window.location.pathname === 'string')
        ? window.location.pathname.toLowerCase()
        : '';
      const prefixes = pagePath.includes('/cfl/') ? [''] : ['CFL/', ''];

      const fetchText = async (file) => {
        let lastError = null;
        for (let i = 0; i < prefixes.length; i++) {
          const prefix = prefixes[i];
          const url = `${prefix}${file}`;
          try {
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Chargement impossible (${response.status}) pour ${url}`);
            }
            return await response.text();
          } catch (error) {
            lastError = error;
          }
        }
        if (lastError) {
          throw lastError;
        }
        throw new Error(`Chargement impossible pour ${file}`);
      };

      const [routesText, stopsText, tripsText, stopTimes1Text, stopTimes2Text] = await Promise.all([
        fetchText('routes[1].txt'),
        fetchText('stops[1].txt'),
        fetchText('trips[1].txt'),
        fetchText('stop_times[1].txt'),
        fetchText('stop_times[2].txt')
      ]);

      const routesRows = parseCSV(routesText);
      const stopsRows = parseCSV(stopsText);
      const tripsRows = parseCSV(tripsText);
      const stopTimesRows = parseCSV(stopTimes1Text).concat(parseCSV(stopTimes2Text));

      return buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows);
    }

    // 3. construction des index (routesById, stopsById, tripsById, tripsStops)
    function buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows) {
      const allowedRouteIds = new Set(['302', '301', '300', '299', '297']);
      const routesById = {};
      for (let i = 0; i < routesRows.length; i++) {
        const route = routesRows[i];
        if (route.agency_id === '11' && allowedRouteIds.has(route.route_id)) {
          routesById[route.route_id] = {
            shortName: route.route_short_name || '',
            longName: route.route_long_name || '',
            type: route.route_type || ''
          };
        }
      }

      const stopsById = {};
      for (let i = 0; i < stopsRows.length; i++) {
        const stop = stopsRows[i];
        const stopName = stop.stop_name ? stop.stop_name.trim() : '';
        if (!isRealTrainStation(stopName)) {
          continue;
        }
        const stopId = stop.stop_id;
        stopsById[stopId] = {
          name: stopName,
          lat: stop.stop_lat && !Number.isNaN(Number(stop.stop_lat)) ? Number(stop.stop_lat) : null,
          lon: stop.stop_lon && !Number.isNaN(Number(stop.stop_lon)) ? Number(stop.stop_lon) : null
        };
      }

      const tripsById = {};
      for (let i = 0; i < tripsRows.length; i++) {
        const trip = tripsRows[i];
        if (!routesById[trip.route_id]) {
          continue;
        }
        tripsById[trip.trip_id] = {
          route_id: trip.route_id,
          headsign: trip.trip_headsign || '',
          shortName: trip.trip_short_name || '',
          direction: trip.direction_id || ''
        };
      }

      const tripsStopsTemp = {};
      for (let i = 0; i < stopTimesRows.length; i++) {
        const row = stopTimesRows[i];
        const tripId = row.trip_id;
        if (!tripsById[tripId]) {
          continue;
        }
        const stopInfo = stopsById[row.stop_id];
        if (!stopInfo) {
          continue;
        }
        const sequence = Number(row.stop_sequence);
        if (!Number.isFinite(sequence)) {
          continue;
        }
        const arrival = toMinutesSinceMidnight(row.arrival_time);
        const departure = toMinutesSinceMidnight(row.departure_time);
        const effectiveArrival = arrival !== null ? arrival : departure;
        const effectiveDeparture = departure !== null ? departure : arrival;
        if (!Number.isFinite(effectiveArrival) || !Number.isFinite(effectiveDeparture)) {
          continue;
        }
        if (!tripsStopsTemp[tripId]) {
          tripsStopsTemp[tripId] = [];
        }
        tripsStopsTemp[tripId].push({
          stop_id: row.stop_id,
          stop_name: stopInfo.name,
          lat: stopInfo.lat,
          lon: stopInfo.lon,
          arrival: effectiveArrival,
          departure: effectiveDeparture,
          seq: sequence
        });
      }

      const tripsStops = {};
      const filteredTripsById = {};
      const tripIds = Object.keys(tripsStopsTemp);
      for (let i = 0; i < tripIds.length; i++) {
        const tripId = tripIds[i];
        const stopsArray = tripsStopsTemp[tripId];
        stopsArray.sort((a, b) => a.seq - b.seq);
        if (stopsArray.length >= 2) {
          tripsStops[tripId] = stopsArray;
          filteredTripsById[tripId] = tripsById[tripId];
        }
      }

      return {
        routesById,
        stopsById,
        tripsById: filteredTripsById,
        tripsStops
      };
    }

    // 4. moteur findDirectTrains
    function findDirectTrains(data, fromStopName, toStopName, minDepartureMinutes) {
      if (!data || !fromStopName || !toStopName) {
        return [];
      }

      const allFromStopIds = new Set();
      const allToStopIds = new Set();
      const stopEntries = Object.entries(data.stopsById || {});
      for (let i = 0; i < stopEntries.length; i++) {
        const [stopId, stopInfo] = stopEntries[i];
        if (stopInfo.name === fromStopName) {
          allFromStopIds.add(stopId);
        }
        if (stopInfo.name === toStopName) {
          allToStopIds.add(stopId);
        }
      }

      if (!allFromStopIds.size || !allToStopIds.size) {
        return [];
      }

      const results = [];
      const tripEntries = Object.entries(data.tripsStops || {});
      for (let i = 0; i < tripEntries.length; i++) {
        const [tripId, stopsSeq] = tripEntries[i];
        if (!Array.isArray(stopsSeq) || stopsSeq.length < 2) {
          continue;
        }

        const tripInfo = data.tripsById?.[tripId];
        if (!tripInfo) {
          continue;
        }
        const routeInfo = data.routesById?.[tripInfo.route_id];
        if (!routeInfo) {
          continue;
        }

        let depStop = null;
        let arrStop = null;
        let depIndex = -1;
        let arrIndex = -1;

        for (let j = 0; j < stopsSeq.length; j++) {
          const currentStop = stopsSeq[j];
          if (!depStop && allFromStopIds.has(currentStop.stop_id)) {
            depStop = currentStop;
            depIndex = j;
          }
          if (depStop && allToStopIds.has(currentStop.stop_id)) {
            arrStop = currentStop;
            arrIndex = j;
            break;
          }
        }

        if (!depStop || !arrStop) {
          continue;
        }
        if (depIndex >= arrIndex) {
          continue;
        }

        const depTime = depStop.departure;
        if (!Number.isFinite(depTime) || depTime < minDepartureMinutes) {
          continue;
        }

        const arrTime = Number.isFinite(arrStop.arrival) ? arrStop.arrival : arrStop.departure;
        if (!Number.isFinite(arrTime)) {
          continue;
        }

        let duration = arrTime - depTime;
        if (duration < 0) {
          duration += 1440;
        }

        const slice = stopsSeq.slice(depIndex, arrIndex + 1);
        const intermediateStops = slice.map((stop) => ({
          name: stop.stop_name,
          arr: stop.arrival,
          dep: stop.departure
        }));

        results.push({
          trip_id: tripId,
          train_type: routeInfo.shortName || '',
          train_label: tripInfo.shortName || routeInfo.shortName || '',
          depart_station: depStop.stop_name,
          depart_time_min: depTime,
          arrive_station: arrStop.stop_name,
          arrive_time_min: arrTime,
          duration_min: duration,
          intermediate_stops: intermediateStops
        });
      }

      results.sort((a, b) => a.depart_time_min - b.depart_time_min);
      return results;
    }

    // 5. rendu UI
    function renderResults(container, results) {
      container.innerHTML = '';
      if (!Array.isArray(results) || results.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card';
        empty.textContent = 'Aucun train direct trouvé après cette heure.';
        container.appendChild(empty);
        return;
      }

      for (let i = 0; i < results.length; i++) {
        const result = results[i];
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'trainHeader';
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = result.train_type || 'Train';
        header.appendChild(badge);
        if (result.train_label) {
          const labelSpan = document.createElement('span');
          labelSpan.textContent = result.train_label;
          header.appendChild(labelSpan);
        }
        card.appendChild(header);

        const mainline = document.createElement('div');
        mainline.className = 'mainline';
        mainline.textContent = `${result.depart_station} ${minutesToHHMM(result.depart_time_min)} → ${result.arrive_station} ${minutesToHHMM(result.arrive_time_min)} (${result.duration_min} min)`;
        card.appendChild(mainline);

        if (Array.isArray(result.intermediate_stops) && result.intermediate_stops.length) {
          const details = document.createElement('div');
          details.className = 'details';
          const seenNames = new Set();
          const names = [];
          for (let j = 0; j < result.intermediate_stops.length; j++) {
            const stop = result.intermediate_stops[j];
            if (!seenNames.has(stop.name)) {
              seenNames.add(stop.name);
              names.push(stop.name);
            }
          }
          details.textContent = `Dessert : ${names.join(' · ')}`;
          card.appendChild(details);
        }

        container.appendChild(card);
      }
    }

    function populateStationSelects(stopsById, selectElements) {
      const unique = new Set();
      const names = [];
      const values = Object.values(stopsById || {});
      for (let i = 0; i < values.length; i++) {
        const stop = values[i];
        if (stop && stop.name && !unique.has(stop.name)) {
          unique.add(stop.name);
          names.push(stop.name);
        }
      }
      names.sort((a, b) => a.localeCompare(b, 'fr'));

      for (let i = 0; i < selectElements.length; i++) {
        const select = selectElements[i];
        const placeholder = select.options.length ? select.options[0] : null;
        select.innerHTML = '';
        if (placeholder) {
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = '';
          select.appendChild(placeholder);
        } else {
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.disabled = true;
          defaultOption.selected = true;
          defaultOption.textContent = 'Choisir une gare';
          select.appendChild(defaultOption);
        }
        for (let j = 0; j < names.length; j++) {
          const option = document.createElement('option');
          option.value = names[j];
          option.textContent = names[j];
          select.appendChild(option);
        }
      }
    }

    function setCurrentTimeDefault(input) {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      input.value = hours + ':' + minutes;
    }

    // 6. wiring des events
    document.addEventListener('DOMContentLoaded', () => {
      const fromSelect = document.getElementById('fromStation');
      const toSelect = document.getElementById('toStation');
      const minTimeInput = document.getElementById('minTime');
      const searchBtn = document.getElementById('searchBtn');
      const form = document.getElementById('searchForm');
      const resultsContainer = document.getElementById('results');
      const errorEl = document.getElementById('formError');

      setCurrentTimeDefault(minTimeInput);

      loadGTFSData()
        .then((data) => {
          window.CFL_DATA = data;
          populateStationSelects(data.stopsById, [fromSelect, toSelect]);
          searchBtn.disabled = false;
          resultsContainer.classList.remove('loading');
          resultsContainer.textContent = '';
        })
        .catch((err) => {
          console.error('Erreur lors du chargement GTFS', err);
          resultsContainer.classList.remove('loading');
          resultsContainer.textContent = "Impossible de charger les données GTFS.";
        });

      form.addEventListener('submit', (event) => {
        event.preventDefault();
        errorEl.textContent = '';
        const fromName = fromSelect.value;
        const toName = toSelect.value;
        if (!fromName || !toName) {
          errorEl.textContent = 'Veuillez sélectionner une gare de départ et d\'arrivée.';
          return;
        }
        if (fromName === toName) {
          errorEl.textContent = 'La gare de départ doit être différente de la gare d\'arrivée.';
          return;
        }
        if (!window.CFL_DATA) {
          errorEl.textContent = 'Les données ne sont pas encore chargées.';
          return;
        }
        const minMinutes = hhmmToMinutes(minTimeInput.value);
        const results = findDirectTrains(window.CFL_DATA, fromName, toName, minMinutes);
        renderResults(resultsContainer, results);
      });
    });
  </script>
</body>
</html>
