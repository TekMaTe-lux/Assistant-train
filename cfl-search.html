<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Recherche trains CFL</title>
<style>
  :root {
    color-scheme: dark;
    --bg-page:#0b0f1a;
    --bg-card:#1a2238;
    --txt-main:#e0f0ff;
    --txt-dim:#7a8cae;
    --border:#2e374f;
    --accent:#e0f0ff;
    --accent-text:#0b0f1a;
  }
  body{
    background:var(--bg-page);
    color:var(--txt-main);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    margin:0;
    padding:16px;
    line-height:1.4;
  }
  header{
    margin-bottom:16px;
  }
  header h1{
    font-size:1.1rem;
    font-weight:600;
    margin:0 0 4px 0;
    color:var(--txt-main);
  }
  header p{
    margin:0;
    color:var(--txt-dim);
    font-size:0.9rem;
    line-height:1.3;
  }

  form#searchForm{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:16px;
    display:flex;
    flex-direction:column;
    gap:12px;
    box-shadow:0 12px 24px rgb(0 0 0 / 0.6);
  }
  .field{
    display:flex;
    flex-direction:column;
  }
  label{
    font-size:14px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  select,
  input[type=time],
  input[type=date]{
    width:100%;
    background:var(--bg-page);
    color:var(--txt-main);
    border:1px solid var(--border);
    border-radius:8px;
    padding:8px;
    font-size:16px;
  }
  button#searchBtn{
    background:var(--accent);
    color:var(--accent-text);
    border:none;
    border-radius:8px;
    font-weight:600;
    padding:10px 14px;
    font-size:16px;
    cursor:pointer;
  }
  #formError{
    color:#ff6b6b;
    font-size:14px;
    min-height:1em;
  }

  #results .card{
    background:var(--bg-card);
    border-radius:12px;
    padding:12px;
    margin-bottom:12px;
    box-shadow:0 8px 24px rgba(0,0,0,0.6);
  }
  .trainHeader{
    font-size:16px;
    font-weight:600;
    margin-bottom:4px;
    display:flex;
    align-items:center;
    flex-wrap:wrap;
    gap:6px;
    color:var(--txt-main);
  }
  .badge{
    background:var(--accent);
    color:var(--accent-text);
    border-radius:6px;
    font-size:14px;
    font-weight:600;
    padding:2px 6px;
    line-height:1.2;
  }
  .mainline{
    font-size:15px;
    font-weight:500;
    color:var(--txt-main);
    margin-bottom:4px;
  }
  .details{
    font-size:13px;
    color:var(--txt-dim);
  }

  footer{
    margin-top:24px;
    color:var(--txt-dim);
    font-size:12px;
    text-align:center;
    line-height:1.4;
  }
  footer a{
    color:var(--txt-main);
  }

  @media(min-width:480px){
    body{ max-width:480px; margin:0 auto; }
  }
</style>
</head>
<body>
<header>
  <h1>Recherche trains CFL</h1>
  <p>Horaires statiques GTFS CFL (IC / RB / RE / TER / TGV). Résultats par date réelle + heure choisie.</p>
</header>

<form id="searchForm" onsubmit="return false;">
  <div class="field">
    <label for="fromStation">Départ</label>
    <select id="fromStation" required></select>
  </div>

  <div class="field">
    <label for="toStation">Arrivée</label>
    <select id="toStation" required></select>
  </div>

  <div class="field">
    <label for="dateDay">Date du trajet</label>
    <input id="dateDay" type="date" required>
  </div>

  <div class="field">
    <label for="minTime">Départ après</label>
    <input id="minTime" type="time" required>
  </div>

  <button id="searchBtn" type="button">Rechercher</button>
  <div id="formError"></div>
</form>

<section id="results"></section>

<footer>
  <div>Prototype horaire CFL – pas de retards temps réel.</div>
  <div>Source : GTFS CFL (statique).</div>
</footer>

<script>
// ============ CONFIG ============

const DATA_PATH = "CFL/";

// Trains CFL qu'on veut garder (agency_id = 11)
const ROUTE_IDS_ALLOWED = new Set(["302","301","300","299","297"]);

// Mémoire globale
const DATA = {
  routesById:{},         // { route_id: {route_id, shortName, agency_id} }
  stopsById:{},          // { stop_id: { name, lat, lon } }
  tripsById:{},          // { trip_id: { route_id, service_id, headsign, shortName } }
  tripsStops:{},         // { trip_id: [ {stop_id,stop_name,arr,dep,seq}, ...] }
  calendar:{},           // { service_id: { startDate,endDate,days:{1..7},exceptions:{} } }
};

// ============ UTILS PARSE CSV ============

function splitCsvLine(line) {
  const out = [];
  let cur = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (inQuotes) {
      if (ch === '"') {
        if (line[i+1] === '"') {
          cur += '"'; i++;
        } else {
          inQuotes = false;
        }
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"') {
        inQuotes = true;
      } else if (ch === ',') {
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
  }
  out.push(cur);
  return out;
}

function parseCSV(rawText){
  const lines = rawText.trim().split(/\r?\n/);
  if (!lines.length) return [];
  const header = splitCsvLine(lines[0]);
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = splitCsvLine(lines[i]);
    if (cols.length===1 && cols[0]==="") continue;
    const obj={};
    for (let c=0;c<header.length;c++){
      obj[header[c]] = cols[c]!==undefined ? cols[c] : "";
    }
    rows.push(obj);
  }
  return rows;
}

// ============ TEMPS / DATES ============

function toMinutesSinceMidnight(hms){
  if(!hms || !hms.includes(":")) return null;
  const parts=hms.split(":");
  const H=parseInt(parts[0],10);
  const M=parseInt(parts[1],10);
  return H*60+M;
}

function hhmmToMinutes(hhmm){
  if(!hhmm||!hhmm.includes(":"))return 0;
  const [h,m]=hhmm.split(":");
  return parseInt(h,10)*60+parseInt(m,10);
}

function minutesToHHMM(mins){
  if(mins==null||isNaN(mins))return"--:--";
  let m=mins;
  while(m<0) m+=1440;
  while(m>=1440) m-=1440;
  const H=Math.floor(m/60);
  const M=m%60;
  return (H<10?"0"+H:H)+":"+(M<10?"0"+M:M);
}

// weekdayIdx: 0=lundi,...,6=dimanche
function dateInputToYMDinfo(dateStr){
  const [Y,M,D]=dateStr.split("-");
  const yyyymmdd=Y+M+D;
  const jsDate=new Date(+Y,+M-1,+D);
  const map={1:0,2:1,3:2,4:3,5:4,6:5,0:6}; // JS 0=dimanche
  const weekdayIdx=map[jsDate.getDay()];
  return { yyyymmdd, weekdayIdx };
}

// ============ GARES ============

// On garde tout arrêt contenant le mot "Gare", même "Gare routière"
// (sinon on perd certains trajets completement)
function isRealStation(name){
  if (!name) return false;

  const lower = name.toLowerCase();

  // exclusions explicites (bus / tram / rue)
  if (lower.includes("routière")) return false;
  if (lower.includes("routiere")) return false;
  if (lower.includes("op der gare")) return false;
  if (lower.includes("rue de la gare")) return false;
  if (lower.includes("bus")) return false;

  // cas spécial gare centrale
  if (name === "Luxembourg, Gare Centrale") return true;

  // format CFL classique "<Ville>, Gare"
  if (/, Gare\b/.test(name)) {
    return true;
  }

  return false;
}

// ============ CALENDAR LOGIC ============
// Le format final qu'on va remplir :
// DATA.calendar[service_id] = {
//   startDate:"20251022",
//   endDate:"20251215",
//   days:{ "1":true, "2":true, ... "7":false }, // 1=lundi,...,7=dimanche
//   exceptions:{ "20251103":1, "20251215":2 }   // 1=ajout,2=suppression
// }

function serviceRunsOnDate(service_id, yyyymmdd, weekdayIdx){
  const svc = DATA.calendar[service_id];
  if(!svc) return false;

  // exceptions d'abord
  if (svc.exceptions && svc.exceptions[yyyymmdd] !== undefined) {
    return svc.exceptions[yyyymmdd] === 1;
  }

  // sinon horaires normaux
  if(svc.startDate && yyyymmdd < svc.startDate) return false;
  if(svc.endDate   && yyyymmdd > svc.endDate)   return false;

  // weekdayIdx 0=lundi,...,6=dimanche => jour GTFS = weekdayIdx+1
  const dayField = String(weekdayIdx+1);
  return !!svc.days[dayField];
}

// ============ BUILDERS (on remplit DATA.*) ============

function buildRoutes(rows){
  for(const r of rows){
    const route_id  = (r.route_id||"").trim();
    const agency_id = (r.agency_id||"").trim();
    if(!ROUTE_IDS_ALLOWED.has(route_id)) continue;
    if(agency_id !== "11") continue; // CFL pur

    DATA.routesById[route_id] = {
      route_id,
      agency_id,
      shortName: (r.route_short_name||"").trim(),
      longName:  (r.route_long_name ||"").trim(),
      type:      (r.route_type      ||"").trim()
    };
  }
}

function buildStops(rows){
  for(const s of rows){
    const stop_id   = (s.stop_id||"").trim();
    const stop_name = (s.stop_name||"").trim();
    if(!stop_id || !stop_name) continue;
    if(!isRealStation(stop_name)) continue;

    DATA.stopsById[stop_id] = {
      name: stop_name,
      lat:  Number(s.stop_lat||"0"),
      lon:  Number(s.stop_lon||"0")
    };
  }
}

function buildTrips(rows){
  for(const t of rows){
    const trip_id    = (t.trip_id||"").trim();
    const route_id   = (t.route_id||"").trim();
    const service_id = (t.service_id||"").trim();
    if(!trip_id || !route_id || !service_id) continue;

    // garder uniquement les trips qui appartiennent à une route CFL retenue
    if(!DATA.routesById[route_id]) continue;

    DATA.tripsById[trip_id] = {
      route_id,
      service_id,
      headsign:  (t.trip_headsign  ||"").trim(),
      shortName: (t.trip_short_name||"").trim(),
      direction: (t.direction_id   ||"").trim()
    };
  }
}

function buildCalendar(calRows, calDatesRows){
  // base
  for(const c of calRows){
    const service_id=(c.service_id||"").trim();
    if(!service_id) continue;
    DATA.calendar[service_id] = {
      startDate:(c.start_date||"").trim(),
      endDate:(c.end_date||"").trim(),
      days:{
        "1": c.monday==="1",
        "2": c.tuesday==="1",
        "3": c.wednesday==="1",
        "4": c.thursday==="1",
        "5": c.friday==="1",
        "6": c.saturday==="1",
        "7": c.sunday==="1"
      },
      exceptions:{}
    };
  }

  // exceptions
  for(const ce of calDatesRows){
    const service_id=(ce.service_id||"").trim();
    const date=(ce.date||"").trim();
    const exc=(ce.exception_type||"").trim();
    if(!service_id||!date||!exc) continue;

    if(!DATA.calendar[service_id]){
      DATA.calendar[service_id] = {
        startDate:"",
        endDate:"",
        days:{},
        exceptions:{}
      };
    }
    DATA.calendar[service_id].exceptions[date] = parseInt(exc,10); // 1=ajout,2=suppr
  }
}

function buildTripsStops(stopTimesRows){
  // 1. pousser dans DATA.tripsStops uniquement si trip + stop valides
  for(const st of stopTimesRows){
    const trip_id = (st.trip_id||"").trim();
    const stop_id = (st.stop_id||"").trim();
    if(!trip_id || !stop_id) continue;

    if(!DATA.tripsById[trip_id]) continue;   // ignorer trips hors CFL
    if(!DATA.stopsById[stop_id]) continue;   // ignorer arrêts qu'on ne garde pas

    if(!DATA.tripsStops[trip_id]) DATA.tripsStops[trip_id] = [];

    DATA.tripsStops[trip_id].push({
      stop_id,
      stop_name: DATA.stopsById[stop_id].name,
      arr: toMinutesSinceMidnight(st.arrival_time),
      dep: toMinutesSinceMidnight(st.departure_time),
      seq: Number(st.stop_sequence||"0")
    });
  }

  // 2. trier et filtrer les trips trop courts
  for(const tripId of Object.keys(DATA.tripsStops)){
    const arrs = DATA.tripsStops[tripId];
    arrs.sort((a,b)=>a.seq-b.seq);
    if(arrs.length < 2){
      delete DATA.tripsStops[tripId];
      delete DATA.tripsById[tripId];
    }
  }
}

// ============ RECHERCHE DES TRAINS DIRECTS ============
//
// Critère :
// - Service actif ce jour-là (calendar + calendar_dates)
// - Train passe par fromStation puis par toStation après
// - Heure départ >= heure min choisie
//

function findDirectTrains(fromName,toName,minDepartureMinutes,yyyymmdd,weekdayIdx){
  // stop_ids possibles pour from et to
  const fromIds = new Set();
  const toIds   = new Set();
  for(const sid in DATA.stopsById){
    const stName = DATA.stopsById[sid].name;
    if(stName === fromName) fromIds.add(sid);
    if(stName === toName)   toIds.add(sid);
  }

  const results = [];

  for(const tripId in DATA.tripsStops){
    const stopSeq = DATA.tripsStops[tripId];
    const tripMeta = DATA.tripsById[tripId];
    if(!tripMeta) continue;

    // est-ce que ce service roule ce jour ?
    if(!serviceRunsOnDate(tripMeta.service_id, yyyymmdd, weekdayIdx)){
      continue;
    }

    let depStop=null;
    let arrStop=null;

    for(let i=0;i<stopSeq.length;i++){
      const s=stopSeq[i];
      if(!depStop && fromIds.has(s.stop_id)){
        depStop = s;
      }
      if(depStop && toIds.has(s.stop_id) && s.seq>depStop.seq){
        arrStop = s;
        break;
      }
    }

    if(!depStop || !arrStop) continue;
    if(depStop.dep==null || depStop.dep < minDepartureMinutes) continue;

    // sous-parcours entre les deux
    const between = stopSeq.filter(s => s.seq>=depStop.seq && s.seq<=arrStop.seq);

    const routeMeta = DATA.routesById[tripMeta.route_id] || {};
    const trainType = routeMeta.shortName || ""; // RB / RE / TER / IC / TGV
    const label = tripMeta.shortName || tripMeta.headsign || "";

    results.push({
      trip_id: tripId,
      train_type: trainType,
      train_label: label,
      depart_station: depStop.stop_name,
      depart_time_min: depStop.dep,
      arrive_station: arrStop.stop_name,
      arrive_time_min: arrStop.arr,
      duration_min: (arrStop.arr??0) - (depStop.dep??0),
      stops: between.map(s=>s.stop_name)
    });
  }

  results.sort((a,b)=>a.depart_time_min - b.depart_time_min);
  return results;
}

// ============ UI / RENDU ============

function populateStationsSelect(){
  const setNames=new Set();
  for(const sid in DATA.stopsById){
    setNames.add(DATA.stopsById[sid].name);
  }
  const names=[...setNames].sort((a,b)=>a.localeCompare(b,"fr"));
  const fromSel=document.getElementById("fromStation");
  const toSel=document.getElementById("toStation");
  fromSel.innerHTML="";
  toSel.innerHTML="";
  for(const n of names){
    const o1=document.createElement("option");
    o1.value=n;o1.textContent=n;
    fromSel.appendChild(o1);
    const o2=document.createElement("option");
    o2.value=n;o2.textContent=n;
    toSel.appendChild(o2);
  }
}

function prefillDateTime(){
  const now=new Date();
  const yyyy=now.getFullYear();
  const mm=String(now.getMonth()+1).padStart(2,"0");
  const dd=String(now.getDate()).padStart(2,"0");
  const HH=String(now.getHours()).padStart(2,"0");
  const MM=String(now.getMinutes()).padStart(2,"0");
  const dateInput=document.getElementById("dateDay");
  const timeInput=document.getElementById("minTime");
  if(!dateInput.value)dateInput.value=`${yyyy}-${mm}-${dd}`;
  if(!timeInput.value)timeInput.value=`${HH}:${MM}`;
}

function renderResults(results){
  const container=document.getElementById("results");
  container.innerHTML="";

  if(!results.length){
    const div=document.createElement("div");
    div.className="card";
    div.style.color="var(--txt-dim)";
    div.textContent="Aucun train direct trouvé après cette heure.";
    container.appendChild(div);
    return;
  }

  for(const r of results){
    const card=document.createElement("div");
    card.className="card";

    const head=document.createElement("div");
    head.className="trainHeader";

    const badge=document.createElement("span");
    badge.className="badge";
    badge.textContent=r.train_type || "?";
    head.appendChild(badge);

    const lbl=document.createElement("span");
    lbl.textContent=r.train_label || "";
    head.appendChild(lbl);

    const mainline=document.createElement("div");
    mainline.className="mainline";
    const depHHMM=minutesToHHMM(r.depart_time_min);
    const arrHHMM=minutesToHHMM(r.arrive_time_min);
    const dur=(r.duration_min!=null && r.duration_min>=0)? r.duration_min+" min":"";
    mainline.textContent =
      `${r.depart_station} ${depHHMM} → ${r.arrive_station} ${arrHHMM}`+
      (dur?` (${dur})`:"");

    const details=document.createElement("div");
    details.className="details";
    details.textContent="Dessert : "+r.stops.join(" · ");

    card.appendChild(head);
    card.appendChild(mainline);
    card.appendChild(details);
    container.appendChild(card);
  }
}

function setupSearchHandler(){
  const btn=document.getElementById("searchBtn");
  const errBox=document.getElementById("formError");

  btn.addEventListener("click",()=>{
    errBox.textContent="";

    const fromStation=document.getElementById("fromStation").value;
    const toStation=document.getElementById("toStation").value;
    const dateStr=document.getElementById("dateDay").value;
    const minTimeStr=document.getElementById("minTime").value;

    if(!fromStation||!toStation){
      errBox.textContent="Choisis une gare de départ et une gare d'arrivée.";
      return;
    }
    if(fromStation===toStation){
      errBox.textContent="Départ et arrivée identiques.";
      return;
    }
    if(!dateStr){
      errBox.textContent="Choisis une date.";
      return;
    }
    if(!minTimeStr){
      errBox.textContent="Choisis une heure minimale.";
      return;
    }

    const { yyyymmdd, weekdayIdx } = dateInputToYMDinfo(dateStr);
    const minDepartureMinutes = hhmmToMinutes(minTimeStr);

    const found = findDirectTrains(
      fromStation,
      toStation,
      minDepartureMinutes,
      yyyymmdd,
      weekdayIdx
    );

    renderResults(found);
  });
}

// ============ CHARGEMENT INITIAL ============

async function loadAll(){
  const [
    routesText,
    stopsText,
    tripsText,
    stopTimesText,
    calText,
    calDatesText
  ] = await Promise.all([
    fetch(DATA_PATH+"routescfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"stopscfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"tripscfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"stop_timescfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"calendarcfl.txt").then(r=>r.text()),
    fetch(DATA_PATH+"calendar_datescfl.txt").then(r=>r.text())
  ]);

  const routesRows    = parseCSV(routesText);
  const stopsRows     = parseCSV(stopsText);
  const tripsRows     = parseCSV(tripsText);
  const stopTimesRows = parseCSV(stopTimesText);
  const calRows       = parseCSV(calText);
  const calDatesRows  = parseCSV(calDatesText);

  buildRoutes(routesRows);
  buildStops(stopsRows);
  buildTrips(tripsRows);
  buildCalendar(calRows, calDatesRows);
  buildTripsStops(stopTimesRows);

  console.log("DEBUG:", {
    routesKept:Object.keys(DATA.routesById).length,
    stopsKept:Object.keys(DATA.stopsById).length,
    tripsKept:Object.keys(DATA.tripsById).length,
    tripsWithStops:Object.keys(DATA.tripsStops).length
  });
}

document.addEventListener("DOMContentLoaded", async ()=>{
  await loadAll();
  populateStationsSelect();
  prefillDateTime();
  setupSearchHandler();
});
</script>
</body>
</html>
