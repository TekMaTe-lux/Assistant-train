<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Recherche trains CFL</title>
  <style>
    body { background:#0b0f1a; color:#e0f0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; padding:16px; line-height:1.4; }
    header { margin-bottom:16px; }
    h1 { font-size:24px; margin:0 0 8px; }
    p { margin:0; color:#7a8cae; }
    form { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:16px; display:flex; flex-direction:column; gap:12px; }
    label { font-size:14px; color:#e0f0ff; display:block; margin-bottom:4px; }
    select, input[type=time] { width:100%; background:#0b0f1a; color:#e0f0ff; border:1px solid #2e374f; border-radius:8px; padding:8px; font-size:16px; }
    button { background:#e0f0ff; color:#0b0f1a; border:none; border-radius:8px; font-weight:600; padding:10px 14px; font-size:16px; cursor:pointer; }
    button:disabled { opacity:0.6; cursor:not-allowed; }
    #formError { color:#ff6b6b; font-size:14px; min-height:1em; }
    #results { min-height:48px; }
    .card { background:#1a2238; border-radius:12px; padding:12px; margin-bottom:12px; box-shadow:0 8px 24px rgba(0,0,0,0.6); }
    .trainHeader { font-size:16px; font-weight:600; margin-bottom:4px; display:flex; align-items:center; flex-wrap:wrap; gap:6px; }
    .badge { background:#e0f0ff; color:#0b0f1a; border-radius:6px; font-size:14px; font-weight:600; padding:2px 6px; line-height:1.2; }
    .mainline { font-size:15px; font-weight:500; color:#e0f0ff; margin-bottom:4px; }
    .details { font-size:13px; color:#7a8cae; }
    .loading { font-size:15px; color:#7a8cae; }
    .resultsIntro { font-size:14px; color:#7a8cae; margin-bottom:8px; }
    .card.expanded { box-shadow:0 12px 32px rgba(0,0,0,0.75); }
    .card .detailPanel { margin-top:8px; border-top:1px solid #2e374f; padding-top:8px; }
    .card .detailPanel[hidden] { display:none; }
    .toggleDetails { margin-top:8px; background:transparent; color:#e0f0ff; border:1px solid #2e374f; border-radius:6px; padding:6px 10px; font-size:14px; font-weight:600; cursor:pointer; transition:background 0.2s ease, color 0.2s ease; }
    .toggleDetails:hover, .toggleDetails:focus { background:#e0f0ff; color:#0b0f1a; outline:none; }
    .detailTitle { font-size:13px; color:#9aaad3; text-transform:uppercase; letter-spacing:0.05em; margin-bottom:6px; }
    .stopsList { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:6px; }
    .stopsList li { display:flex; justify-content:space-between; align-items:flex-start; gap:12px; font-size:13px; color:#c3d2f1; }
    .stopName { font-weight:500; flex:1; }
    .stopTimes { min-width:140px; text-align:right; color:#9aaad3; }
  </style>
</head>
<body>
  <header>
    <h1>Recherche trains CFL</h1>
    <p>Données GTFS CFL filtrées (IC / RB / RE / TER / TGV)</p>
  </header>
  <form id="searchForm">
    <div>
      <label for="fromStation">Départ :</label>
      <select id="fromStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="toStation">Arrivée :</label>
      <select id="toStation" required>
        <option value="" disabled selected>Choisir une gare</option>
      </select>
    </div>
    <div>
      <label for="travelDate">Date du voyage :</label>
      <input id="travelDate" type="date" required>
    </div>
    <div>
      <label for="minTime">Départ après :</label>
      <input id="minTime" type="time" required>
    </div>
    <button id="searchBtn" type="submit" disabled>Rechercher</button>
    <div id="formError"></div>
  </form>
  <div id="results" class="loading">Chargement des données GTFS…</div>
  <script>
    // 1. utils CSV
    function parseCSV(text) {
      const cleaned = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/^\uFEFF/, '');
      const rows = [];
      let currentRow = [];
      let currentField = '';
      let inQuotes = false;
      for (let i = 0; i < cleaned.length; i++) {
        const char = cleaned[i];
        if (inQuotes) {
          if (char === '"') {
            const next = cleaned[i + 1];
            if (next === '"') {
              currentField += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            currentField += char;
          }
        } else if (char === '"') {
          inQuotes = true;
        } else if (char === ',') {
          currentRow.push(currentField);
          currentField = '';
        } else if (char === '\n') {
          currentRow.push(currentField);
          rows.push(currentRow);
          currentRow = [];
          currentField = '';
        } else {
          currentField += char;
        }
      }
      if (inQuotes) {
        currentRow.push(currentField);
      } else if (currentField !== '' || currentRow.length) {
        currentRow.push(currentField);
      }
      if (currentRow.length) {
        rows.push(currentRow);
      }
      if (!rows.length) {
        return [];
      }
      const header = rows.shift().map((col, index) => (index === 0 ? col.replace(/^\uFEFF/, '') : col));
      const data = [];
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        if (row.length === 1 && row[0] === '') {
          continue;
        }
        const record = {};
        for (let j = 0; j < header.length; j++) {
          record[header[j]] = row[j] !== undefined ? row[j] : '';
        }
        data.push(record);
      }
      return data;
    }

    function toMinutesSinceMidnight(timeStr) {
      if (!timeStr) {
        return null;
      }
      const parts = timeStr.split(':');
      if (parts.length < 2) {
        return null;
      }
      const hours = Number(parts[0]);
      const minutes = Number(parts[1]);
      const seconds = parts.length > 2 ? Number(parts[2]) : 0;
      if (Number.isNaN(hours) || Number.isNaN(minutes) || Number.isNaN(seconds)) {
        return null;
      }
      return hours * 60 + minutes + Math.floor(seconds / 60);
    }

    function minutesToHHMM(totalMinutes) {
      if (!Number.isFinite(totalMinutes)) {
        return '--:--';
      }
      const normalized = ((totalMinutes % 1440) + 1440) % 1440;
      const hours = Math.floor(normalized / 60);
      const minutes = normalized % 60;
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
    }

    function hhmmToMinutes(value) {
      if (!value) {
        return 0;
      }
      const [hh, mm] = value.split(':').map((num) => parseInt(num, 10));
      if (Number.isNaN(hh) || Number.isNaN(mm)) {
        return 0;
      }
      return hh * 60 + mm;
    }

    function isRealTrainStation(name) {
      if (!name) {
        return false;
      }
      const trimmed = name.trim();
      if (trimmed === 'Luxembourg, Gare Centrale') {
        return true;
      }
      return trimmed.endsWith(', Gare');
    }

    const WEEKDAY_NAMES = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

    function dateInputToYYYYMMDD(value) {
      if (!value) {
        return null;
      }
      const parts = value.split('-');
      if (parts.length !== 3) {
        return null;
      }
      const [year, month, day] = parts;
      if (year.length !== 4 || month.length !== 2 || day.length !== 2) {
        return null;
      }
      return `${year}${month}${day}`;
    }

    function yyyymmddToISO(value) {
      if (!value || value.length !== 8) {
        return null;
      }
      const year = value.slice(0, 4);
      const month = value.slice(4, 6);
      const day = value.slice(6, 8);
      return `${year}-${month}-${day}`;
    }

    function yyyymmddToDate(value) {
      if (!value || value.length !== 8) {
        return null;
      }
      const year = parseInt(value.slice(0, 4), 10);
      const month = parseInt(value.slice(4, 6), 10);
      const day = parseInt(value.slice(6, 8), 10);
      if ([year, month, day].some((num) => Number.isNaN(num))) {
        return null;
      }
      return new Date(Date.UTC(year, month - 1, day));
    }

    function dateToYYYYMMDD(dateObj) {
      if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) {
        return null;
      }
      const year = dateObj.getUTCFullYear();
      const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
      const day = String(dateObj.getUTCDate()).padStart(2, '0');
      return `${year}${month}${day}`;
    }

    function addDaysToYYYYMMDD(value, days) {
      const dateObj = yyyymmddToDate(value);
      if (!dateObj) {
        return null;
      }
      dateObj.setUTCDate(dateObj.getUTCDate() + days);
      return dateToYYYYMMDD(dateObj);
    }

    function getWeekdayIndexFromYYYYMMDD(value) {
      const dateObj = yyyymmddToDate(value);
      if (!dateObj) {
        return null;
      }
      return dateObj.getUTCDay();
    }

    // 2. chargement et parsing GTFS
    async function loadGTFSData() {
      const pagePath = (window.location && typeof window.location.pathname === 'string')
        ? window.location.pathname.toLowerCase()
        : '';
      const prefixes = pagePath.includes('/cfl/') ? [''] : ['CFL/', ''];

      const fetchText = async (file) => {
        let lastError = null;
        for (let i = 0; i < prefixes.length; i++) {
          const prefix = prefixes[i];
          const url = `${prefix}${file}`;
          try {
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Chargement impossible (${response.status}) pour ${url}`);
            }
            return await response.text();
          } catch (error) {
            lastError = error;
          }
        }
        if (lastError) {
          throw lastError;
        }
        throw new Error(`Chargement impossible pour ${file}`);
      };

      const [
        routesText,
        stopsText,
        tripsText,
        stopTimes1Text,
        stopTimes2Text,
        calendarText,
        calendarDatesText
      ] = await Promise.all([
        fetchText('routes[1].txt'),
        fetchText('stops[1].txt'),
        fetchText('trips[1].txt'),
        fetchText('stop_times[1].txt'),
        fetchText('stop_times[2].txt'),
        fetchText('calendar[1].txt'),
        fetchText('calendar_dates[1].txt')
      ]);

      const routesRows = parseCSV(routesText);
      const stopsRows = parseCSV(stopsText);
      const tripsRows = parseCSV(tripsText);
      const stopTimesRows = parseCSV(stopTimes1Text).concat(parseCSV(stopTimes2Text));

      const calendarRows = parseCSV(calendarText);
      const calendarDatesRows = parseCSV(calendarDatesText);

      return buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows, calendarRows, calendarDatesRows);
    }

    // 3. construction des index (routesById, stopsById, tripsById, tripsStops)
    function buildCFLData(routesRows, stopsRows, tripsRows, stopTimesRows, calendarRows, calendarDatesRows) {
      const allowedRouteIds = new Set(['302', '301', '300', '299', '297']);
      const routesById = {};
      for (let i = 0; i < routesRows.length; i++) {
        const route = routesRows[i];
        if (route.agency_id === '11' && allowedRouteIds.has(route.route_id)) {
          routesById[route.route_id] = {
            shortName: route.route_short_name || '',
            longName: route.route_long_name || '',
            type: route.route_type || ''
          };
        }
      }

      const stopsById = {};
      for (let i = 0; i < stopsRows.length; i++) {
        const stop = stopsRows[i];
        const stopName = stop.stop_name ? stop.stop_name.trim() : '';
        if (!isRealTrainStation(stopName)) {
          continue;
        }
        const stopId = stop.stop_id;
        stopsById[stopId] = {
          name: stopName,
          lat: stop.stop_lat && !Number.isNaN(Number(stop.stop_lat)) ? Number(stop.stop_lat) : null,
          lon: stop.stop_lon && !Number.isNaN(Number(stop.stop_lon)) ? Number(stop.stop_lon) : null
        };
      }

      const tripsById = {};
      for (let i = 0; i < tripsRows.length; i++) {
        const trip = tripsRows[i];
        if (!routesById[trip.route_id]) {
          continue;
        }
        tripsById[trip.trip_id] = {
          route_id: trip.route_id,
          service_id: trip.service_id || '',
          headsign: trip.trip_headsign || '',
          shortName: trip.trip_short_name || '',
          direction: trip.direction_id || ''
        };
      }

      const tripsStopsTemp = {};
      for (let i = 0; i < stopTimesRows.length; i++) {
        const row = stopTimesRows[i];
        const tripId = row.trip_id;
        if (!tripsById[tripId]) {
          continue;
        }
        const stopInfo = stopsById[row.stop_id];
        if (!stopInfo) {
          continue;
        }
        const sequence = Number(row.stop_sequence);
        if (!Number.isFinite(sequence)) {
          continue;
        }
        const arrival = toMinutesSinceMidnight(row.arrival_time);
        const departure = toMinutesSinceMidnight(row.departure_time);
        const effectiveArrival = arrival !== null ? arrival : departure;
        const effectiveDeparture = departure !== null ? departure : arrival;
        if (!Number.isFinite(effectiveArrival) || !Number.isFinite(effectiveDeparture)) {
          continue;
        }
        if (!tripsStopsTemp[tripId]) {
          tripsStopsTemp[tripId] = [];
        }
        tripsStopsTemp[tripId].push({
          stop_id: row.stop_id,
          stop_name: stopInfo.name,
          lat: stopInfo.lat,
          lon: stopInfo.lon,
          arrival: effectiveArrival,
          departure: effectiveDeparture,
          seq: sequence
        });
      }

      const tripsStops = {};
      const filteredTripsById = {};
      const tripIds = Object.keys(tripsStopsTemp);
      for (let i = 0; i < tripIds.length; i++) {
        const tripId = tripIds[i];
        const stopsArray = tripsStopsTemp[tripId];
        stopsArray.sort((a, b) => a.seq - b.seq);
        if (stopsArray.length >= 2) {
          tripsStops[tripId] = stopsArray;
          filteredTripsById[tripId] = tripsById[tripId];
        }
      }

      const serviceCalendars = {};
      for (let i = 0; i < calendarRows.length; i++) {
        const row = calendarRows[i];
        const serviceId = row.service_id;
        if (!serviceId) {
          continue;
        }
        serviceCalendars[serviceId] = {
          startDate: row.start_date || '',
          endDate: row.end_date || '',
          days: {
            monday: Number(row.monday) === 1 ? 1 : 0,
            tuesday: Number(row.tuesday) === 1 ? 1 : 0,
            wednesday: Number(row.wednesday) === 1 ? 1 : 0,
            thursday: Number(row.thursday) === 1 ? 1 : 0,
            friday: Number(row.friday) === 1 ? 1 : 0,
            saturday: Number(row.saturday) === 1 ? 1 : 0,
            sunday: Number(row.sunday) === 1 ? 1 : 0
          }
        };
      }

      const serviceExceptions = {};
      for (let i = 0; i < calendarDatesRows.length; i++) {
        const row = calendarDatesRows[i];
        if (!row.service_id || !row.date) {
          continue;
        }
        if (!serviceExceptions[row.service_id]) {
          serviceExceptions[row.service_id] = {};
        }
        serviceExceptions[row.service_id][row.date] = row.exception_type || '';
      }

      return {
        routesById,
        stopsById,
        tripsById: filteredTripsById,
        tripsStops,
        serviceCalendars,
        serviceExceptions
      };
    }

    // 3b. disponibilité des services (calendriers et exceptions)
    function isServiceActiveForDate(data, tripInfo, targetDate, weekdayName) {
      if (!tripInfo || !tripInfo.service_id || !targetDate) {
        return false;
      }

      const serviceId = tripInfo.service_id;
      const exceptions = data.serviceExceptions && data.serviceExceptions[serviceId];
      if (exceptions && Object.prototype.hasOwnProperty.call(exceptions, targetDate)) {
        return exceptions[targetDate] === '1';
      }

      const calendar = data.serviceCalendars && data.serviceCalendars[serviceId];
      if (!calendar || !calendar.startDate || !calendar.endDate) {
        return false;
      }

      if (targetDate < calendar.startDate || targetDate > calendar.endDate) {
        return false;
      }

      if (!weekdayName) {
        return false;
      }

      return calendar.days && calendar.days[weekdayName] === 1;
    }

    function computeEarliestServiceDateISO(data) {
      let candidate = null;
      const pushCandidate = (dateStr) => {
        if (!dateStr || dateStr.length !== 8) {
          return;
        }
        if (!candidate || dateStr < candidate) {
          candidate = dateStr;
        }
      };

      if (data && data.serviceExceptions) {
        const exceptionEntries = Object.values(data.serviceExceptions);
        for (let i = 0; i < exceptionEntries.length; i++) {
          const record = exceptionEntries[i];
          const dates = Object.keys(record || {});
          for (let j = 0; j < dates.length; j++) {
            const dateKey = dates[j];
            if (record[dateKey] === '1') {
              pushCandidate(dateKey);
            }
          }
        }
      }

      if (data && data.serviceCalendars) {
        const calendarList = Object.values(data.serviceCalendars);
        for (let i = 0; i < calendarList.length; i++) {
          const calendar = calendarList[i];
          if (!calendar || !calendar.startDate || !calendar.endDate) {
            continue;
          }
          const startDate = calendar.startDate;
          const startWeekdayIndex = getWeekdayIndexFromYYYYMMDD(startDate);
          if (startWeekdayIndex === null) {
            pushCandidate(startDate);
            continue;
          }
          for (let offset = 0; offset < 7; offset++) {
            const weekdayIndex = (startWeekdayIndex + offset) % 7;
            const weekdayName = WEEKDAY_NAMES[weekdayIndex];
            if (calendar.days && calendar.days[weekdayName] === 1) {
              const possibleDate = addDaysToYYYYMMDD(startDate, offset);
              if (possibleDate && possibleDate <= calendar.endDate) {
                pushCandidate(possibleDate);
              }
              break;
            }
          }
        }
      }

      if (candidate) {
        return yyyymmddToISO(candidate);
      }

      const today = new Date();
      const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));
      return yyyymmddToISO(dateToYYYYMMDD(todayUTC));
    }

    // 4. moteur findDirectTrains
    function findDirectTrains(data, fromStopName, toStopName, minDepartureMinutes, travelDateISO) {
      if (!data || !fromStopName || !toStopName || !travelDateISO) {
        return [];
      }

      const targetDate = dateInputToYYYYMMDD(travelDateISO);
      if (!targetDate) {
        return [];
      }
      const weekdayIndex = getWeekdayIndexFromYYYYMMDD(targetDate);
      if (weekdayIndex === null) {
        return [];
      }
      const weekdayName = WEEKDAY_NAMES[weekdayIndex];

      const allFromStopIds = new Set();
      const allToStopIds = new Set();
      const stopEntries = Object.entries(data.stopsById || {});
      for (let i = 0; i < stopEntries.length; i++) {
        const [stopId, stopInfo] = stopEntries[i];
        if (stopInfo.name === fromStopName) {
          allFromStopIds.add(stopId);
        }
        if (stopInfo.name === toStopName) {
          allToStopIds.add(stopId);
        }
      }

      if (!allFromStopIds.size || !allToStopIds.size) {
        return [];
      }

      const results = [];
      const tripEntries = Object.entries(data.tripsStops || {});
      for (let i = 0; i < tripEntries.length; i++) {
        const [tripId, stopsSeq] = tripEntries[i];
        if (!Array.isArray(stopsSeq) || stopsSeq.length < 2) {
          continue;
        }

        const tripInfo = data.tripsById?.[tripId];
        if (!tripInfo) {
          continue;
        }
        if (!isServiceActiveForDate(data, tripInfo, targetDate, weekdayName)) {
          continue;
        }
        const routeInfo = data.routesById?.[tripInfo.route_id];
        if (!routeInfo) {
          continue;
        }

        let depStop = null;
        let arrStop = null;
        let depIndex = -1;
        let arrIndex = -1;

        for (let j = 0; j < stopsSeq.length; j++) {
          const currentStop = stopsSeq[j];
          if (!depStop && allFromStopIds.has(currentStop.stop_id)) {
            depStop = currentStop;
            depIndex = j;
          }
          if (depStop && allToStopIds.has(currentStop.stop_id)) {
            arrStop = currentStop;
            arrIndex = j;
            break;
          }
        }

        if (!depStop || !arrStop) {
          continue;
        }
        if (depIndex >= arrIndex) {
          continue;
        }

        const depTime = depStop.departure;
        if (!Number.isFinite(depTime) || depTime < minDepartureMinutes) {
          continue;
        }

        const arrTime = Number.isFinite(arrStop.arrival) ? arrStop.arrival : arrStop.departure;
        if (!Number.isFinite(arrTime)) {
          continue;
        }

        let duration = arrTime - depTime;
        if (duration < 0) {
          duration += 1440;
        }

        const slice = stopsSeq.slice(depIndex, arrIndex + 1);
        const intermediateStops = slice.map((stop) => ({
          name: stop.stop_name,
          arr: stop.arrival,
          dep: stop.departure
        }));

        results.push({
          trip_id: tripId,
          train_type: routeInfo.shortName || '',
          train_label: tripInfo.shortName || routeInfo.shortName || '',
          depart_station: depStop.stop_name,
          depart_time_min: depTime,
          arrive_station: arrStop.stop_name,
          arrive_time_min: arrTime,
          duration_min: duration,
          intermediate_stops: intermediateStops
        });
      }

      results.sort((a, b) => a.depart_time_min - b.depart_time_min);
      return results;
    }

    // 5. rendu UI
    function buildStopTimesText(stop, index, totalStops) {
      const arrMinutes = Number.isFinite(stop.arr) ? stop.arr : null;
      const depMinutes = Number.isFinite(stop.dep) ? stop.dep : null;
      const arrText = arrMinutes !== null ? minutesToHHMM(arrMinutes) : null;
      const depText = depMinutes !== null ? minutesToHHMM(depMinutes) : null;
      const isFirst = index === 0;
      const isLast = index === totalStops - 1;

      if (isFirst && isLast) {
        if (depText) {
          return `Départ ${depText}`;
        }
        if (arrText) {
          return `Arrivée ${arrText}`;
        }
        return 'Horaire indisponible';
      }

      if (isFirst) {
        if (depText) {
          return `Départ ${depText}`;
        }
        if (arrText) {
          return `Départ ${arrText}`;
        }
      } else if (isLast) {
        if (arrText) {
          return `Arrivée ${arrText}`;
        }
        if (depText) {
          return `Arrivée ${depText}`;
        }
      } else {
        const parts = [];
        if (arrText) {
          parts.push(`Arrivée ${arrText}`);
        }
        if (depMinutes !== null && depMinutes !== arrMinutes && depText) {
          parts.push(`Départ ${depText}`);
        }
        if (!parts.length && depText) {
          parts.push(`Départ ${depText}`);
        }
        if (!parts.length && arrText) {
          parts.push(`Passage ${arrText}`);
        }
        if (parts.length) {
          return parts.join(' · ');
        }
      }

      if (depText && arrText && depMinutes === arrMinutes) {
        return `Passage ${depText}`;
      }
      if (depText) {
        return `Départ ${depText}`;
      }
      if (arrText) {
        return `Arrivée ${arrText}`;
      }
      return 'Horaire indisponible';
    }

    function renderResults(container, results) {
      container.innerHTML = '';
      if (!Array.isArray(results) || results.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'card';
        empty.textContent = 'Aucun train direct trouvé après cette heure.';
        container.appendChild(empty);
        return;
      }

      const totalCount = results.length;
      const intro = document.createElement('div');
      intro.className = 'resultsIntro';
      const introPrefix = totalCount === 1 ? '1 trajet direct trouvé.' : `${totalCount} trajets directs trouvés.`;
      intro.textContent = `${introPrefix} Cliquez sur un trajet pour voir les détails.`;
      container.appendChild(intro);

      const MAX_RESULTS = 30;
      const limitedResults = results.slice(0, MAX_RESULTS);
      if (totalCount > MAX_RESULTS) {
        const note = document.createElement('div');
        note.className = 'resultsIntro';
        note.textContent = `Affichage des ${MAX_RESULTS} premiers résultats sur ${totalCount}. Ajustez l'heure pour affiner la recherche.`;
        container.appendChild(note);
      }

      for (let i = 0; i < limitedResults.length; i++) {
        const result = limitedResults[i];
        const card = document.createElement('div');
        card.className = 'card';

        const header = document.createElement('div');
        header.className = 'trainHeader';
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = result.train_type || 'Train';
        header.appendChild(badge);
        if (result.train_label) {
          const labelSpan = document.createElement('span');
          labelSpan.textContent = result.train_label;
          header.appendChild(labelSpan);
        }
        card.appendChild(header);

        const mainline = document.createElement('div');
        mainline.className = 'mainline';
        mainline.textContent = `${result.depart_station} ${minutesToHHMM(result.depart_time_min)} → ${result.arrive_station} ${minutesToHHMM(result.arrive_time_min)} (${result.duration_min} min)`;
        card.appendChild(mainline);

        const stopsArray = Array.isArray(result.intermediate_stops) ? result.intermediate_stops : [];
        if (stopsArray.length) {
          const quickDetails = document.createElement('div');
          quickDetails.className = 'details';
          const seenNames = new Set();
          const names = [];
          for (let j = 0; j < stopsArray.length; j++) {
            const stop = stopsArray[j];
            if (stop && stop.name && !seenNames.has(stop.name)) {
              seenNames.add(stop.name);
              names.push(stop.name);
            }
          }
          quickDetails.textContent = `Dessert : ${names.join(' · ')}`;
          card.appendChild(quickDetails);
        }

        const toggleBtn = document.createElement('button');
        toggleBtn.type = 'button';
        toggleBtn.className = 'toggleDetails';
        toggleBtn.textContent = 'Voir les détails du trajet';
        card.appendChild(toggleBtn);

        const detailPanel = document.createElement('div');
        detailPanel.className = 'detailPanel';
        detailPanel.setAttribute('hidden', '');
        const detailId = `trip-${result.trip_id}`;
        detailPanel.id = detailId;
        toggleBtn.setAttribute('aria-controls', detailId);
        toggleBtn.setAttribute('aria-expanded', 'false');

        const detailTitle = document.createElement('div');
        detailTitle.className = 'detailTitle';
        detailTitle.textContent = 'Arrêts desservis';
        detailPanel.appendChild(detailTitle);

        const stopsList = document.createElement('ul');
        stopsList.className = 'stopsList';
        for (let j = 0; j < stopsArray.length; j++) {
          const stop = stopsArray[j];
          const listItem = document.createElement('li');

          const nameSpan = document.createElement('span');
          nameSpan.className = 'stopName';
          nameSpan.textContent = stop.name;
          listItem.appendChild(nameSpan);

          const timesSpan = document.createElement('span');
          timesSpan.className = 'stopTimes';
          timesSpan.textContent = buildStopTimesText(stop, j, stopsArray.length);
          listItem.appendChild(timesSpan);

          stopsList.appendChild(listItem);
        }
        detailPanel.appendChild(stopsList);

        const tripMeta = document.createElement('div');
        tripMeta.className = 'details';
        tripMeta.textContent = `Identifiant du trajet : ${result.trip_id}`;
        detailPanel.appendChild(tripMeta);

        card.appendChild(detailPanel);

        toggleBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const isHidden = detailPanel.hasAttribute('hidden');
          if (isHidden) {
            detailPanel.removeAttribute('hidden');
            card.classList.add('expanded');
            toggleBtn.textContent = 'Masquer les détails';
            toggleBtn.setAttribute('aria-expanded', 'true');
          } else {
            detailPanel.setAttribute('hidden', '');
            card.classList.remove('expanded');
            toggleBtn.textContent = 'Voir les détails du trajet';
            toggleBtn.setAttribute('aria-expanded', 'false');
          }
        });

        container.appendChild(card);
      }
    }

    function populateStationSelects(stopsById, selectElements) {
      const unique = new Set();
      const names = [];
      const values = Object.values(stopsById || {});
      for (let i = 0; i < values.length; i++) {
        const stop = values[i];
        if (stop && stop.name && !unique.has(stop.name)) {
          unique.add(stop.name);
          names.push(stop.name);
        }
      }
      names.sort((a, b) => a.localeCompare(b, 'fr'));

      for (let i = 0; i < selectElements.length; i++) {
        const select = selectElements[i];
        const placeholder = select.options.length ? select.options[0] : null;
        select.innerHTML = '';
        if (placeholder) {
          placeholder.disabled = true;
          placeholder.selected = true;
          placeholder.value = '';
          select.appendChild(placeholder);
        } else {
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.disabled = true;
          defaultOption.selected = true;
          defaultOption.textContent = 'Choisir une gare';
          select.appendChild(defaultOption);
        }
        for (let j = 0; j < names.length; j++) {
          const option = document.createElement('option');
          option.value = names[j];
          option.textContent = names[j];
          select.appendChild(option);
        }
      }
    }

    function setCurrentTimeDefault(input) {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      input.value = hours + ':' + minutes;
    }

    function setTodayDefaultDate(input) {
      const today = new Date();
      const iso = today.toISOString().slice(0, 10);
      input.value = iso;
    }

    // 6. wiring des events
    document.addEventListener('DOMContentLoaded', () => {
      const fromSelect = document.getElementById('fromStation');
      const toSelect = document.getElementById('toStation');
      const minTimeInput = document.getElementById('minTime');
      const travelDateInput = document.getElementById('travelDate');
      const searchBtn = document.getElementById('searchBtn');
      const form = document.getElementById('searchForm');
      const resultsContainer = document.getElementById('results');
      const errorEl = document.getElementById('formError');

      setCurrentTimeDefault(minTimeInput);
      setTodayDefaultDate(travelDateInput);

      loadGTFSData()
        .then((data) => {
          window.CFL_DATA = data;
          populateStationSelects(data.stopsById, [fromSelect, toSelect]);
          const suggestedDate = computeEarliestServiceDateISO(data);
          if (suggestedDate) {
            travelDateInput.value = suggestedDate;
          }
          searchBtn.disabled = false;
          resultsContainer.classList.remove('loading');
          resultsContainer.textContent = '';
        })
        .catch((err) => {
          console.error('Erreur lors du chargement GTFS', err);
          resultsContainer.classList.remove('loading');
          resultsContainer.textContent = "Impossible de charger les données GTFS.";
        });

      form.addEventListener('submit', (event) => {
        event.preventDefault();
        errorEl.textContent = '';
        const fromName = fromSelect.value;
        const toName = toSelect.value;
        const travelDate = travelDateInput.value;
        if (!fromName || !toName) {
          errorEl.textContent = 'Veuillez sélectionner une gare de départ et d\'arrivée.';
          return;
        }
        if (fromName === toName) {
          errorEl.textContent = 'La gare de départ doit être différente de la gare d\'arrivée.';
          return;
        }
        if (!travelDate) {
          errorEl.textContent = 'Veuillez choisir une date de voyage.';
          return;
        }
        if (!window.CFL_DATA) {
          errorEl.textContent = 'Les données ne sont pas encore chargées.';
          return;
        }
        const minMinutes = hhmmToMinutes(minTimeInput.value);
        const results = findDirectTrains(window.CFL_DATA, fromName, toName, minMinutes, travelDate);
        renderResults(resultsContainer, results);
      });
    });
  </script>
</body>
</html>
