<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train Bétail - Jeu Snake</title>
<style>
  body {
    background-color: #000;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
    user-select: none;
  }
  h1 {
    margin-top: 20px;
  }
  #gameCanvas {
    background-color: #111;
    border: 3px solid #0ff;
    margin-top: 20px;
    display: block;
  }
  #info {
    margin-top: 15px;
    font-size: 18px;
    text-align: center;
  }
</style>
</head>
<body>

<h1>Train Bétail - Évite les suppressions !</h1>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="info">
  Utilise <b>flèche haut</b>, <b>flèche bas</b>, <b>flèche gauche</b>, <b>flèche droite</b> pour changer la direction.<br>
  Le train grandit à chaque mouvement, évite les cases rouges (suppressions) et attention aux cases oranges qui accélèrent le train !
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const gridSize = 20;
  const cols = canvas.width / gridSize;
  const rows = canvas.height / gridSize;

  const colorTrainHead = "#0ff";
  const colorTrainBody = "#088";
  const colorSuppression = "#f33";
  const colorAcceleration = "#f90";

  let train = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  let direction = { x: 0, y: -1 }; // direction initiale : vers le haut
  let nextDirection = direction;
  let speed = 300;

  let suppressions = [];
  let accelerateurs = [];

  // Place suppressions et accélérateurs sur la grille, pas sur le train
  function placePerturbations() {
    suppressions = [];
    for(let i = 0; i < 8; i++) {
      let pos;
      do {
        pos = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
      } while(isOnTrain(pos) || isOnPerturbation(pos));
      suppressions.push(pos);
    }

    accelerateurs = [];
    for(let i = 0; i < 5; i++) {
      let pos;
      do {
        pos = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
      } while(isOnTrain(pos) || isOnPerturbation(pos));
      accelerateurs.push(pos);
    }
  }

  function isOnTrain(pos) {
    return train.some(t => t.x === pos.x && t.y === pos.y);
  }

  function isOnPerturbation(pos) {
    return suppressions.some(p => p.x === pos.x && p.y === pos.y) ||
           accelerateurs.some(a => a.x === pos.x && a.y === pos.y);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grille
    ctx.strokeStyle = "#222";
    for(let x = 0; x <= cols; x++) {
      ctx.beginPath();
      ctx.moveTo(x * gridSize, 0);
      ctx.lineTo(x * gridSize, canvas.height);
      ctx.stroke();
    }
    for(let y = 0; y <= rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * gridSize);
      ctx.lineTo(canvas.width, y * gridSize);
      ctx.stroke();
    }

    // Suppressions
    suppressions.forEach(p => {
      ctx.fillStyle = colorSuppression;
      ctx.fillRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4);
    });

    // Accélérateurs
    accelerateurs.forEach(p => {
      ctx.fillStyle = colorAcceleration;
      ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8);
    });

    // Train
    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? colorTrainHead : colorTrainBody;
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  function gameLoop() {
    // Met à jour la direction (interdiction de demi-tour)
    if ((nextDirection.x !== -direction.x || nextDirection.y !== -direction.y)) {
      direction = nextDirection;
    }

    const head = { x: train[0].x + direction.x, y: train[0].y + direction.y };

    // Rebondir sur les bords
    if (head.x < 0) head.x = cols - 1;
    else if (head.x >= cols) head.x = 0;
    if (head.y < 0) head.y = rows - 1;
    else if (head.y >= rows) head.y = 0;

    // Collision avec le train (sauf la queue, qui va bouger)
    if (train.slice(0, -1).some(t => t.x === head.x && t.y === head.y)) {
      alert("Perdu : collision avec votre propre train !");
      resetGame();
      return;
    }

    // Collision avec suppression
    if (suppressions.some(p => p.x === head.x && p.y === head.y)) {
      alert("Perdu : votre train a rencontré une suppression !");
      resetGame();
      return;
    }

    train.unshift(head); // ajoute la tête

    // Accélération
    if (accelerateurs.some(p => p.x === head.x && p.y === head.y)) {
      speed = Math.max(80, speed - 40);
    }

    // Le train grandit à chaque mouvement (pas de suppression de queue)
    // On pourrait ajouter ici une condition pour ne pas grandir sans fin.

    draw();

    setTimeout(gameLoop, speed);
  }

  function resetGame() {
    train = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
    direction = { x: 0, y: -1 };
    nextDirection = direction;
    speed = 300;
    placePerturbations();
    draw();
    setTimeout(gameLoop, speed);
  }

  window.addEventListener("keydown", e => {
    switch(e.key) {
      case "ArrowUp":
        nextDirection = { x: 0, y: -1 };
        break;
      case "ArrowDown":
        nextDirection = { x: 0, y: 1 };
        break;
      case "ArrowLeft":
        nextDirection = { x: -1, y: 0 };
        break;
      case "ArrowRight":
        nextDirection = { x: 1, y: 0 };
        break;
    }
  });

  resetGame();
})();
</script>

</body>
</html>
