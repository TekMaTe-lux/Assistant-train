<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train Snake - Jeu Bétail & Perturbations</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
  body {
    background: #000010;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
    height: 100vh;
    user-select: none;
  }
  h1 {
    margin-top: 10px;
    text-shadow: 0 0 12px #0ff;
  }
  #game-container {
    margin-top: 20px;
    position: relative;
  }
  #grid {
    display: grid;
    grid-template-columns: repeat(20, 25px);
    grid-template-rows: repeat(20, 25px);
    gap: 2px;
    background: #111122;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 0 20px #0ff;
  }
  .cell {
    width: 25px;
    height: 25px;
    background: #001122;
    border-radius: 6px;
    box-shadow: inset 0 0 5px #0ff33;
    position: relative;
  }
  .train-head {
    background: linear-gradient(135deg, #00ffff, #0066ff);
    box-shadow: 0 0 10px #00ffff;
    border-radius: 8px 8px 8px 8px;
    z-index: 10;
  }
  .train-body {
    background: #0099ff;
    box-shadow: 0 0 6px #00ccff;
  }
  .betail {
    background: #ffff33;
    box-shadow: 0 0 10px #ffff00;
  }
  .suppression {
    background: #ff2222;
    box-shadow: 0 0 12px #ff0000;
  }
  .retard {
    background: #ff7700;
    box-shadow: 0 0 10px #ff6600;
  }
  #info {
    margin-top: 15px;
    text-align: center;
    font-size: 1.2em;
    min-width: 320px;
  }
  #score, #speed {
    margin: 0 15px;
    display: inline-block;
    min-width: 120px;
  }
  #message {
    margin-top: 15px;
    font-size: 1.3em;
    color: #0ff;
    text-shadow: 0 0 10px #0ff;
    min-height: 30px;
  }
  button {
    margin-top: 20px;
    background: #001122;
    border: 1.5px solid #0ff;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    font-size: 1.1em;
    padding: 8px 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.3s;
  }
  button:hover {
    background: #003344;
    box-shadow: 0 0 15px #0ff;
  }
  @media (max-width: 480px) {
    #grid {
      grid-template-columns: repeat(20, 18px);
      grid-template-rows: repeat(20, 18px);
      gap: 1px;
      padding: 5px;
    }
    .cell {
      width: 18px;
      height: 18px;
      border-radius: 4px;
    }
    #info {
      font-size: 1em;
      min-width: 280px;
    }
  }
</style>
</head>
<body>

<h1>Train Snake - Bétail & Perturbations</h1>

<div id="game-container">
  <div id="grid"></div>
</div>

<div id="info">
  <span id="score">Bétail ramassé : 0</span>
  <span id="speed">Vitesse : 5</span>
  <div id="message"></div>
</div>

<button id="startBtn">Démarrer la partie</button>

<script>
  const ROWS = 20;
  const COLS = 20;

  const gridElem = document.getElementById('grid');
  const scoreElem = document.getElementById('score');
  const speedElem = document.getElementById('speed');
  const messageElem = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');

  // Cell types
  const CELL_TYPES = {
    EMPTY: 'empty',
    TRAIN_HEAD: 'train-head',
    TRAIN_BODY: 'train-body',
    BETAIL: 'betail',
    SUPPRESSION: 'suppression',
    RETARD: 'retard'
  };

  let grid = [];
  let train = []; // array of cells {r,c}
  let direction = {r: 0, c: 1}; // start moving right
  let nextDirection = null;
  let score = 0;
  let speed = 5; // ticks per second
  let gameInterval = null;
  let gameRunning = false;

  // Création grille vide
  function createGrid() {
    gridElem.innerHTML = '';
    grid = [];
    for(let r=0; r<ROWS; r++){
      const row = [];
      for(let c=0; c<COLS; c++){
        const cell = document.createElement('div');
        cell.classList.add('cell');
        gridElem.appendChild(cell);
        row.push({elem: cell, type: CELL_TYPES.EMPTY});
      }
      grid.push(row);
    }
  }

  // Set type cellule
  function setCell(r,c,type){
    const cell = grid[r][c];
    cell.type = type;
    cell.elem.className = 'cell';
    if(type !== CELL_TYPES.EMPTY) cell.elem.classList.add(type);
  }

  // Placer aléatoirement type donné, sans collision avec train ni autres items
  function placeRandom(type, count){
    let placed = 0;
    while(placed < count){
      const r = Math.floor(Math.random() * ROWS);
      const c = Math.floor(Math.random() * COLS);
      if(grid[r][c].type === CELL_TYPES.EMPTY && !train.some(pos => pos.r === r && pos.c === c)){
        setCell(r,c,type);
        placed++;
      }
    }
  }

  // Initialisation jeu
  function initGame(){
    createGrid();
    score = 0;
    speed = 5;
    direction = {r: 0, c: 1};
    nextDirection = null;
    gameRunning = true;
    messageElem.textContent = '';
    scoreElem.textContent = `Bétail ramassé : ${score}`;
    speedElem.textContent = `Vitesse : ${speed}`;

    // train départ bas-gauche taille 3 vers droite
    train = [
      {r: ROWS - 1, c: 0},
      {r: ROWS - 1, c: 1},
      {r: ROWS - 1, c: 2},
    ];
    train.forEach((pos, i) => {
      setCell(pos.r, pos.c, i === train.length - 1 ? CELL_TYPES.TRAIN_HEAD : CELL_TYPES.TRAIN_BODY);
    });

    // Placer wagons bétail
    placeRandom(CELL_TYPES.BETAIL, 10);

    // Placer suppressions
    placeRandom(CELL_TYPES.SUPPRESSION, 25);

    // Placer retards
    placeRandom(CELL_TYPES.RETARD, 15);

    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameTick, 1000 / speed);
  }

  // Mise à jour vitesse intervalle
  function updateSpeed(){
    clearInterval(gameInterval);
    gameInterval = setInterval(gameTick, 1000 / speed);
    speedElem.textContent = `Vitesse : ${speed}`;
  }

  // Tourner à gauche ou droite
  // direction actuelle : {r,c}
  // tourner à gauche : newDirection = { -c, r }
  // tourner à droite : newDirection = { c, -r }
  function turnLeft(){
    const {r,c} = direction;
    direction = {r: -c, c: r};
  }
  function turnRight(){
    const {r,c} = direction;
    direction = {r: c, c: -r};
  }

  // Tick du jeu
  function gameTick(){
    if(!gameRunning) return;

    // Appliquer direction suivante si définie (gestion input plus fluide)
    if(nextDirection){
      direction = nextDirection;
      nextDirection = null;
    }

    const head = train[train.length -1];
    const newHead = {r: head.r + direction.r, c: head.c + direction.c};

    // Vérifier collisions bord
    if(newHead.r < 0 || newHead.r >= ROWS || newHead.c < 0 || newHead.c >= COLS){
      endGame("Collision avec bord ! Partie terminée.");
      return;
    }
    // Vérifier collision avec train
    if(train.some(pos => pos.r === newHead.r && pos.c === newHead.c)){
      endGame("Collision avec le train ! Partie terminée.");
      return;
    }

    // Vérifier type cellule nouvelle tête
    const cellType = grid[newHead.r][newHead.c].type;

    if(cellType === CELL_TYPES.SUPPRESSION){
      endGame("Train supprimé ! Partie terminée.");
      return;
    }

    let grow = false;

    if(cellType === CELL_TYPES.BETAIL){
      score++;
      grow = true;
      // Placer un nouveau bétail ailleurs
      placeRandom(CELL_TYPES.BETAIL, 1);

      // Tous les 3 bétails, augmenter vitesse
      if(score % 3 === 0){
        speed++;
        updateSpeed();
      }
    }

    if(cellType === CELL_TYPES.RETARD){
      // Augmenter vitesse (train accélère)
      speed++;
      updateSpeed();
      // retirer retard de cette case (car train est passé dessus)
      setCell(newHead.r, newHead.c, CELL_TYPES.EMPTY);
    }

    // Déplacer train :
    // Si pas croissance, retirer queue
    if(!grow){
      const tail = train.shift();
      setCell(tail.r, tail.c, CELL_TYPES.EMPTY);
    }

    // Ajouter nouvelle tête
    train.push(newHead);

    // Réafficher train
    train.forEach((pos, i) => {
      setCell(pos.r, pos.c, i === train.length - 1 ? CELL_TYPES.TRAIN_HEAD : CELL_TYPES.TRAIN_BODY);
    });

    // Mettre à jour score
    scoreElem.textContent = `Bétail ramassé : ${score}`;
  }

  // Fin du jeu
  function endGame(msg){
    gameRunning = false;
    messageElem.textContent = msg + ` Score final: ${score}`;
    startBtn.style.display = 'inline-block';
    clearInterval(gameInterval);
  }

  // Gestion clavier : uniquement tourner à gauche ou droite (flèches gauche/droite)
  window.addEventListener('keydown', e => {
    if(!gameRunning) return;

    if(e.key === 'ArrowLeft'){
      // tourner gauche à partir de la direction actuelle
      const {r,c} = direction;
      nextDirection = {r: -c, c: r};
      e.preventDefault();
    } else if(e.key === 'ArrowRight'){
      // tourner droite
      const {r,c} = direction;
      nextDirection = {r: c, c: -r};
      e.preventDefault();
    }
  });

  // Bouton démarrer
  startBtn.addEventListener('click', () => {
    startBtn.style.display = 'none';
    initGame();
  });

  // Initialisation grille à l'ouverture
  createGrid();
</script>

</body>
</html>
