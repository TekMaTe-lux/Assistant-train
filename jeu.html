<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train Bétail - Jeu</title>
<style>
  body {
    background: black;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
  }
  canvas {
    background: #111;
    margin-top: 20px;
    border: 2px solid #0ff;
    box-shadow: 0 0 20px #0ff99;
  }
  #score {
    font-size: 1.2em;
    margin-top: 10px;
  }
</style>
</head>
<body>

<h1>Train Bétail - Évite les suppressions et traversées de vaches !</h1>
<canvas id="game" width="400" height="400"></canvas>
<div id="score">Score: 0</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const gridSize = 20;
  const tileCount = canvas.width / gridSize; // 20x20 grille

  let train = [{x:10, y:10}]; // tête au centre
  let direction = 'right';
  let pendingDirection = null;
  let vitesseTrain = 10; // frames par seconde
  let vitesseActuelle = vitesseTrain;
  let vitesseBonus = 0;
  let vitesseMalus = 0;

  let betail = {x:5, y:5};
  let caseOrange = null; // accélération ou ralentissement temporaire
  let orangeTimer = 0;

  let suppressions = []; // cases rouges à éviter (statique)
  // Exemples de suppressions fixes (à changer)
  suppressions.push({x:15, y:10});
  suppressions.push({x:3, y:12});
  suppressions.push({x:17, y:5});

  let traverses = []; // traversées de vaches violettes

  let score = 0;
  let gameOver = false;

  function placeBetail() {
    while(true) {
      let x = Math.floor(Math.random() * tileCount);
      let y = Math.floor(Math.random() * tileCount);
      if (!train.some(t => t.x === x && t.y === y) &&
          !suppressions.some(s => s.x === x && s.y === y) &&
          !traverses.some(tr => tr.cells.some(c => c.x === x && c.y === y))) {
        betail = {x, y};
        break;
      }
    }
  }

  function placeOrange() {
    while(true) {
      let x = Math.floor(Math.random() * tileCount);
      let y = Math.floor(Math.random() * tileCount);
      if (!train.some(t => t.x === x && t.y === y) &&
          !suppressions.some(s => s.x === x && s.y === y) &&
          !(betail.x === x && betail.y === y) &&
          !traverses.some(tr => tr.cells.some(c => c.x === x && c.y === y))) {
        caseOrange = {x, y};
        break;
      }
    }
  }

  // Génère une traversée de 3 vaches violet
  // direction 'h' = horizontale, 'v' = verticale
  // vitesse en frames (plus bas = plus rapide)
  function addTraverse() {
    let dir = Math.random() < 0.5 ? 'h' : 'v';
    let speed = Math.floor(Math.random() * 5) + 3; // 3 à 7 frames par déplacement
    let start;
    let cells = [];

    if (dir === 'h') {
      // horizontale : ligne de 3 cases, départ gauche ou droite
      let y = Math.floor(Math.random() * (tileCount - 2)) + 1; // pas tout en bordure
      let fromLeft = Math.random() < 0.5;
      for (let i=0; i<3; i++) {
        cells.push({x: fromLeft ? -i : tileCount + i, y});
      }
      start = fromLeft ? 1 : -1;
      traverses.push({dir, speed, counter: 0, cells, movingForward: fromLeft});
    } else {
      // verticale : ligne de 3 cases, départ haut ou bas
      let x = Math.floor(Math.random() * (tileCount - 2)) + 1;
      let fromTop = Math.random() < 0.5;
      for (let i=0; i<3; i++) {
        cells.push({x, y: fromTop ? -i : tileCount + i});
      }
      start = fromTop ? 1 : -1;
      traverses.push({dir, speed, counter: 0, cells, movingForward: fromTop});
    }
  }

  // Déplace toutes les traversées selon leur vitesse et sens
  function moveTraverses() {
    traverses.forEach(tr => {
      tr.counter++;
      if (tr.counter >= tr.speed) {
        tr.counter = 0;
        if (tr.dir === 'h') {
          // horizontal, déplace x selon movingForward
          tr.cells = tr.cells.map(c => ({
            x: tr.movingForward ? c.x + 1 : c.x - 1,
            y: c.y
          }));
          // Si toute la ligne est sortie, on supprime
          if (tr.movingForward && tr.cells[0].x > tileCount) {
            traverses.splice(traverses.indexOf(tr),1);
          } else if (!tr.movingForward && tr.cells[0].x < -3) {
            traverses.splice(traverses.indexOf(tr),1);
          }
        } else {
          // vertical, déplace y selon movingForward
          tr.cells = tr.cells.map(c => ({
            x: c.x,
            y: tr.movingForward ? c.y + 1 : c.y - 1
          }));
          if (tr.movingForward && tr.cells[0].y > tileCount) {
            traverses.splice(traverses.indexOf(tr),1);
          } else if (!tr.movingForward && tr.cells[0].y < -3) {
            traverses.splice(traverses.indexOf(tr),1);
          }
        }
      }
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // grille
    ctx.strokeStyle = '#222';
    for(let i=0; i <= tileCount; i++) {
      ctx.beginPath();
      ctx.moveTo(i*gridSize,0);
      ctx.lineTo(i*gridSize,canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,i*gridSize);
      ctx.lineTo(canvas.width,i*gridSize);
      ctx.stroke();
    }

    // train (vert)
    ctx.fillStyle = '#0f0';
    train.forEach((part, i) => {
      ctx.fillRect(part.x*gridSize, part.y*gridSize, gridSize, gridSize);
    });

    // bétail jaune
    ctx.fillStyle = 'yellow';
    ctx.fillRect(betail.x*gridSize, betail.y*gridSize, gridSize, gridSize);

    // case orange (bonus/malus)
    if (caseOrange) {
      ctx.fillStyle = 'orange';
      ctx.fillRect(caseOrange.x*gridSize, caseOrange.y*gridSize, gridSize, gridSize);
    }

    // suppressions rouges
    ctx.fillStyle = 'red';
    suppressions.forEach(s => {
      ctx.fillRect(s.x*gridSize, s.y*gridSize, gridSize, gridSize);
    });

    // traversées violettes
    ctx.fillStyle = 'purple';
    traverses.forEach(tr => {
      tr.cells.forEach(c => {
        if (c.x >= 0 && c.x < tileCount && c.y >= 0 && c.y < tileCount)
          ctx.fillRect(c.x*gridSize, c.y*gridSize, gridSize, gridSize);
      });
    });
  }

  function gameOverFunc() {
    gameOver = true;
    alert("Collision avec une suppression ou une traversée de vaches ! Jeu terminé.\nScore: " + score);
    document.location.reload();
  }

  function update() {
    if (gameOver) return;

    // Gestion de la direction pour éviter demi-tour
    if (pendingDirection) {
      if ( (pendingDirection === 'up' && direction !== 'down') ||
           (pendingDirection === 'down' && direction !== 'up') ||
           (pendingDirection === 'left' && direction !== 'right') ||
           (pendingDirection === 'right' && direction !== 'left') ) {
        direction = pendingDirection;
      }
      pendingDirection = null;
    }

    // déplace la tête selon direction
    let head = {...train[0]};
    switch(direction) {
      case 'up': head.y--; break;
      case 'down': head.y++; break;
      case 'left': head.x--; break;
      case 'right': head.x++; break;
    }

    // rebond grille ?
    if (head.x < 0) head.x = tileCount-1;
    else if (head.x >= tileCount) head.x = 0;
    if (head.y < 0) head.y = tileCount-1;
    else if (head.y >= tileCount) head.y = 0;

    // collision avec le corps
    if (train.some(seg => seg.x === head.x && seg.y === head.y)) {
      gameOverFunc();
      return;
    }

    // collision avec suppression
    if (suppressions.some(s => s.x === head.x && s.y === head.y)) {
      gameOverFunc();
      return;
    }

    // collision avec traversée violette
    for(let tr of traverses) {
      if (tr.cells.some(c => c.x === head.x && c.y === head.y)) {
        gameOverFunc();
        return;
      }
    }

    train.unshift(head);

    // ramasse betail
    if (head.x === betail.x && head.y === betail.y) {
      score++;
      document.getElementById('score').textContent = "Score: " + score;
      placeBetail();

      // ajoute un nouveau segment (le train grandit)
    } else {
      train.pop();
    }

    // gère l'orange (bonus/malus)
    if (caseOrange) {
      if (head.x === caseOrange.x && head.y === caseOrange.y) {
        orangeTimer = 120; // 2 secondes à 60fps
        // bonus ou malus aléatoire
        if (Math.random() < 0.5) {
          vitesseBonus = 5;
          vitesseMalus = 0;
        } else {
          vitesseMalus = 5;
          vitesseBonus = 0;
        }
        caseOrange = null;
        placeOrange();
      }
    }

    if (orangeTimer > 0) {
      orangeTimer--;
      if (vitesseBonus > 0) {
        vitesseActuelle = vitesseTrain + 5;
      } else if (vitesseMalus > 0) {
        vitesseActuelle = vitesseTrain - 5 > 1 ? vitesseTrain - 5 : 1;
      }
    } else {
      vitesseActuelle = vitesseTrain;
      vitesseBonus = 0;
      vitesseMalus = 0;
    }

    // avance traversées de vaches
    moveTraverses();

    // aléatoire : création de traversée avec probabilité 1/150 par frame (ajuste si besoin)
    if (Math.random() < 1/150) {
      addTraverse();
    }
  }

  window.addEventListener("keydown", e => {
    switch(e.key) {
      case 'ArrowUp':
        if (direction !== 'down') pendingDirection = 'up';
        break;
      case 'ArrowDown':
        if (direction !== 'up') pendingDirection = 'down';
        break;
      case 'ArrowLeft':
        if (direction !== 'right') pendingDirection = 'left';
        break;
      case 'ArrowRight':
        if (direction !== 'left') pendingDirection = 'right';
        break;
    }
  });

  placeBetail();
  placeOrange();

  let lastTime = 0;
  function gameLoop(time=0) {
    if (!lastTime) lastTime = time;
    const delta = time - lastTime;
    if (delta > 1000 / vitesseActuelle) {
      update();
      draw();
      lastTime = time;
    }
    requestAnimationFrame(gameLoop);
  }
  gameLoop();

})();
</script>

</body>
</html>
