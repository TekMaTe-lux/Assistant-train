<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train Snake - Bétail & Perturbations</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
  body {
    background: #000010;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
    height: 100vh;
    user-select: none;
  }
  h1 {
    margin-top: 10px;
    text-shadow: 0 0 12px #0ff;
  }
  #game-container {
    margin-top: 20px;
    position: relative;
  }
  #grid {
    display: grid;
    grid-template-columns: repeat(20, 25px);
    grid-template-rows: repeat(20, 25px);
    gap: 2px;
    background: #111122;
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 0 20px #0ff;
  }
  .cell {
    width: 25px;
    height: 25px;
    background: #001122;
    border-radius: 6px;
    box-shadow: inset 0 0 5px #0ff33;
    position: relative;
  }
  .train-head {
    background: linear-gradient(135deg, #00ffff, #0066ff);
    box-shadow: 0 0 10px #00ffff;
    border-radius: 8px 8px 8px 8px;
    z-index: 10;
  }
  .train-body {
    background: #0099ff;
    box-shadow: 0 0 6px #00ccff;
  }
  .betail {
    background: #ffff33;
    box-shadow: 0 0 10px #ffff00;
  }
  .suppression {
    background: #ff2222;
    box-shadow: 0 0 12px #ff0000;
  }
  .retard {
    background: #ff7700;
    box-shadow: 0 0 10px #ff6600;
  }
  #info {
    margin-top: 15px;
    text-align: center;
    font-size: 1.2em;
    min-width: 320px;
  }
  #score, #speed {
    margin: 0 15px;
    display: inline-block;
    min-width: 120px;
  }
  #message {
    margin-top: 15px;
    font-size: 1.3em;
    color: #0ff;
    text-shadow: 0 0 10px #0ff;
    min-height: 30px;
  }
  button {
    margin-top: 20px;
    background: #001122;
    border: 1.5px solid #0ff;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    font-size: 1.1em;
    padding: 8px 20px;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.3s;
  }
  button:hover {
    background: #003344;
    box-shadow: 0 0 15px #0ff;
  }
  @media (max-width: 480px) {
    #grid {
      grid-template-columns: repeat(20, 18px);
      grid-template-rows: repeat(20, 18px);
      gap: 1px;
      padding: 5px;
    }
    .cell {
      width: 18px;
      height: 18px;
      border-radius: 4px;
    }
    #info {
      font-size: 1em;
      min-width: 280px;
    }
  }
</style>
</head>
<body>

<h1>Train Snake - Bétail & Perturbations</h1>

<div id="game-container">
  <div id="grid"></div>
</div>

<div id="info">
  <span id="score">Bétail ramassé : 0</span>
  <span id="speed">Vitesse : 5</span>
  <div id="message"></div>
</div>

<button id="startBtn">Démarrer la partie</button>

<script>
  const ROWS = 20;
  const COLS = 20;

  const gridElem = document.getElementById('grid');
  const scoreElem = document.getElementById('score');
  const speedElem = document.getElementById('speed');
  const messageElem = document.getElementById('message');
  const startBtn = document.getElementById('startBtn');

  // Cell types
  const CELL_TYPES = {
    EMPTY: 'empty',
    TRAIN_HEAD: 'train-head',
    TRAIN_BODY: 'train-body',
    BETAIL: 'betail',
    SUPPRESSION: 'suppression',
    RETARD: 'retard'
  };

  let grid = [];
  let train = []; // array of cells {r,c}
  let direction = {r: 0, c: 1}; // start moving right
  let nextTurn = 0; // 0: none, 1:left, 2:right
  let score = 0;
  let speed = 5; // ticks per second
  let gameInterval = null;
  let gameRunning = false;
  let ticks = 0; // compteur pour ajout bétail auto

  // Création grille vide
  function createGrid() {
    gridElem.innerHTML = '';
    grid = [];
    for(let r=0; r<ROWS; r++){
      const row = [];
      for(let c=0; c<COLS; c++){
        const cell = document.createElement('div');
        cell.classList.add('cell');
        gridElem.appendChild(cell);
        row.push({elem: cell, type: CELL_TYPES.EMPTY});
      }
      grid.push(row);
    }
  }

  // Set type cellule
  function setCell(r,c,type){
    const cell = grid[r][c];
    cell.type = type;
    cell.elem.className = 'cell';
    if(type !== CELL_TYPES.EMPTY) cell.elem.classList.add(type);
  }

  // Placer aléatoirement type donné, sans collision avec train ni autres items
  function placeRandom(type, count){
    let placed = 0;
    while(placed < count){
      const r = Math.floor(Math.random() * ROWS);
      const c = Math.floor(Math.random() * COLS);
      if(grid[r][c].type === CELL_TYPES.EMPTY && !train.some(pos => pos.r === r && pos.c === c)){
        setCell(r,c,type);
        placed++;
      }
    }
  }

  // Initialisation jeu
  function initGame(){
    createGrid();
    score = 0;
    speed = 5;
    direction = {r: 0, c: 1};
    nextTurn = 0;
    gameRunning = true;
    ticks = 0;
    messageElem.textContent = '';
    scoreElem.textContent = `Bétail ramassé : ${score}`;
    speedElem.textContent = `Vitesse : ${speed}`;

    // train départ bas-gauche taille 3 vers droite
    train = [
      {r: ROWS - 1, c: 0},
      {r: ROWS - 1, c: 1},
      {r: ROWS - 1, c: 2},
    ];
    train.forEach((pos, i) => {
      setCell(pos.r, pos.c, i === train.length - 1 ? CELL_TYPES.TRAIN_HEAD : CELL_TYPES.TRAIN_BODY);
    });

    // Placer wagons bétail initiaux
    placeRandom(CELL_TYPES.BETAIL, 5);

    // Placer suppressions
    placeRandom(CELL_TYPES.SUPPRESSION, 20);

    // Placer retards
    placeRandom(CELL_TYPES.RETARD, 10);

    if(gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameTick, 1000 / speed);
  }

  // Mise à jour vitesse intervalle
  function updateSpeed(){
    clearInterval(gameInterval);
    gameInterval = setInterval(gameTick, 1000 / speed);
    speedElem.textContent = `Vitesse : ${speed}`;
  }

  // Tourner à gauche ou droite
  // direction actuelle : {r,c}
  // tourner à gauche : newDirection = { -c, r }
  // tourner à droite : newDirection = { c, -r }
  function turnLeft(){
    const {r,c} = direction;
    direction = {r: -c, c: r};
  }
  function turnRight(){
    const {r,c} = direction;
    direction = {r: c, c: -r};
  }

  // Ajoute un wagon (ne pas retirer la queue au prochain tick)
  function growTrain(){
    // on laisse la queue en place (en ne supprimant pas la dernière position au déplacement)
    growing = true;
  }
  let growing = false;

  // Ajout d'un bétail aléatoire sur la grille, sans collision
  function addBetail(){
    placeRandom(CELL_TYPES.BETAIL, 1);
  }

  // Tick du jeu
  function gameTick(){
    if(!gameRunning) return;

    ticks++;

    // Traiter virage demandé
    if(nextTurn === 1){
      turnLeft();
    } else if(nextTurn === 2){
      turnRight();
    }
    nextTurn = 0;

    // Calcul nouvelle tête
    const head = train[train.length -1];
    let newR = head.r + direction.r;
    let newC = head.c + direction.c;

    // Gestion rebond sur murs (game over)
    if(newR < 0 || newR >= ROWS || newC < 0 || newC >= COLS){
      gameOver("Collision avec un mur !");
      return;
    }

    // Collision avec le train lui-même ?
    if(train.some(pos => pos.r === newR && pos.c === newC)){
      gameOver("Collision avec le train !");
      return;
    }

    // Obtenir type cellule cible
    const cellType = grid[newR][newC].type;

    // Gestion collisions
    if(cellType === CELL_TYPES.SUPPRESSION){
      gameOver("Train supprimé ! Collision avec suppression.");
      return;
    }
    if(cellType === CELL_TYPES.RETARD){
      // Juste un avertissement + ralentir un peu
      messageElem.textContent = "Attention : Retard détecté, vitesse réduite !";
      speed = Math.max(2, speed - 1);
      updateSpeed();
    }

    // Avancer train : ajouter nouvelle tête
    train.push({r: newR, c: newC});
    setCell(newR, newC, CELL_TYPES.TRAIN_HEAD);

    // L'ancienne tête devient corps
    const oldHead = train[train.length -2];
    setCell(oldHead.r, oldHead.c, CELL_TYPES.TRAIN_BODY);

    if(cellType === CELL_TYPES.BETAIL){
      // Ramasser le bétail, augmenter score, vitesse + ajout bétail
      score++;
      scoreElem.textContent = `Bétail ramassé : ${score}`;
      messageElem.textContent = "Bétail ramassé ! Vitesse augmentée.";
      speed = Math.min(15, speed + 1);
      updateSpeed();
      growing = true;

      // Retirer le bétail ramassé
      setCell(newR, newC, CELL_TYPES.TRAIN_HEAD);

      // Ajouter un nouveau bétail aléatoire
      addBetail();
    }

    // Si on grandit, on ne retire pas la queue
    if(growing){
      growing = false;
    } else {
      // Retirer queue train
      const tail = train.shift();
      setCell(tail.r, tail.c, CELL_TYPES.EMPTY);
    }

    // Ajout automatique d'un bétail tous les 15 ticks
    if(ticks % 15 === 0){
      addBetail();
    }

    // Allonger le train automatiquement tous les 40 ticks pour augmenter la difficulté
    if(ticks % 40 === 0){
      growing = true;
      messageElem.textContent = "Train s'allonge automatiquement !";
    }

  }

  // Fin de partie
  function gameOver(reason){
    gameRunning = false;
    messageElem.textContent = "Game Over : " + reason;
    clearInterval(gameInterval);
  }

  // Gestion clavier
  window.addEventListener('keydown', (e) => {
    if(!gameRunning) return;
    switch(e.key){
      case "ArrowUp":
        // Flèche haut => avancer (ne change pas direction)
        // Pas de changement de direction, on avance dans la direction courante
        // Peut aussi servir à reprendre le jeu si pause ?
        e.preventDefault();
        // rien à faire, on continue
        break;
      case "ArrowLeft":
        e.preventDefault();
        nextTurn = 1; // tourner à gauche au prochain tick
        break;
      case "ArrowRight":
        e.preventDefault();
        nextTurn = 2; // tourner à droite au prochain tick
        break;
    }
  });

  startBtn.addEventListener('click', () => {
    initGame();
  });

</script>

</body>
</html>
