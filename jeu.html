<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Train Bétail - Jeu Snake amélioré</title>
<style>
  body {
    background-color: #000;
    color: #0ff;
    font-family: 'Orbitron', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0; padding: 0;
    user-select: none;
  }
  h1 {
    margin-top: 20px;
  }
  #gameCanvas {
    background-color: #111;
    border: 3px solid #0ff;
    margin-top: 20px;
    display: block;
  }
  #info {
    margin-top: 15px;
    font-size: 18px;
    text-align: center;
    max-width: 400px;
  }
  #scoreDisplay {
    margin-top: 10px;
    font-size: 24px;
    font-weight: bold;
    color: yellow;
  }
  #gameOverOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.9);
    color: #f33;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-family: 'Orbitron', monospace;
    font-size: 32px;
    z-index: 1000;
    visibility: hidden;
  }
  #gameOverOverlay button {
    margin-top: 20px;
    font-size: 20px;
    padding: 10px 20px;
    background: #0ff;
    border: none;
    color: #000;
    cursor: pointer;
    border-radius: 5px;
    font-weight: bold;
  }
  #gameOverOverlay button:hover {
    background: #0cc;
  }
</style>
</head>
<body>

<h1>Train Bétail - Évite les suppressions !</h1>
<canvas id="gameCanvas" width="400" height="400"></canvas>
<div id="info">
  Utilise <b>flèches</b> pour tourner.<br>
  Mange le <span style="color: yellow;">bétail jaune</span> pour grandir.<br>
  Évite les <span style="color: red;">cases rouges (suppression)</span>.<br>
  Les <span style="color: orange;">cases oranges</span> ralentissent ou accélèrent le train pendant 2s.<br>
  La vitesse augmente progressivement avec le temps.<br>
</div>
<div id="scoreDisplay">Score : 0</div>

<div id="gameOverOverlay">
  <div id="gameOverText"></div>
  <button id="restartBtn">Recommencer</button>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const scoreDisplay = document.getElementById("scoreDisplay");
  const gameOverOverlay = document.getElementById("gameOverOverlay");
  const gameOverText = document.getElementById("gameOverText");
  const restartBtn = document.getElementById("restartBtn");

  const gridSize = 20;
  const cols = canvas.width / gridSize;
  const rows = canvas.height / gridSize;

  const colorTrainHead = "#0ff";
  const colorTrainBody = "#088";
  const colorSuppression = "#f33";
  const colorAcceleration = "#f90";
  const colorBetail = "#ff0";

  let train = [{ x: Math.floor(cols/2), y: Math.floor(rows/2) }];
  let direction = { x: 0, y: -1 }; // initial vers le haut
  let nextDirection = direction;

  let speed = 300;
  let baseSpeed = 300;
  let speedModifier = 0; // en ms, ajouté ou retiré temporairement
  let speedEffectTimeout = null;

  let betail = null; // case jaune (bétail)
  let suppressions = [];
  let oranges = [];

  let score = 0;

  let gameRunning = true;
  let speedIncreaseTimeout;

  function randomFreePosition() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows) };
    } while (
      isOnTrain(pos) ||
      isOnSuppression(pos) ||
      isOnOrange(pos) ||
      (betail && betail.x === pos.x && betail.y === pos.y)
    );
    return pos;
  }

  function isOnTrain(pos) {
    return train.some(t => t.x === pos.x && t.y === pos.y);
  }

  function isOnSuppression(pos) {
    return suppressions.some(p => p.x === pos.x && p.y === pos.y);
  }

  function isOnOrange(pos) {
    return oranges.some(p => p.x === pos.x && p.y === pos.y);
  }

  function placePerturbations() {
    suppressions = [];
    for(let i = 0; i < 8; i++) {
      suppressions.push(randomFreePosition());
    }
    oranges = [];
    for(let i = 0; i < 5; i++) {
      oranges.push(randomFreePosition());
    }
    betail = randomFreePosition();
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grille
    ctx.strokeStyle = "#222";
    for(let x = 0; x <= cols; x++) {
      ctx.beginPath();
      ctx.moveTo(x * gridSize, 0);
      ctx.lineTo(x * gridSize, canvas.height);
      ctx.stroke();
    }
    for(let y = 0; y <= rows; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * gridSize);
      ctx.lineTo(canvas.width, y * gridSize);
      ctx.stroke();
    }

    // Suppressions rouges
    suppressions.forEach(p => {
      ctx.fillStyle = colorSuppression;
      ctx.fillRect(p.x * gridSize + 2, p.y * gridSize + 2, gridSize - 4, gridSize - 4);
    });

    // Oranges (bonus/malus)
    oranges.forEach(p => {
      ctx.fillStyle = colorAcceleration;
      ctx.fillRect(p.x * gridSize + 4, p.y * gridSize + 4, gridSize - 8, gridSize - 8);
    });

    // Bétail jaune
    if (betail) {
      ctx.fillStyle = colorBetail;
      ctx.beginPath();
      const cx = betail.x * gridSize + gridSize/2;
      const cy = betail.y * gridSize + gridSize/2;
      const radius = gridSize/3;
      ctx.arc(cx, cy, radius, 0, 2*Math.PI);
      ctx.fill();
    }

    // Train
    train.forEach((pos, i) => {
      ctx.fillStyle = (i === 0) ? colorTrainHead : colorTrainBody;
      ctx.fillRect(pos.x * gridSize + 1, pos.y * gridSize + 1, gridSize - 2, gridSize - 2);
    });
  }

  function increaseSpeedOverTime() {
    if (baseSpeed > 80) {
      baseSpeed -= 10; // accélère le jeu
    }
    speedIncreaseTimeout = setTimeout(() => {
      increaseSpeedOverTime();
    }, 15000);
  }

  function applySpeedEffect(modifier) {
    speedModifier = modifier;
    if(speedEffectTimeout) clearTimeout(speedEffectTimeout);
    speedEffectTimeout = setTimeout(() => {
      speedModifier = 0;
    }, 2000);
  }

  function gameLoop() {
    if (!gameRunning) return;

    if ((nextDirection.x !== -direction.x || nextDirection.y !== -direction.y)) {
      direction = nextDirection;
    }

    const head = { x: train[0].x + direction.x, y: train[0].y + direction.y };

    if (head.x < 0) head.x = cols - 1;
    else if (head.x >= cols) head.x = 0;
    if (head.y < 0) head.y = rows - 1;
    else if (head.y >= rows) head.y = 0;

    if (train.slice(0, -1).some(t => t.x === head.x && t.y === head.y)) {
      gameOver("Collision avec votre propre train !");
      return;
    }

    if (isOnSuppression(head)) {
      gameOver("Votre train a rencontré une suppression !");
      return;
    }

    train.unshift(head);

    if (betail && head.x === betail.x && head.y === betail.y) {
      score++;
      scoreDisplay.textContent = "Score : " + score;
      betail = randomFreePosition();
    } else {
      train.pop();
    }

    if (isOnOrange(head)) {
      if (Math.random() < 0.5) {
        applySpeedEffect(-100);
      } else {
        applySpeedEffect(150);
      }
      oranges = oranges.filter(p => !(p.x === head.x && p.y === head.y));
      oranges.push(randomFreePosition());
    }

    speed = Math.max(80, baseSpeed + speedModifier);

    draw();
    setTimeout(gameLoop, speed);
  }

  function resetGame() {
    train = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
    direction = { x: 0, y: -1 };
    nextDirection = direction;
    baseSpeed = 300;
    speedModifier = 0;
    score = 0;
    scoreDisplay.textContent = "Score : " + score;
    gameRunning = true;
    placePerturbations();
    draw();
    clearTimeout(speedIncreaseTimeout);
    increaseSpeedOverTime();
    gameOverOverlay.style.visibility = "hidden";
    gameLoop();
  }

  function gameOver(message) {
    gameRunning = false;
    clearTimeout(speedIncreaseTimeout);
    gameOverText.textContent = message + "\nScore final : " + score;
    gameOverOverlay.style.visibility = "visible";
  }

  window.addEventListener("keydown", e => {
    switch(e.key) {
    case 'ArrowUp':
      if (direction !== 'down') direction = 'up';
      break;
    case 'ArrowDown':
      if (direction !== 'up') direction = 'down';
      break;
    case 'ArrowLeft':
      if (direction !== 'right') direction = 'left';
      break;
    case 'ArrowRight':
      if (direction !== 'left') direction = 'right';
      break;
  }
});

  restartBtn.addEventListener("click", () => {
    resetGame();
  });

  resetGame();
})();
</script>

</body>
</html>
